// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: pos/tokenomics/v1/query.proto

package types

import (
	context "context"
	cosmossdk_io_math "cosmossdk.io/math"
	fmt "fmt"
	_ "github.com/cosmos/cosmos-proto"
	query "github.com/cosmos/cosmos-sdk/types/query"
	_ "github.com/cosmos/cosmos-sdk/types/tx/amino"
	_ "github.com/cosmos/gogoproto/gogoproto"
	grpc1 "github.com/cosmos/gogoproto/grpc"
	proto "github.com/cosmos/gogoproto/proto"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// QueryParamsRequest is request type for the Query/Params RPC method.
type QueryParamsRequest struct {
}

func (m *QueryParamsRequest) Reset()         { *m = QueryParamsRequest{} }
func (m *QueryParamsRequest) String() string { return proto.CompactTextString(m) }
func (*QueryParamsRequest) ProtoMessage()    {}
func (*QueryParamsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ff681edaa2931a07, []int{0}
}
func (m *QueryParamsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryParamsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryParamsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryParamsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryParamsRequest.Merge(m, src)
}
func (m *QueryParamsRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryParamsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryParamsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryParamsRequest proto.InternalMessageInfo

// QueryParamsResponse is response type for the Query/Params RPC method.
type QueryParamsResponse struct {
	// params holds all the parameters of this module.
	Params TokenomicsParams `protobuf:"bytes,1,opt,name=params,proto3" json:"params"`
}

func (m *QueryParamsResponse) Reset()         { *m = QueryParamsResponse{} }
func (m *QueryParamsResponse) String() string { return proto.CompactTextString(m) }
func (*QueryParamsResponse) ProtoMessage()    {}
func (*QueryParamsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ff681edaa2931a07, []int{1}
}
func (m *QueryParamsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryParamsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryParamsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryParamsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryParamsResponse.Merge(m, src)
}
func (m *QueryParamsResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryParamsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryParamsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryParamsResponse proto.InternalMessageInfo

func (m *QueryParamsResponse) GetParams() TokenomicsParams {
	if m != nil {
		return m.Params
	}
	return TokenomicsParams{}
}

// QuerySupplyRequest is request type for the Query/Supply RPC method.
type QuerySupplyRequest struct {
}

func (m *QuerySupplyRequest) Reset()         { *m = QuerySupplyRequest{} }
func (m *QuerySupplyRequest) String() string { return proto.CompactTextString(m) }
func (*QuerySupplyRequest) ProtoMessage()    {}
func (*QuerySupplyRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ff681edaa2931a07, []int{2}
}
func (m *QuerySupplyRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QuerySupplyRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QuerySupplyRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QuerySupplyRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QuerySupplyRequest.Merge(m, src)
}
func (m *QuerySupplyRequest) XXX_Size() int {
	return m.Size()
}
func (m *QuerySupplyRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QuerySupplyRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QuerySupplyRequest proto.InternalMessageInfo

// QuerySupplyResponse is response type for the Query/Supply RPC method.
type QuerySupplyResponse struct {
	// total_supply_cap is the hard maximum (1.5B OMNI)
	TotalSupplyCap cosmossdk_io_math.Int `protobuf:"bytes,1,opt,name=total_supply_cap,json=totalSupplyCap,proto3,customtype=cosmossdk.io/math.Int" json:"total_supply_cap"`
	// current_total_supply is the current circulating supply
	CurrentTotalSupply cosmossdk_io_math.Int `protobuf:"bytes,2,opt,name=current_total_supply,json=currentTotalSupply,proto3,customtype=cosmossdk.io/math.Int" json:"current_total_supply"`
	// total_minted is the cumulative minted amount
	TotalMinted cosmossdk_io_math.Int `protobuf:"bytes,3,opt,name=total_minted,json=totalMinted,proto3,customtype=cosmossdk.io/math.Int" json:"total_minted"`
	// total_burned is the cumulative burned amount
	TotalBurned cosmossdk_io_math.Int `protobuf:"bytes,4,opt,name=total_burned,json=totalBurned,proto3,customtype=cosmossdk.io/math.Int" json:"total_burned"`
	// remaining_mintable is how much can still be minted
	RemainingMintable cosmossdk_io_math.Int `protobuf:"bytes,5,opt,name=remaining_mintable,json=remainingMintable,proto3,customtype=cosmossdk.io/math.Int" json:"remaining_mintable"`
	// supply_pct_of_cap is the current supply as % of cap (0.0-1.0)
	SupplyPctOfCap cosmossdk_io_math.LegacyDec `protobuf:"bytes,6,opt,name=supply_pct_of_cap,json=supplyPctOfCap,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"supply_pct_of_cap"`
	// net_inflation_rate is the effective growth rate (minting - burning)
	NetInflationRate cosmossdk_io_math.LegacyDec `protobuf:"bytes,7,opt,name=net_inflation_rate,json=netInflationRate,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"net_inflation_rate"`
}

func (m *QuerySupplyResponse) Reset()         { *m = QuerySupplyResponse{} }
func (m *QuerySupplyResponse) String() string { return proto.CompactTextString(m) }
func (*QuerySupplyResponse) ProtoMessage()    {}
func (*QuerySupplyResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ff681edaa2931a07, []int{3}
}
func (m *QuerySupplyResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QuerySupplyResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QuerySupplyResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QuerySupplyResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QuerySupplyResponse.Merge(m, src)
}
func (m *QuerySupplyResponse) XXX_Size() int {
	return m.Size()
}
func (m *QuerySupplyResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QuerySupplyResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QuerySupplyResponse proto.InternalMessageInfo

// QueryInflationRequest is request type for the Query/Inflation RPC method.
type QueryInflationRequest struct {
}

func (m *QueryInflationRequest) Reset()         { *m = QueryInflationRequest{} }
func (m *QueryInflationRequest) String() string { return proto.CompactTextString(m) }
func (*QueryInflationRequest) ProtoMessage()    {}
func (*QueryInflationRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ff681edaa2931a07, []int{4}
}
func (m *QueryInflationRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryInflationRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryInflationRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryInflationRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryInflationRequest.Merge(m, src)
}
func (m *QueryInflationRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryInflationRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryInflationRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryInflationRequest proto.InternalMessageInfo

// QueryInflationResponse is response type for the Query/Inflation RPC method.
type QueryInflationResponse struct {
	// current_inflation_rate is the current annual inflation (0.01-0.05)
	CurrentInflationRate cosmossdk_io_math.LegacyDec `protobuf:"bytes,1,opt,name=current_inflation_rate,json=currentInflationRate,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"current_inflation_rate"`
	// inflation_min is the DAO floor
	InflationMin cosmossdk_io_math.LegacyDec `protobuf:"bytes,2,opt,name=inflation_min,json=inflationMin,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"inflation_min"`
	// inflation_max is the protocol cap
	InflationMax cosmossdk_io_math.LegacyDec `protobuf:"bytes,3,opt,name=inflation_max,json=inflationMax,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"inflation_max"`
	// annual_provisions is the expected tokens minted this year
	AnnualProvisions cosmossdk_io_math.Int `protobuf:"bytes,4,opt,name=annual_provisions,json=annualProvisions,proto3,customtype=cosmossdk.io/math.Int" json:"annual_provisions"`
	// block_provisions is the tokens minted per block
	BlockProvisions cosmossdk_io_math.LegacyDec `protobuf:"bytes,5,opt,name=block_provisions,json=blockProvisions,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"block_provisions"`
	// blocks_per_year is the estimated annual block count
	BlocksPerYear uint64 `protobuf:"varint,6,opt,name=blocks_per_year,json=blocksPerYear,proto3" json:"blocks_per_year,omitempty"`
}

func (m *QueryInflationResponse) Reset()         { *m = QueryInflationResponse{} }
func (m *QueryInflationResponse) String() string { return proto.CompactTextString(m) }
func (*QueryInflationResponse) ProtoMessage()    {}
func (*QueryInflationResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ff681edaa2931a07, []int{5}
}
func (m *QueryInflationResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryInflationResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryInflationResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryInflationResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryInflationResponse.Merge(m, src)
}
func (m *QueryInflationResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryInflationResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryInflationResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryInflationResponse proto.InternalMessageInfo

func (m *QueryInflationResponse) GetBlocksPerYear() uint64 {
	if m != nil {
		return m.BlocksPerYear
	}
	return 0
}

// QueryEmissionsRequest is request type for the Query/Emissions RPC method.
type QueryEmissionsRequest struct {
}

func (m *QueryEmissionsRequest) Reset()         { *m = QueryEmissionsRequest{} }
func (m *QueryEmissionsRequest) String() string { return proto.CompactTextString(m) }
func (*QueryEmissionsRequest) ProtoMessage()    {}
func (*QueryEmissionsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ff681edaa2931a07, []int{6}
}
func (m *QueryEmissionsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryEmissionsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryEmissionsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryEmissionsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryEmissionsRequest.Merge(m, src)
}
func (m *QueryEmissionsRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryEmissionsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryEmissionsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryEmissionsRequest proto.InternalMessageInfo

// EmissionAllocation shows how inflation is distributed
type EmissionAllocation struct {
	// category is the emission category (staking, poc, sequencer, treasury)
	Category string `protobuf:"bytes,1,opt,name=category,proto3" json:"category,omitempty"`
	// percentage is the allocation percentage (0.0-1.0)
	Percentage cosmossdk_io_math.LegacyDec `protobuf:"bytes,2,opt,name=percentage,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"percentage"`
	// annual_amount is the estimated yearly allocation
	AnnualAmount cosmossdk_io_math.Int `protobuf:"bytes,3,opt,name=annual_amount,json=annualAmount,proto3,customtype=cosmossdk.io/math.Int" json:"annual_amount"`
	// total_distributed is the cumulative amount distributed
	TotalDistributed cosmossdk_io_math.Int `protobuf:"bytes,4,opt,name=total_distributed,json=totalDistributed,proto3,customtype=cosmossdk.io/math.Int" json:"total_distributed"`
}

func (m *EmissionAllocation) Reset()         { *m = EmissionAllocation{} }
func (m *EmissionAllocation) String() string { return proto.CompactTextString(m) }
func (*EmissionAllocation) ProtoMessage()    {}
func (*EmissionAllocation) Descriptor() ([]byte, []int) {
	return fileDescriptor_ff681edaa2931a07, []int{7}
}
func (m *EmissionAllocation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EmissionAllocation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EmissionAllocation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EmissionAllocation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EmissionAllocation.Merge(m, src)
}
func (m *EmissionAllocation) XXX_Size() int {
	return m.Size()
}
func (m *EmissionAllocation) XXX_DiscardUnknown() {
	xxx_messageInfo_EmissionAllocation.DiscardUnknown(m)
}

var xxx_messageInfo_EmissionAllocation proto.InternalMessageInfo

func (m *EmissionAllocation) GetCategory() string {
	if m != nil {
		return m.Category
	}
	return ""
}

// QueryEmissionsResponse is response type for the Query/Emissions RPC method.
type QueryEmissionsResponse struct {
	// allocations shows the emission splits
	Allocations []EmissionAllocation `protobuf:"bytes,1,rep,name=allocations,proto3" json:"allocations"`
	// total_annual_emissions is the total yearly inflation
	TotalAnnualEmissions cosmossdk_io_math.Int `protobuf:"bytes,2,opt,name=total_annual_emissions,json=totalAnnualEmissions,proto3,customtype=cosmossdk.io/math.Int" json:"total_annual_emissions"`
	// last_distribution_height is the last block that distributed rewards
	LastDistributionHeight int64 `protobuf:"varint,3,opt,name=last_distribution_height,json=lastDistributionHeight,proto3" json:"last_distribution_height,omitempty"`
}

func (m *QueryEmissionsResponse) Reset()         { *m = QueryEmissionsResponse{} }
func (m *QueryEmissionsResponse) String() string { return proto.CompactTextString(m) }
func (*QueryEmissionsResponse) ProtoMessage()    {}
func (*QueryEmissionsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ff681edaa2931a07, []int{8}
}
func (m *QueryEmissionsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryEmissionsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryEmissionsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryEmissionsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryEmissionsResponse.Merge(m, src)
}
func (m *QueryEmissionsResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryEmissionsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryEmissionsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryEmissionsResponse proto.InternalMessageInfo

func (m *QueryEmissionsResponse) GetAllocations() []EmissionAllocation {
	if m != nil {
		return m.Allocations
	}
	return nil
}

func (m *QueryEmissionsResponse) GetLastDistributionHeight() int64 {
	if m != nil {
		return m.LastDistributionHeight
	}
	return 0
}

// QueryBurnsRequest is request type for the Query/Burns RPC method.
type QueryBurnsRequest struct {
	// pagination defines an optional pagination for the request.
	Pagination *query.PageRequest `protobuf:"bytes,1,opt,name=pagination,proto3" json:"pagination,omitempty"`
}

func (m *QueryBurnsRequest) Reset()         { *m = QueryBurnsRequest{} }
func (m *QueryBurnsRequest) String() string { return proto.CompactTextString(m) }
func (*QueryBurnsRequest) ProtoMessage()    {}
func (*QueryBurnsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ff681edaa2931a07, []int{9}
}
func (m *QueryBurnsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryBurnsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryBurnsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryBurnsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryBurnsRequest.Merge(m, src)
}
func (m *QueryBurnsRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryBurnsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryBurnsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryBurnsRequest proto.InternalMessageInfo

func (m *QueryBurnsRequest) GetPagination() *query.PageRequest {
	if m != nil {
		return m.Pagination
	}
	return nil
}

// BurnRecord represents a single burn event
type BurnRecord struct {
	// burn_id is a unique identifier
	BurnId uint64 `protobuf:"varint,1,opt,name=burn_id,json=burnId,proto3" json:"burn_id,omitempty"`
	// amount is the burned amount
	Amount cosmossdk_io_math.Int `protobuf:"bytes,2,opt,name=amount,proto3,customtype=cosmossdk.io/math.Int" json:"amount"`
	// source is the burn source type
	Source BurnSource `protobuf:"varint,3,opt,name=source,proto3,enum=pos.tokenomics.v1.BurnSource" json:"source,omitempty"`
	// chain_id is where the burn occurred
	ChainId string `protobuf:"bytes,4,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	// block_height is when the burn occurred
	BlockHeight int64 `protobuf:"varint,5,opt,name=block_height,json=blockHeight,proto3" json:"block_height,omitempty"`
	// tx_hash is the transaction hash
	TxHash string `protobuf:"bytes,6,opt,name=tx_hash,json=txHash,proto3" json:"tx_hash,omitempty"`
	// timestamp is the block timestamp
	Timestamp int64 `protobuf:"varint,7,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	// burner_address is who initiated the burn
	BurnerAddress string `protobuf:"bytes,8,opt,name=burner_address,json=burnerAddress,proto3" json:"burner_address,omitempty"`
	// treasury_redirect is the amount sent to treasury instead of burned
	TreasuryRedirect cosmossdk_io_math.Int `protobuf:"bytes,9,opt,name=treasury_redirect,json=treasuryRedirect,proto3,customtype=cosmossdk.io/math.Int" json:"treasury_redirect"`
}

func (m *BurnRecord) Reset()         { *m = BurnRecord{} }
func (m *BurnRecord) String() string { return proto.CompactTextString(m) }
func (*BurnRecord) ProtoMessage()    {}
func (*BurnRecord) Descriptor() ([]byte, []int) {
	return fileDescriptor_ff681edaa2931a07, []int{10}
}
func (m *BurnRecord) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BurnRecord) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BurnRecord.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BurnRecord) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BurnRecord.Merge(m, src)
}
func (m *BurnRecord) XXX_Size() int {
	return m.Size()
}
func (m *BurnRecord) XXX_DiscardUnknown() {
	xxx_messageInfo_BurnRecord.DiscardUnknown(m)
}

var xxx_messageInfo_BurnRecord proto.InternalMessageInfo

func (m *BurnRecord) GetBurnId() uint64 {
	if m != nil {
		return m.BurnId
	}
	return 0
}

func (m *BurnRecord) GetSource() BurnSource {
	if m != nil {
		return m.Source
	}
	return BurnSource_BURN_SOURCE_UNSPECIFIED
}

func (m *BurnRecord) GetChainId() string {
	if m != nil {
		return m.ChainId
	}
	return ""
}

func (m *BurnRecord) GetBlockHeight() int64 {
	if m != nil {
		return m.BlockHeight
	}
	return 0
}

func (m *BurnRecord) GetTxHash() string {
	if m != nil {
		return m.TxHash
	}
	return ""
}

func (m *BurnRecord) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *BurnRecord) GetBurnerAddress() string {
	if m != nil {
		return m.BurnerAddress
	}
	return ""
}

// QueryBurnsResponse is response type for the Query/Burns RPC method.
type QueryBurnsResponse struct {
	// burns is the list of burn records
	Burns []BurnRecord `protobuf:"bytes,1,rep,name=burns,proto3" json:"burns"`
	// pagination defines the pagination in the response.
	Pagination *query.PageResponse `protobuf:"bytes,2,opt,name=pagination,proto3" json:"pagination,omitempty"`
	// total_burned is the cumulative burned amount
	TotalBurned cosmossdk_io_math.Int `protobuf:"bytes,3,opt,name=total_burned,json=totalBurned,proto3,customtype=cosmossdk.io/math.Int" json:"total_burned"`
}

func (m *QueryBurnsResponse) Reset()         { *m = QueryBurnsResponse{} }
func (m *QueryBurnsResponse) String() string { return proto.CompactTextString(m) }
func (*QueryBurnsResponse) ProtoMessage()    {}
func (*QueryBurnsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ff681edaa2931a07, []int{11}
}
func (m *QueryBurnsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryBurnsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryBurnsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryBurnsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryBurnsResponse.Merge(m, src)
}
func (m *QueryBurnsResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryBurnsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryBurnsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryBurnsResponse proto.InternalMessageInfo

func (m *QueryBurnsResponse) GetBurns() []BurnRecord {
	if m != nil {
		return m.Burns
	}
	return nil
}

func (m *QueryBurnsResponse) GetPagination() *query.PageResponse {
	if m != nil {
		return m.Pagination
	}
	return nil
}

// QueryBurnsBySourceRequest is request type for the Query/BurnsBySource RPC method.
type QueryBurnsBySourceRequest struct {
	// source is the burn source to filter by
	Source BurnSource `protobuf:"varint,1,opt,name=source,proto3,enum=pos.tokenomics.v1.BurnSource" json:"source,omitempty"`
	// pagination defines an optional pagination for the request.
	Pagination *query.PageRequest `protobuf:"bytes,2,opt,name=pagination,proto3" json:"pagination,omitempty"`
}

func (m *QueryBurnsBySourceRequest) Reset()         { *m = QueryBurnsBySourceRequest{} }
func (m *QueryBurnsBySourceRequest) String() string { return proto.CompactTextString(m) }
func (*QueryBurnsBySourceRequest) ProtoMessage()    {}
func (*QueryBurnsBySourceRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ff681edaa2931a07, []int{12}
}
func (m *QueryBurnsBySourceRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryBurnsBySourceRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryBurnsBySourceRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryBurnsBySourceRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryBurnsBySourceRequest.Merge(m, src)
}
func (m *QueryBurnsBySourceRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryBurnsBySourceRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryBurnsBySourceRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryBurnsBySourceRequest proto.InternalMessageInfo

func (m *QueryBurnsBySourceRequest) GetSource() BurnSource {
	if m != nil {
		return m.Source
	}
	return BurnSource_BURN_SOURCE_UNSPECIFIED
}

func (m *QueryBurnsBySourceRequest) GetPagination() *query.PageRequest {
	if m != nil {
		return m.Pagination
	}
	return nil
}

// BurnsBySourceStats provides statistics for a specific burn source
type BurnsBySourceStats struct {
	// source is the burn source
	Source BurnSource `protobuf:"varint,1,opt,name=source,proto3,enum=pos.tokenomics.v1.BurnSource" json:"source,omitempty"`
	// total_amount is the cumulative burned from this source
	TotalAmount cosmossdk_io_math.Int `protobuf:"bytes,2,opt,name=total_amount,json=totalAmount,proto3,customtype=cosmossdk.io/math.Int" json:"total_amount"`
	// burn_count is the number of burn events
	BurnCount uint64 `protobuf:"varint,3,opt,name=burn_count,json=burnCount,proto3" json:"burn_count,omitempty"`
	// current_burn_rate is the configured burn percentage
	CurrentBurnRate cosmossdk_io_math.LegacyDec `protobuf:"bytes,4,opt,name=current_burn_rate,json=currentBurnRate,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"current_burn_rate"`
	// average_burn_amount is the mean burn per event
	AverageBurnAmount cosmossdk_io_math.LegacyDec `protobuf:"bytes,5,opt,name=average_burn_amount,json=averageBurnAmount,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"average_burn_amount"`
}

func (m *BurnsBySourceStats) Reset()         { *m = BurnsBySourceStats{} }
func (m *BurnsBySourceStats) String() string { return proto.CompactTextString(m) }
func (*BurnsBySourceStats) ProtoMessage()    {}
func (*BurnsBySourceStats) Descriptor() ([]byte, []int) {
	return fileDescriptor_ff681edaa2931a07, []int{13}
}
func (m *BurnsBySourceStats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BurnsBySourceStats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BurnsBySourceStats.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BurnsBySourceStats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BurnsBySourceStats.Merge(m, src)
}
func (m *BurnsBySourceStats) XXX_Size() int {
	return m.Size()
}
func (m *BurnsBySourceStats) XXX_DiscardUnknown() {
	xxx_messageInfo_BurnsBySourceStats.DiscardUnknown(m)
}

var xxx_messageInfo_BurnsBySourceStats proto.InternalMessageInfo

func (m *BurnsBySourceStats) GetSource() BurnSource {
	if m != nil {
		return m.Source
	}
	return BurnSource_BURN_SOURCE_UNSPECIFIED
}

func (m *BurnsBySourceStats) GetBurnCount() uint64 {
	if m != nil {
		return m.BurnCount
	}
	return 0
}

// QueryBurnsBySourceResponse is response type for the Query/BurnsBySource RPC method.
type QueryBurnsBySourceResponse struct {
	// burns is the list of burn records
	Burns []BurnRecord `protobuf:"bytes,1,rep,name=burns,proto3" json:"burns"`
	// pagination defines the pagination in the response.
	Pagination *query.PageResponse `protobuf:"bytes,2,opt,name=pagination,proto3" json:"pagination,omitempty"`
	// stats provides aggregate statistics
	Stats BurnsBySourceStats `protobuf:"bytes,3,opt,name=stats,proto3" json:"stats"`
}

func (m *QueryBurnsBySourceResponse) Reset()         { *m = QueryBurnsBySourceResponse{} }
func (m *QueryBurnsBySourceResponse) String() string { return proto.CompactTextString(m) }
func (*QueryBurnsBySourceResponse) ProtoMessage()    {}
func (*QueryBurnsBySourceResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ff681edaa2931a07, []int{14}
}
func (m *QueryBurnsBySourceResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryBurnsBySourceResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryBurnsBySourceResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryBurnsBySourceResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryBurnsBySourceResponse.Merge(m, src)
}
func (m *QueryBurnsBySourceResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryBurnsBySourceResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryBurnsBySourceResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryBurnsBySourceResponse proto.InternalMessageInfo

func (m *QueryBurnsBySourceResponse) GetBurns() []BurnRecord {
	if m != nil {
		return m.Burns
	}
	return nil
}

func (m *QueryBurnsBySourceResponse) GetPagination() *query.PageResponse {
	if m != nil {
		return m.Pagination
	}
	return nil
}

func (m *QueryBurnsBySourceResponse) GetStats() BurnsBySourceStats {
	if m != nil {
		return m.Stats
	}
	return BurnsBySourceStats{}
}

// QueryBurnsByChainRequest is request type for the Query/BurnsByChain RPC method.
type QueryBurnsByChainRequest struct {
	// chain_id is the chain to filter by
	ChainId string `protobuf:"bytes,1,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	// pagination defines an optional pagination for the request.
	Pagination *query.PageRequest `protobuf:"bytes,2,opt,name=pagination,proto3" json:"pagination,omitempty"`
}

func (m *QueryBurnsByChainRequest) Reset()         { *m = QueryBurnsByChainRequest{} }
func (m *QueryBurnsByChainRequest) String() string { return proto.CompactTextString(m) }
func (*QueryBurnsByChainRequest) ProtoMessage()    {}
func (*QueryBurnsByChainRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ff681edaa2931a07, []int{15}
}
func (m *QueryBurnsByChainRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryBurnsByChainRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryBurnsByChainRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryBurnsByChainRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryBurnsByChainRequest.Merge(m, src)
}
func (m *QueryBurnsByChainRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryBurnsByChainRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryBurnsByChainRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryBurnsByChainRequest proto.InternalMessageInfo

func (m *QueryBurnsByChainRequest) GetChainId() string {
	if m != nil {
		return m.ChainId
	}
	return ""
}

func (m *QueryBurnsByChainRequest) GetPagination() *query.PageRequest {
	if m != nil {
		return m.Pagination
	}
	return nil
}

// QueryBurnsByChainResponse is response type for the Query/BurnsByChain RPC method.
type QueryBurnsByChainResponse struct {
	// burns is the list of burn records
	Burns []BurnRecord `protobuf:"bytes,1,rep,name=burns,proto3" json:"burns"`
	// pagination defines the pagination in the response.
	Pagination *query.PageResponse `protobuf:"bytes,2,opt,name=pagination,proto3" json:"pagination,omitempty"`
	// total_burned_on_chain is the cumulative burns from this chain
	TotalBurnedOnChain cosmossdk_io_math.Int `protobuf:"bytes,3,opt,name=total_burned_on_chain,json=totalBurnedOnChain,proto3,customtype=cosmossdk.io/math.Int" json:"total_burned_on_chain"`
}

func (m *QueryBurnsByChainResponse) Reset()         { *m = QueryBurnsByChainResponse{} }
func (m *QueryBurnsByChainResponse) String() string { return proto.CompactTextString(m) }
func (*QueryBurnsByChainResponse) ProtoMessage()    {}
func (*QueryBurnsByChainResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ff681edaa2931a07, []int{16}
}
func (m *QueryBurnsByChainResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryBurnsByChainResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryBurnsByChainResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryBurnsByChainResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryBurnsByChainResponse.Merge(m, src)
}
func (m *QueryBurnsByChainResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryBurnsByChainResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryBurnsByChainResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryBurnsByChainResponse proto.InternalMessageInfo

func (m *QueryBurnsByChainResponse) GetBurns() []BurnRecord {
	if m != nil {
		return m.Burns
	}
	return nil
}

func (m *QueryBurnsByChainResponse) GetPagination() *query.PageResponse {
	if m != nil {
		return m.Pagination
	}
	return nil
}

// QueryTreasuryRequest is request type for the Query/Treasury RPC method.
type QueryTreasuryRequest struct {
}

func (m *QueryTreasuryRequest) Reset()         { *m = QueryTreasuryRequest{} }
func (m *QueryTreasuryRequest) String() string { return proto.CompactTextString(m) }
func (*QueryTreasuryRequest) ProtoMessage()    {}
func (*QueryTreasuryRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ff681edaa2931a07, []int{17}
}
func (m *QueryTreasuryRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryTreasuryRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryTreasuryRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryTreasuryRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryTreasuryRequest.Merge(m, src)
}
func (m *QueryTreasuryRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryTreasuryRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryTreasuryRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryTreasuryRequest proto.InternalMessageInfo

// QueryTreasuryResponse is response type for the Query/Treasury RPC method.
type QueryTreasuryResponse struct {
	// treasury_balance is the current DAO treasury balance
	TreasuryBalance cosmossdk_io_math.Int `protobuf:"bytes,1,opt,name=treasury_balance,json=treasuryBalance,proto3,customtype=cosmossdk.io/math.Int" json:"treasury_balance"`
	// total_treasury_inflows is cumulative treasury deposits
	TotalTreasuryInflows cosmossdk_io_math.Int `protobuf:"bytes,2,opt,name=total_treasury_inflows,json=totalTreasuryInflows,proto3,customtype=cosmossdk.io/math.Int" json:"total_treasury_inflows"`
	// from_inflation is the amount from emission splits
	FromInflation cosmossdk_io_math.Int `protobuf:"bytes,3,opt,name=from_inflation,json=fromInflation,proto3,customtype=cosmossdk.io/math.Int" json:"from_inflation"`
	// from_burn_redirect is the amount from burn redirection
	FromBurnRedirect cosmossdk_io_math.Int `protobuf:"bytes,4,opt,name=from_burn_redirect,json=fromBurnRedirect,proto3,customtype=cosmossdk.io/math.Int" json:"from_burn_redirect"`
	// treasury_burn_redirect_pct is the current redirect percentage
	TreasuryBurnRedirectPct cosmossdk_io_math.LegacyDec `protobuf:"bytes,5,opt,name=treasury_burn_redirect_pct,json=treasuryBurnRedirectPct,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"treasury_burn_redirect_pct"`
	// treasury_address is the DAO treasury account
	TreasuryAddress string `protobuf:"bytes,6,opt,name=treasury_address,json=treasuryAddress,proto3" json:"treasury_address,omitempty"`
}

func (m *QueryTreasuryResponse) Reset()         { *m = QueryTreasuryResponse{} }
func (m *QueryTreasuryResponse) String() string { return proto.CompactTextString(m) }
func (*QueryTreasuryResponse) ProtoMessage()    {}
func (*QueryTreasuryResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ff681edaa2931a07, []int{18}
}
func (m *QueryTreasuryResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryTreasuryResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryTreasuryResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryTreasuryResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryTreasuryResponse.Merge(m, src)
}
func (m *QueryTreasuryResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryTreasuryResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryTreasuryResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryTreasuryResponse proto.InternalMessageInfo

func (m *QueryTreasuryResponse) GetTreasuryAddress() string {
	if m != nil {
		return m.TreasuryAddress
	}
	return ""
}

// QueryProjectionsRequest is request type for the Query/Projections RPC method.
type QueryProjectionsRequest struct {
	// years_ahead is how many years to project (1-10)
	YearsAhead uint32 `protobuf:"varint,1,opt,name=years_ahead,json=yearsAhead,proto3" json:"years_ahead,omitempty"`
	// assume_constant_burn_rate uses current burn rates for projection
	AssumeConstantBurnRate bool `protobuf:"varint,2,opt,name=assume_constant_burn_rate,json=assumeConstantBurnRate,proto3" json:"assume_constant_burn_rate,omitempty"`
}

func (m *QueryProjectionsRequest) Reset()         { *m = QueryProjectionsRequest{} }
func (m *QueryProjectionsRequest) String() string { return proto.CompactTextString(m) }
func (*QueryProjectionsRequest) ProtoMessage()    {}
func (*QueryProjectionsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ff681edaa2931a07, []int{19}
}
func (m *QueryProjectionsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryProjectionsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryProjectionsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryProjectionsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryProjectionsRequest.Merge(m, src)
}
func (m *QueryProjectionsRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryProjectionsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryProjectionsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryProjectionsRequest proto.InternalMessageInfo

func (m *QueryProjectionsRequest) GetYearsAhead() uint32 {
	if m != nil {
		return m.YearsAhead
	}
	return 0
}

func (m *QueryProjectionsRequest) GetAssumeConstantBurnRate() bool {
	if m != nil {
		return m.AssumeConstantBurnRate
	}
	return false
}

// SupplyProjection shows projected supply at a future date
type SupplyProjection struct {
	// year is the number of years from now
	Year uint32 `protobuf:"varint,1,opt,name=year,proto3" json:"year,omitempty"`
	// projected_supply is the estimated total supply
	ProjectedSupply cosmossdk_io_math.Int `protobuf:"bytes,2,opt,name=projected_supply,json=projectedSupply,proto3,customtype=cosmossdk.io/math.Int" json:"projected_supply"`
	// projected_minted is the estimated cumulative minting
	ProjectedMinted cosmossdk_io_math.Int `protobuf:"bytes,3,opt,name=projected_minted,json=projectedMinted,proto3,customtype=cosmossdk.io/math.Int" json:"projected_minted"`
	// projected_burned is the estimated cumulative burning
	ProjectedBurned cosmossdk_io_math.Int `protobuf:"bytes,4,opt,name=projected_burned,json=projectedBurned,proto3,customtype=cosmossdk.io/math.Int" json:"projected_burned"`
	// net_growth_rate is the effective annual growth rate
	NetGrowthRate cosmossdk_io_math.LegacyDec `protobuf:"bytes,5,opt,name=net_growth_rate,json=netGrowthRate,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"net_growth_rate"`
	// years_until_cap is the estimated years until supply cap (0 if never)
	YearsUntilCap uint32 `protobuf:"varint,6,opt,name=years_until_cap,json=yearsUntilCap,proto3" json:"years_until_cap,omitempty"`
}

func (m *SupplyProjection) Reset()         { *m = SupplyProjection{} }
func (m *SupplyProjection) String() string { return proto.CompactTextString(m) }
func (*SupplyProjection) ProtoMessage()    {}
func (*SupplyProjection) Descriptor() ([]byte, []int) {
	return fileDescriptor_ff681edaa2931a07, []int{20}
}
func (m *SupplyProjection) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SupplyProjection) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SupplyProjection.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SupplyProjection) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SupplyProjection.Merge(m, src)
}
func (m *SupplyProjection) XXX_Size() int {
	return m.Size()
}
func (m *SupplyProjection) XXX_DiscardUnknown() {
	xxx_messageInfo_SupplyProjection.DiscardUnknown(m)
}

var xxx_messageInfo_SupplyProjection proto.InternalMessageInfo

func (m *SupplyProjection) GetYear() uint32 {
	if m != nil {
		return m.Year
	}
	return 0
}

func (m *SupplyProjection) GetYearsUntilCap() uint32 {
	if m != nil {
		return m.YearsUntilCap
	}
	return 0
}

// QueryProjectionsResponse is response type for the Query/Projections RPC method.
type QueryProjectionsResponse struct {
	// projections is the list of yearly projections
	Projections []SupplyProjection `protobuf:"bytes,1,rep,name=projections,proto3" json:"projections"`
	// assumptions describes the projection assumptions
	Assumptions string `protobuf:"bytes,2,opt,name=assumptions,proto3" json:"assumptions,omitempty"`
}

func (m *QueryProjectionsResponse) Reset()         { *m = QueryProjectionsResponse{} }
func (m *QueryProjectionsResponse) String() string { return proto.CompactTextString(m) }
func (*QueryProjectionsResponse) ProtoMessage()    {}
func (*QueryProjectionsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ff681edaa2931a07, []int{21}
}
func (m *QueryProjectionsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryProjectionsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryProjectionsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryProjectionsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryProjectionsResponse.Merge(m, src)
}
func (m *QueryProjectionsResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryProjectionsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryProjectionsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryProjectionsResponse proto.InternalMessageInfo

func (m *QueryProjectionsResponse) GetProjections() []SupplyProjection {
	if m != nil {
		return m.Projections
	}
	return nil
}

func (m *QueryProjectionsResponse) GetAssumptions() string {
	if m != nil {
		return m.Assumptions
	}
	return ""
}

// QueryChainMetricsRequest is request type for the Query/ChainMetrics RPC method.
type QueryChainMetricsRequest struct {
	// chain_id is the chain to query
	ChainId string `protobuf:"bytes,1,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
}

func (m *QueryChainMetricsRequest) Reset()         { *m = QueryChainMetricsRequest{} }
func (m *QueryChainMetricsRequest) String() string { return proto.CompactTextString(m) }
func (*QueryChainMetricsRequest) ProtoMessage()    {}
func (*QueryChainMetricsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ff681edaa2931a07, []int{22}
}
func (m *QueryChainMetricsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryChainMetricsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryChainMetricsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryChainMetricsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryChainMetricsRequest.Merge(m, src)
}
func (m *QueryChainMetricsRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryChainMetricsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryChainMetricsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryChainMetricsRequest proto.InternalMessageInfo

func (m *QueryChainMetricsRequest) GetChainId() string {
	if m != nil {
		return m.ChainId
	}
	return ""
}

// QueryChainMetricsResponse is response type for the Query/ChainMetrics RPC method.
type QueryChainMetricsResponse struct {
	// chain_id is the chain identifier
	ChainId string `protobuf:"bytes,1,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	// total_burned is the cumulative burns from this chain
	TotalBurned cosmossdk_io_math.Int `protobuf:"bytes,2,opt,name=total_burned,json=totalBurned,proto3,customtype=cosmossdk.io/math.Int" json:"total_burned"`
	// total_rewards_received is the cumulative IBC rewards sent to this chain
	TotalRewardsReceived cosmossdk_io_math.Int `protobuf:"bytes,3,opt,name=total_rewards_received,json=totalRewardsReceived,proto3,customtype=cosmossdk.io/math.Int" json:"total_rewards_received"`
	// net_flow is the net token flow (rewards received - burns)
	NetFlow cosmossdk_io_math.Int `protobuf:"bytes,4,opt,name=net_flow,json=netFlow,proto3,customtype=cosmossdk.io/math.Int" json:"net_flow"`
	// ibc_channel is the IBC channel to Core chain
	IbcChannel string `protobuf:"bytes,5,opt,name=ibc_channel,json=ibcChannel,proto3" json:"ibc_channel,omitempty"`
	// gas_conversion_ratio is the gas price multiplier vs Core
	GasConversionRatio cosmossdk_io_math.LegacyDec `protobuf:"bytes,6,opt,name=gas_conversion_ratio,json=gasConversionRatio,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"gas_conversion_ratio"`
	// last_reward_height is the last block that received IBC rewards
	LastRewardHeight int64 `protobuf:"varint,7,opt,name=last_reward_height,json=lastRewardHeight,proto3" json:"last_reward_height,omitempty"`
	// last_burn_report_height is the last block that reported burns to Core
	LastBurnReportHeight int64 `protobuf:"varint,8,opt,name=last_burn_report_height,json=lastBurnReportHeight,proto3" json:"last_burn_report_height,omitempty"`
}

func (m *QueryChainMetricsResponse) Reset()         { *m = QueryChainMetricsResponse{} }
func (m *QueryChainMetricsResponse) String() string { return proto.CompactTextString(m) }
func (*QueryChainMetricsResponse) ProtoMessage()    {}
func (*QueryChainMetricsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ff681edaa2931a07, []int{23}
}
func (m *QueryChainMetricsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryChainMetricsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryChainMetricsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryChainMetricsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryChainMetricsResponse.Merge(m, src)
}
func (m *QueryChainMetricsResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryChainMetricsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryChainMetricsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryChainMetricsResponse proto.InternalMessageInfo

func (m *QueryChainMetricsResponse) GetChainId() string {
	if m != nil {
		return m.ChainId
	}
	return ""
}

func (m *QueryChainMetricsResponse) GetIbcChannel() string {
	if m != nil {
		return m.IbcChannel
	}
	return ""
}

func (m *QueryChainMetricsResponse) GetLastRewardHeight() int64 {
	if m != nil {
		return m.LastRewardHeight
	}
	return 0
}

func (m *QueryChainMetricsResponse) GetLastBurnReportHeight() int64 {
	if m != nil {
		return m.LastBurnReportHeight
	}
	return 0
}

// QueryFeeStatsRequest is request type for the Query/FeeStats RPC method.
type QueryFeeStatsRequest struct {
}

func (m *QueryFeeStatsRequest) Reset()         { *m = QueryFeeStatsRequest{} }
func (m *QueryFeeStatsRequest) String() string { return proto.CompactTextString(m) }
func (*QueryFeeStatsRequest) ProtoMessage()    {}
func (*QueryFeeStatsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ff681edaa2931a07, []int{24}
}
func (m *QueryFeeStatsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryFeeStatsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryFeeStatsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryFeeStatsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryFeeStatsRequest.Merge(m, src)
}
func (m *QueryFeeStatsRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryFeeStatsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryFeeStatsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryFeeStatsRequest proto.InternalMessageInfo

// QueryFeeStatsResponse is response type for the Query/FeeStats RPC method.
type QueryFeeStatsResponse struct {
	// total_fees_burned is cumulative fees burned via 90/10 mechanism
	TotalFeesBurned cosmossdk_io_math.Int `protobuf:"bytes,1,opt,name=total_fees_burned,json=totalFeesBurned,proto3,customtype=cosmossdk.io/math.Int" json:"total_fees_burned"`
	// total_fees_to_treasury is cumulative fees sent to treasury (10%)
	TotalFeesToTreasury cosmossdk_io_math.Int `protobuf:"bytes,2,opt,name=total_fees_to_treasury,json=totalFeesToTreasury,proto3,customtype=cosmossdk.io/math.Int" json:"total_fees_to_treasury"`
	// average_fees_burned_per_block is the mean fees burned per block
	AverageFeesBurnedPerBlock cosmossdk_io_math.LegacyDec `protobuf:"bytes,3,opt,name=average_fees_burned_per_block,json=averageFeesBurnedPerBlock,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"average_fees_burned_per_block"`
	// fee_burn_enabled indicates if the mechanism is active
	FeeBurnEnabled bool `protobuf:"varint,4,opt,name=fee_burn_enabled,json=feeBurnEnabled,proto3" json:"fee_burn_enabled,omitempty"`
	// fee_burn_ratio is current burn percentage (default 0.90)
	FeeBurnRatio cosmossdk_io_math.LegacyDec `protobuf:"bytes,5,opt,name=fee_burn_ratio,json=feeBurnRatio,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"fee_burn_ratio"`
	// treasury_fee_ratio is current treasury percentage (default 0.10)
	TreasuryFeeRatio cosmossdk_io_math.LegacyDec `protobuf:"bytes,6,opt,name=treasury_fee_ratio,json=treasuryFeeRatio,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"treasury_fee_ratio"`
}

func (m *QueryFeeStatsResponse) Reset()         { *m = QueryFeeStatsResponse{} }
func (m *QueryFeeStatsResponse) String() string { return proto.CompactTextString(m) }
func (*QueryFeeStatsResponse) ProtoMessage()    {}
func (*QueryFeeStatsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ff681edaa2931a07, []int{25}
}
func (m *QueryFeeStatsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryFeeStatsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryFeeStatsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryFeeStatsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryFeeStatsResponse.Merge(m, src)
}
func (m *QueryFeeStatsResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryFeeStatsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryFeeStatsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryFeeStatsResponse proto.InternalMessageInfo

func (m *QueryFeeStatsResponse) GetFeeBurnEnabled() bool {
	if m != nil {
		return m.FeeBurnEnabled
	}
	return false
}

// QueryBurnRateRequest is request type for the Query/BurnRate RPC method.
type QueryBurnRateRequest struct {
}

func (m *QueryBurnRateRequest) Reset()         { *m = QueryBurnRateRequest{} }
func (m *QueryBurnRateRequest) String() string { return proto.CompactTextString(m) }
func (*QueryBurnRateRequest) ProtoMessage()    {}
func (*QueryBurnRateRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ff681edaa2931a07, []int{26}
}
func (m *QueryBurnRateRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryBurnRateRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryBurnRateRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryBurnRateRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryBurnRateRequest.Merge(m, src)
}
func (m *QueryBurnRateRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryBurnRateRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryBurnRateRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryBurnRateRequest proto.InternalMessageInfo

// QueryBurnRateResponse is response type for the Query/BurnRate RPC method.
type QueryBurnRateResponse struct {
	// adaptive_burn_enabled indicates if adaptive burn controller is active
	AdaptiveBurnEnabled bool `protobuf:"varint,1,opt,name=adaptive_burn_enabled,json=adaptiveBurnEnabled,proto3" json:"adaptive_burn_enabled,omitempty"`
	// current_burn_ratio is the current effective burn rate (0.70-0.95)
	CurrentBurnRatio cosmossdk_io_math.LegacyDec `protobuf:"bytes,2,opt,name=current_burn_ratio,json=currentBurnRatio,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"current_burn_ratio"`
	// trigger is the reason for current burn ratio
	// Values: "emergency_override", "adaptive_disabled", "treasury_protection",
	//         "congestion_control", "adoption_incentive", "normal"
	Trigger string `protobuf:"bytes,3,opt,name=trigger,proto3" json:"trigger,omitempty"`
	// min_burn_ratio is the DAO-set minimum (default 0.80)
	MinBurnRatio cosmossdk_io_math.LegacyDec `protobuf:"bytes,4,opt,name=min_burn_ratio,json=minBurnRatio,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"min_burn_ratio"`
	// max_burn_ratio is the DAO-set maximum (default 0.95)
	MaxBurnRatio cosmossdk_io_math.LegacyDec `protobuf:"bytes,5,opt,name=max_burn_ratio,json=maxBurnRatio,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"max_burn_ratio"`
	// default_burn_ratio is the DAO-set default (default 0.90)
	DefaultBurnRatio cosmossdk_io_math.LegacyDec `protobuf:"bytes,6,opt,name=default_burn_ratio,json=defaultBurnRatio,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"default_burn_ratio"`
	// block_congestion is current block gas usage percentage
	BlockCongestion cosmossdk_io_math.LegacyDec `protobuf:"bytes,7,opt,name=block_congestion,json=blockCongestion,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"block_congestion"`
	// treasury_pct is treasury balance as % of total supply
	TreasuryPct cosmossdk_io_math.LegacyDec `protobuf:"bytes,8,opt,name=treasury_pct,json=treasuryPct,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"treasury_pct"`
	// avg_tx_per_day is 7-day rolling average of daily transactions
	AvgTxPerDay cosmossdk_io_math.Int `protobuf:"bytes,9,opt,name=avg_tx_per_day,json=avgTxPerDay,proto3,customtype=cosmossdk.io/math.Int" json:"avg_tx_per_day"`
	// emergency_burn_override indicates if emergency override is active
	EmergencyBurnOverride bool `protobuf:"varint,10,opt,name=emergency_burn_override,json=emergencyBurnOverride,proto3" json:"emergency_burn_override,omitempty"`
}

func (m *QueryBurnRateResponse) Reset()         { *m = QueryBurnRateResponse{} }
func (m *QueryBurnRateResponse) String() string { return proto.CompactTextString(m) }
func (*QueryBurnRateResponse) ProtoMessage()    {}
func (*QueryBurnRateResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ff681edaa2931a07, []int{27}
}
func (m *QueryBurnRateResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryBurnRateResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryBurnRateResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryBurnRateResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryBurnRateResponse.Merge(m, src)
}
func (m *QueryBurnRateResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryBurnRateResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryBurnRateResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryBurnRateResponse proto.InternalMessageInfo

func (m *QueryBurnRateResponse) GetAdaptiveBurnEnabled() bool {
	if m != nil {
		return m.AdaptiveBurnEnabled
	}
	return false
}

func (m *QueryBurnRateResponse) GetTrigger() string {
	if m != nil {
		return m.Trigger
	}
	return ""
}

func (m *QueryBurnRateResponse) GetEmergencyBurnOverride() bool {
	if m != nil {
		return m.EmergencyBurnOverride
	}
	return false
}

func init() {
	proto.RegisterType((*QueryParamsRequest)(nil), "pos.tokenomics.v1.QueryParamsRequest")
	proto.RegisterType((*QueryParamsResponse)(nil), "pos.tokenomics.v1.QueryParamsResponse")
	proto.RegisterType((*QuerySupplyRequest)(nil), "pos.tokenomics.v1.QuerySupplyRequest")
	proto.RegisterType((*QuerySupplyResponse)(nil), "pos.tokenomics.v1.QuerySupplyResponse")
	proto.RegisterType((*QueryInflationRequest)(nil), "pos.tokenomics.v1.QueryInflationRequest")
	proto.RegisterType((*QueryInflationResponse)(nil), "pos.tokenomics.v1.QueryInflationResponse")
	proto.RegisterType((*QueryEmissionsRequest)(nil), "pos.tokenomics.v1.QueryEmissionsRequest")
	proto.RegisterType((*EmissionAllocation)(nil), "pos.tokenomics.v1.EmissionAllocation")
	proto.RegisterType((*QueryEmissionsResponse)(nil), "pos.tokenomics.v1.QueryEmissionsResponse")
	proto.RegisterType((*QueryBurnsRequest)(nil), "pos.tokenomics.v1.QueryBurnsRequest")
	proto.RegisterType((*BurnRecord)(nil), "pos.tokenomics.v1.BurnRecord")
	proto.RegisterType((*QueryBurnsResponse)(nil), "pos.tokenomics.v1.QueryBurnsResponse")
	proto.RegisterType((*QueryBurnsBySourceRequest)(nil), "pos.tokenomics.v1.QueryBurnsBySourceRequest")
	proto.RegisterType((*BurnsBySourceStats)(nil), "pos.tokenomics.v1.BurnsBySourceStats")
	proto.RegisterType((*QueryBurnsBySourceResponse)(nil), "pos.tokenomics.v1.QueryBurnsBySourceResponse")
	proto.RegisterType((*QueryBurnsByChainRequest)(nil), "pos.tokenomics.v1.QueryBurnsByChainRequest")
	proto.RegisterType((*QueryBurnsByChainResponse)(nil), "pos.tokenomics.v1.QueryBurnsByChainResponse")
	proto.RegisterType((*QueryTreasuryRequest)(nil), "pos.tokenomics.v1.QueryTreasuryRequest")
	proto.RegisterType((*QueryTreasuryResponse)(nil), "pos.tokenomics.v1.QueryTreasuryResponse")
	proto.RegisterType((*QueryProjectionsRequest)(nil), "pos.tokenomics.v1.QueryProjectionsRequest")
	proto.RegisterType((*SupplyProjection)(nil), "pos.tokenomics.v1.SupplyProjection")
	proto.RegisterType((*QueryProjectionsResponse)(nil), "pos.tokenomics.v1.QueryProjectionsResponse")
	proto.RegisterType((*QueryChainMetricsRequest)(nil), "pos.tokenomics.v1.QueryChainMetricsRequest")
	proto.RegisterType((*QueryChainMetricsResponse)(nil), "pos.tokenomics.v1.QueryChainMetricsResponse")
	proto.RegisterType((*QueryFeeStatsRequest)(nil), "pos.tokenomics.v1.QueryFeeStatsRequest")
	proto.RegisterType((*QueryFeeStatsResponse)(nil), "pos.tokenomics.v1.QueryFeeStatsResponse")
	proto.RegisterType((*QueryBurnRateRequest)(nil), "pos.tokenomics.v1.QueryBurnRateRequest")
	proto.RegisterType((*QueryBurnRateResponse)(nil), "pos.tokenomics.v1.QueryBurnRateResponse")
}

func init() { proto.RegisterFile("pos/tokenomics/v1/query.proto", fileDescriptor_ff681edaa2931a07) }

var fileDescriptor_ff681edaa2931a07 = []byte{
	// 2415 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x5a, 0x5b, 0x6f, 0x1b, 0xc7,
	0xf5, 0xf7, 0xea, 0x4a, 0x1d, 0x8a, 0xb2, 0x34, 0x96, 0x25, 0x8a, 0xb6, 0x64, 0x87, 0x8e, 0x6d,
	0xf9, 0x26, 0x46, 0xfe, 0xc3, 0x7f, 0x34, 0x8f, 0x92, 0x1c, 0x25, 0x42, 0xeb, 0x9a, 0x59, 0x2b,
	0x49, 0x9d, 0xc6, 0xdd, 0x0e, 0x97, 0xa3, 0xd5, 0xd6, 0xe4, 0xee, 0x66, 0x76, 0x48, 0x93, 0x0d,
	0xfc, 0x92, 0xa6, 0x01, 0xfa, 0x52, 0xb4, 0x28, 0xd0, 0x00, 0x45, 0xd0, 0xe7, 0x02, 0x7d, 0x68,
	0x0b, 0xf4, 0x43, 0xe4, 0x31, 0x68, 0x5f, 0x8a, 0x3e, 0x04, 0x85, 0x5d, 0xa0, 0xfd, 0x10, 0x05,
	0x5a, 0xcc, 0x99, 0xd9, 0x0b, 0x6f, 0x92, 0xbd, 0xca, 0x43, 0x5e, 0x12, 0x71, 0x2e, 0xbf, 0x73,
	0xe6, 0xcc, 0x6f, 0xce, 0x6d, 0x0d, 0xab, 0x81, 0x1f, 0x56, 0x84, 0xff, 0x98, 0x79, 0x7e, 0xd3,
	0xb5, 0xc3, 0x4a, 0x7b, 0xb3, 0xf2, 0x61, 0x8b, 0xf1, 0xee, 0x46, 0xc0, 0x7d, 0xe1, 0x93, 0x85,
	0xc0, 0x0f, 0x37, 0x92, 0xe9, 0x8d, 0xf6, 0x66, 0x69, 0x81, 0x36, 0x5d, 0xcf, 0xaf, 0xe0, 0x7f,
	0xd5, 0xaa, 0xd2, 0x75, 0xdb, 0x0f, 0x9b, 0x7e, 0x58, 0xa9, 0xd1, 0x90, 0xa9, 0xed, 0x95, 0xf6,
	0x66, 0x8d, 0x09, 0xba, 0x59, 0x09, 0xa8, 0xe3, 0x7a, 0x54, 0xb8, 0xbe, 0xa7, 0xd7, 0xae, 0xa8,
	0xb5, 0x16, 0xfe, 0xaa, 0xa8, 0x1f, 0x7a, 0x6a, 0xd1, 0xf1, 0x1d, 0x5f, 0x8d, 0xcb, 0xbf, 0xf4,
	0xe8, 0x79, 0xc7, 0xf7, 0x9d, 0x06, 0xab, 0xd0, 0xc0, 0xad, 0x50, 0xcf, 0xf3, 0x05, 0xa2, 0x45,
	0x7b, 0xd6, 0x06, 0xf5, 0x0f, 0x28, 0xa7, 0xcd, 0x68, 0xbe, 0x34, 0x38, 0x2f, 0x3a, 0x6a, 0xae,
	0xbc, 0x08, 0xe4, 0x6d, 0xa9, 0x6c, 0x15, 0x37, 0x98, 0xec, 0xc3, 0x16, 0x0b, 0x45, 0xf9, 0x11,
	0x9c, 0xe9, 0x19, 0x0d, 0x03, 0xdf, 0x0b, 0x19, 0xd9, 0x85, 0x29, 0x05, 0x5c, 0x34, 0x2e, 0x1a,
	0xeb, 0xf9, 0xdb, 0x97, 0x36, 0x06, 0x4c, 0xb3, 0xb1, 0x1f, 0xff, 0x52, 0x9b, 0xb7, 0x67, 0xbe,
	0xf8, 0xea, 0xc2, 0xa9, 0xdf, 0xfd, 0xeb, 0x8f, 0xd7, 0x0d, 0x53, 0xef, 0x8e, 0x85, 0x3e, 0x68,
	0x05, 0x41, 0xa3, 0x1b, 0x09, 0xfd, 0x74, 0x52, 0x4b, 0x8d, 0x86, 0xb5, 0xd4, 0x77, 0x60, 0x5e,
	0xf8, 0x82, 0x36, 0xac, 0x10, 0xc7, 0x2d, 0x9b, 0x06, 0x28, 0x7f, 0x66, 0xfb, 0x86, 0x84, 0xfe,
	0xfb, 0x57, 0x17, 0xce, 0x2a, 0x13, 0x86, 0xf5, 0xc7, 0x1b, 0xae, 0x5f, 0x69, 0x52, 0x71, 0xb8,
	0xb1, 0xe7, 0x89, 0xbf, 0xfc, 0xf9, 0x16, 0x68, 0xdb, 0xee, 0x79, 0xc2, 0x9c, 0x43, 0x10, 0x85,
	0xbd, 0x43, 0x03, 0xf2, 0x08, 0x16, 0xed, 0x16, 0xe7, 0xcc, 0x13, 0x56, 0x1a, 0xbe, 0x38, 0xf6,
	0xf2, 0xd0, 0x44, 0x03, 0xed, 0x27, 0x12, 0xc8, 0x77, 0x61, 0x56, 0xc1, 0x36, 0x5d, 0x4f, 0xb0,
	0x7a, 0x71, 0xfc, 0xe5, 0x61, 0xf3, 0x08, 0x70, 0x0f, 0xf7, 0x27, 0x78, 0xb5, 0x16, 0xf7, 0x58,
	0xbd, 0x38, 0x91, 0x15, 0x6f, 0x1b, 0xf7, 0x93, 0xf7, 0x81, 0x70, 0xd6, 0xa4, 0xae, 0xe7, 0x7a,
	0x0e, 0xea, 0x48, 0x6b, 0x0d, 0x56, 0x9c, 0x7c, 0x79, 0xd4, 0x85, 0x18, 0xe6, 0x9e, 0x46, 0x21,
	0x1f, 0xc0, 0x82, 0xbe, 0xab, 0xc0, 0x16, 0x96, 0x7f, 0x80, 0x57, 0x36, 0x85, 0xd0, 0x9b, 0x1a,
	0xfa, 0xdc, 0x20, 0xf4, 0x77, 0x98, 0x43, 0xed, 0xee, 0x5d, 0x66, 0xa7, 0x04, 0xdc, 0x65, 0xb6,
	0x39, 0xa7, 0xb0, 0xaa, 0xb6, 0xb8, 0x7f, 0x20, 0x2f, 0xce, 0x02, 0xe2, 0x31, 0x61, 0xb9, 0xde,
	0x41, 0x03, 0x9f, 0x81, 0xc5, 0xa9, 0x60, 0xc5, 0xe9, 0xac, 0xf0, 0xf3, 0x1e, 0x13, 0x7b, 0x11,
	0x96, 0x49, 0x05, 0x2b, 0x2f, 0xc3, 0x59, 0xe4, 0x61, 0x32, 0xaa, 0x19, 0xfa, 0xcb, 0x09, 0x58,
	0xea, 0x9f, 0xd1, 0x24, 0x75, 0x60, 0x29, 0x62, 0x53, 0x9f, 0x62, 0x46, 0x56, 0xc5, 0x22, 0x7a,
	0xf6, 0x28, 0x47, 0xde, 0x85, 0x42, 0x22, 0xa0, 0xe9, 0x7a, 0x9a, 0xaf, 0x19, 0xf0, 0x67, 0x63,
	0x9c, 0x7b, 0xae, 0xd7, 0x87, 0x4b, 0x3b, 0x9a, 0xb0, 0x27, 0xc3, 0xa5, 0x1d, 0xf2, 0x3d, 0x58,
	0xa0, 0x9e, 0xd7, 0xa2, 0x0d, 0xe9, 0xed, 0xda, 0x6e, 0x28, 0xfd, 0x56, 0x16, 0xf2, 0xce, 0x2b,
	0x94, 0x6a, 0x0c, 0x42, 0x3e, 0x80, 0xf9, 0x5a, 0xc3, 0xb7, 0x1f, 0xa7, 0x81, 0x27, 0xb3, 0x2a,
	0x7d, 0x1a, 0xa1, 0x52, 0xe8, 0x57, 0x40, 0x0d, 0x85, 0x56, 0xc0, 0xb8, 0xd5, 0x65, 0x94, 0x23,
	0x83, 0x27, 0xcc, 0x82, 0x1a, 0xae, 0x32, 0xfe, 0x90, 0x51, 0x1e, 0x93, 0xe5, 0x8d, 0xa6, 0x1b,
	0xe2, 0xce, 0x88, 0x2c, 0x7f, 0x18, 0x03, 0x12, 0x0d, 0x6e, 0x35, 0x1a, 0xbe, 0x8d, 0x26, 0x21,
	0x25, 0xc8, 0xd9, 0x54, 0x30, 0xc7, 0xe7, 0x5d, 0x45, 0x0d, 0x33, 0xfe, 0x4d, 0xde, 0x06, 0x08,
	0x18, 0xb7, 0x99, 0x27, 0xa8, 0xc3, 0xb2, 0x5f, 0x6c, 0x0a, 0x84, 0x54, 0xa1, 0xa0, 0xcd, 0x4f,
	0x9b, 0x7e, 0xcb, 0x13, 0x59, 0xfc, 0xd0, 0xac, 0x42, 0xd8, 0x42, 0x00, 0x79, 0xa1, 0xca, 0x11,
	0xd5, 0xdd, 0x50, 0x70, 0xb7, 0xd6, 0x12, 0xd9, 0xbc, 0x91, 0x72, 0xea, 0x77, 0x13, 0x90, 0xf2,
	0x27, 0x63, 0xfa, 0x79, 0xa5, 0x6c, 0xa9, 0x9f, 0xd7, 0x3d, 0xc8, 0xd3, 0xd8, 0x86, 0x32, 0xfc,
	0x8c, 0xaf, 0xe7, 0x6f, 0x5f, 0x1e, 0x12, 0x7e, 0x06, 0x2d, 0xbe, 0x3d, 0x21, 0xb5, 0x32, 0xd3,
	0xfb, 0x09, 0x85, 0x25, 0x75, 0x06, 0x6d, 0x1b, 0x16, 0x09, 0xcc, 0xe2, 0xfd, 0x17, 0x11, 0x6a,
	0x0b, 0x91, 0x62, 0xcd, 0xc9, 0xb7, 0xa0, 0xd8, 0xa0, 0xa1, 0x48, 0xac, 0x24, 0xdf, 0xd5, 0x21,
	0x73, 0x9d, 0x43, 0x75, 0x07, 0xe3, 0xe6, 0x92, 0x9c, 0xbf, 0x9b, 0x9a, 0x7e, 0x0b, 0x67, 0xcb,
	0xdf, 0x87, 0x05, 0xb4, 0x82, 0x74, 0xd4, 0x11, 0x9b, 0xc8, 0x2e, 0x40, 0x92, 0x46, 0xe8, 0xf0,
	0x7b, 0x65, 0x43, 0x6b, 0x21, 0x73, 0x8e, 0x0d, 0x95, 0xb2, 0xe8, 0x9c, 0x63, 0xa3, 0x4a, 0x1d,
	0xa6, 0xf7, 0x9a, 0xa9, 0x9d, 0xe5, 0xcf, 0xc6, 0x01, 0x24, 0xb0, 0xc9, 0x6c, 0x9f, 0xd7, 0xc9,
	0x32, 0x4c, 0xcb, 0x78, 0x62, 0xb9, 0x75, 0xc4, 0x9c, 0x30, 0xa7, 0xe4, 0xcf, 0xbd, 0x3a, 0xd9,
	0x81, 0x29, 0x4d, 0x98, 0x0c, 0x16, 0xd1, 0x5b, 0xc9, 0x1d, 0x98, 0x0a, 0xfd, 0x16, 0xb7, 0x19,
	0x9e, 0x78, 0xee, 0xf6, 0xea, 0x90, 0x0b, 0x93, 0xca, 0x3c, 0xc0, 0x45, 0xa6, 0x5e, 0x4c, 0x56,
	0x20, 0x67, 0x1f, 0x52, 0x17, 0xb5, 0x42, 0x62, 0x99, 0xd3, 0xf8, 0x7b, 0xaf, 0x4e, 0x5e, 0x81,
	0x59, 0xf5, 0xe6, 0xb5, 0x25, 0x27, 0xd1, 0x92, 0x79, 0x1c, 0x53, 0xe6, 0x93, 0x47, 0x12, 0x1d,
	0xeb, 0x90, 0x86, 0x87, 0x2a, 0xe4, 0x98, 0x53, 0xa2, 0xf3, 0x16, 0x0d, 0x0f, 0xc9, 0x79, 0x98,
	0x11, 0x6e, 0x93, 0x85, 0x82, 0x36, 0x03, 0x0c, 0x17, 0xe3, 0x66, 0x32, 0x40, 0x2e, 0xc3, 0x1c,
	0x46, 0x56, 0x6e, 0xd1, 0x7a, 0x9d, 0xb3, 0x30, 0x2c, 0xe6, 0x70, 0x77, 0x41, 0x8d, 0x6e, 0xa9,
	0x41, 0x64, 0x3f, 0x67, 0x34, 0x6c, 0xf1, 0xae, 0xc5, 0x59, 0xdd, 0xe5, 0xcc, 0x16, 0xc5, 0x99,
	0x2c, 0xec, 0xd7, 0x28, 0xa6, 0x06, 0x29, 0xff, 0xdb, 0xd0, 0x59, 0x91, 0xbe, 0x77, 0xcd, 0xfc,
	0xd7, 0x61, 0x52, 0x6a, 0x10, 0x71, 0x7e, 0x94, 0x09, 0xd5, 0x7d, 0x6a, 0xae, 0xab, 0x1d, 0xe4,
	0xcd, 0x1e, 0xce, 0x8c, 0x21, 0x67, 0xae, 0x1e, 0xcb, 0x19, 0x25, 0x37, 0x4d, 0x9a, 0x81, 0xdc,
	0x63, 0xfc, 0x64, 0xb9, 0x47, 0xf9, 0x37, 0x06, 0xac, 0x24, 0x47, 0xdd, 0xee, 0xea, 0xfb, 0xd7,
	0x54, 0x4f, 0x58, 0x63, 0xbc, 0x0c, 0x6b, 0x76, 0x87, 0x9c, 0x36, 0xcb, 0x0b, 0xf9, 0xcf, 0x18,
	0x90, 0x1e, 0xbd, 0x1e, 0x08, 0x2a, 0xc2, 0xac, 0x5a, 0xc5, 0xa6, 0xcb, 0xfe, 0x9a, 0x94, 0xe9,
	0xb4, 0xf7, 0x5d, 0x05, 0xc0, 0x07, 0x6b, 0xc7, 0xce, 0x7c, 0xc2, 0x9c, 0x91, 0x23, 0x3b, 0x38,
	0xfd, 0x08, 0x16, 0xa2, 0x34, 0x04, 0x97, 0x61, 0x06, 0x32, 0x91, 0x39, 0x28, 0x6a, 0x2c, 0x24,
	0x98, 0x4c, 0x3e, 0x28, 0x9c, 0xa1, 0x6d, 0xc6, 0xa9, 0xc3, 0x14, 0xbc, 0x3e, 0x54, 0xe6, 0xa8,
	0xbb, 0xa0, 0xd1, 0xa4, 0x00, 0x75, 0xc0, 0xf2, 0x73, 0x03, 0x4a, 0xc3, 0xb8, 0xf1, 0x0d, 0x7a,
	0x0e, 0x5b, 0x30, 0x19, 0x4a, 0x4e, 0xa0, 0xf9, 0x87, 0x87, 0xa1, 0x41, 0x02, 0x45, 0xba, 0xe0,
	0xce, 0xf2, 0x53, 0x28, 0xa6, 0x0f, 0xb9, 0x23, 0xdd, 0x5b, 0xc4, 0xff, 0xb4, 0xfb, 0x33, 0x7a,
	0xdd, 0xdf, 0xd7, 0xc5, 0xf1, 0xff, 0xf6, 0x3d, 0x40, 0x2d, 0xff, 0x1b, 0x64, 0xe3, 0x1f, 0xc0,
	0xd9, 0xb4, 0xcb, 0xb1, 0x7c, 0xcf, 0x42, 0x23, 0x64, 0xf1, 0x3d, 0x24, 0xe5, 0x7b, 0xee, 0x7b,
	0x78, 0xd6, 0xf2, 0x12, 0x2c, 0xa2, 0x01, 0xf6, 0x63, 0x37, 0xac, 0xb2, 0xb6, 0xcf, 0x27, 0x74,
	0x3e, 0x97, 0x4c, 0x68, 0xab, 0xbc, 0x0b, 0xb1, 0xcf, 0xb6, 0x6a, 0xb4, 0x41, 0x3d, 0x9b, 0x65,
	0x29, 0x43, 0x4f, 0x47, 0x20, 0xdb, 0x0a, 0x23, 0xc9, 0x45, 0x62, 0x74, 0x99, 0x3f, 0xfb, 0x4f,
	0x4e, 0x90, 0x8b, 0x44, 0xba, 0xef, 0x29, 0x20, 0x62, 0xc2, 0xdc, 0x01, 0xf7, 0x9b, 0x49, 0x65,
	0x92, 0xc5, 0x8a, 0x05, 0x09, 0x11, 0xd7, 0x22, 0xe4, 0x21, 0x10, 0xc4, 0x54, 0x6e, 0x26, 0x8a,
	0x84, 0x59, 0xf2, 0x40, 0x09, 0xa3, 0xf8, 0xa4, 0x40, 0x88, 0x07, 0xa5, 0xc4, 0xd2, 0x69, 0x78,
	0x59, 0x4e, 0x66, 0x77, 0x36, 0xcb, 0xb1, 0xe5, 0x53, 0xc2, 0xaa, 0xb6, 0x20, 0xd7, 0x52, 0x37,
	0x1b, 0x05, 0x7f, 0x95, 0x3a, 0xc4, 0x97, 0xa5, 0xc3, 0x7f, 0xb9, 0x05, 0xcb, 0xaa, 0x31, 0xc2,
	0xfd, 0x1f, 0x31, 0x5b, 0xa4, 0xf2, 0x7d, 0x72, 0x01, 0xf2, 0xb2, 0x4a, 0x08, 0x2d, 0x7a, 0xc8,
	0xa8, 0x7a, 0xb9, 0x05, 0x13, 0x70, 0x68, 0x4b, 0x8e, 0x90, 0xd7, 0x61, 0x85, 0x86, 0x61, 0xab,
	0xc9, 0x2c, 0xdb, 0xf7, 0x42, 0x41, 0x7b, 0x7c, 0xb4, 0xbc, 0xeb, 0x9c, 0xb9, 0xa4, 0x16, 0xec,
	0xe8, 0xf9, 0xc8, 0xef, 0x96, 0xff, 0x34, 0x0e, 0xf3, 0xaa, 0xaf, 0x90, 0x08, 0x26, 0x04, 0x26,
	0xb0, 0x2c, 0x51, 0x92, 0xf0, 0x6f, 0x49, 0xd2, 0x40, 0xad, 0x60, 0xf5, 0x13, 0x34, 0x34, 0x4e,
	0xc7, 0x20, 0xba, 0x9b, 0xd1, 0x83, 0x9b, 0xbd, 0xa3, 0x91, 0xe0, 0xea, 0xae, 0x46, 0x0f, 0x6e,
	0xf6, 0xce, 0x46, 0x82, 0xab, 0xbb, 0x1b, 0x0f, 0xe1, 0xb4, 0xc7, 0x84, 0xe5, 0x70, 0xff, 0x89,
	0x38, 0x54, 0x16, 0xce, 0xcc, 0x9b, 0x82, 0xc7, 0xc4, 0x9b, 0x08, 0x84, 0x31, 0xf0, 0x0a, 0x9c,
	0x56, 0xf7, 0xdc, 0xf2, 0x84, 0xdb, 0x88, 0x5b, 0x1b, 0x05, 0xb3, 0x80, 0xc3, 0xef, 0xc8, 0xd1,
	0x1d, 0x1a, 0x94, 0x7f, 0x66, 0x68, 0x1f, 0xdf, 0xc3, 0x15, 0xed, 0x4c, 0xbe, 0x0d, 0xf9, 0x20,
	0x19, 0xd6, 0x8e, 0x76, 0x58, 0x3b, 0xad, 0xff, 0xd6, 0xa3, 0x6a, 0x26, 0xb5, 0x9b, 0x5c, 0x84,
	0x3c, 0xf2, 0x26, 0x10, 0x49, 0x09, 0x63, 0xa6, 0x87, 0xca, 0x77, 0xb4, 0x2a, 0xe8, 0xfb, 0xee,
	0x31, 0xc1, 0x5d, 0x3b, 0x3c, 0x3e, 0xdc, 0x48, 0x67, 0xb8, 0x32, 0x64, 0x9f, 0x3e, 0xc3, 0x11,
	0x71, 0xaa, 0x3f, 0x61, 0x1c, 0x3b, 0x61, 0xb3, 0x2a, 0xf6, 0x91, 0x9c, 0x3d, 0xa1, 0xbc, 0x1e,
	0x5a, 0x9c, 0xd9, 0xcc, 0x6d, 0x67, 0x23, 0xa1, 0xf2, 0x91, 0xa6, 0x42, 0x32, 0x35, 0x10, 0xd9,
	0x85, 0x9c, 0x64, 0x8c, 0x74, 0x98, 0x59, 0x18, 0x38, 0xed, 0x31, 0xb1, 0xdb, 0xf0, 0x9f, 0x48,
	0x37, 0xe0, 0xd6, 0x6c, 0x19, 0xac, 0x3c, 0x8f, 0x35, 0x14, 0xeb, 0x4c, 0x70, 0x6b, 0xf6, 0x8e,
	0x1a, 0x21, 0x36, 0x2c, 0x3a, 0x34, 0x94, 0x3e, 0xa0, 0xcd, 0x78, 0xa8, 0xdb, 0x44, 0xae, 0x9f,
	0xbd, 0x3f, 0x46, 0x1c, 0x1a, 0xee, 0xc4, 0x68, 0xa6, 0x04, 0x23, 0x37, 0x81, 0x60, 0xf5, 0xa9,
	0xec, 0x15, 0x55, 0x4b, 0xaa, 0xe8, 0x99, 0x97, 0x33, 0xea, 0xf8, 0xba, 0x64, 0xba, 0x03, 0xcb,
	0xb8, 0x5a, 0x3b, 0xdb, 0xc0, 0xe7, 0x22, 0xda, 0x92, 0xc3, 0x2d, 0x8b, 0x72, 0x5a, 0xb9, 0x4d,
	0x39, 0xa9, 0x0b, 0xd5, 0x28, 0x86, 0xee, 0x32, 0x95, 0xe2, 0x44, 0x31, 0xf4, 0xf7, 0x51, 0x0c,
	0x4d, 0x26, 0x34, 0x65, 0xde, 0x8b, 0x7a, 0x07, 0x07, 0x8c, 0x85, 0x11, 0x39, 0x32, 0x05, 0x51,
	0x89, 0xb2, 0xcb, 0x58, 0xa8, 0x09, 0xf2, 0xc3, 0x88, 0x20, 0x08, 0x2c, 0xfc, 0x38, 0x98, 0x66,
	0xa1, 0xde, 0x99, 0x18, 0x7d, 0xdf, 0x8f, 0x42, 0x29, 0x09, 0x61, 0x35, 0x4a, 0x7d, 0x53, 0xca,
	0x63, 0x73, 0x08, 0xab, 0xcf, 0xec, 0xfd, 0xb2, 0x15, 0x8d, 0x9b, 0x1c, 0xa7, 0xca, 0xf8, 0xb6,
	0xc4, 0x24, 0xeb, 0x30, 0x7f, 0xc0, 0x74, 0xae, 0xcd, 0x3c, 0x5a, 0x6b, 0x68, 0xf7, 0x98, 0x33,
	0xe7, 0x0e, 0x18, 0x66, 0xcd, 0x6f, 0xa8, 0x51, 0xf2, 0x1e, 0xcc, 0xc5, 0x2b, 0x15, 0x9f, 0x32,
	0xfb, 0xbb, 0x59, 0x0d, 0xad, 0x98, 0x64, 0x01, 0x89, 0x83, 0xa3, 0x94, 0x70, 0x42, 0xb2, 0xc6,
	0x91, 0x76, 0x97, 0x31, 0x14, 0x10, 0xb3, 0x28, 0x0a, 0x76, 0x11, 0x8b, 0x3e, 0x9b, 0xd2, 0x2c,
	0x4a, 0x26, 0x34, 0x8b, 0x6e, 0xc3, 0x59, 0x5a, 0xa7, 0x81, 0x70, 0xdb, 0x7d, 0xa6, 0x31, 0xd0,
	0x34, 0x67, 0xa2, 0xc9, 0xb4, 0x7d, 0x2c, 0x20, 0xfd, 0x85, 0x91, 0xeb, 0x67, 0x6f, 0xb1, 0xcd,
	0xf7, 0x56, 0x46, 0xae, 0x4f, 0x8a, 0x30, 0x2d, 0xb8, 0xeb, 0x38, 0x8c, 0x2b, 0x26, 0x98, 0xd1,
	0x4f, 0x79, 0x35, 0x4d, 0xd7, 0x4b, 0x8b, 0xcd, 0x5c, 0x90, 0xcd, 0x36, 0x5d, 0x2f, 0x11, 0x29,
	0x81, 0x69, 0xe7, 0xeb, 0xb9, 0xf3, 0x26, 0xed, 0xf4, 0xdc, 0x79, 0x9d, 0x1d, 0xd0, 0x56, 0xa3,
	0xc7, 0x58, 0xd9, 0xef, 0x5c, 0x83, 0x25, 0x02, 0xe2, 0xd6, 0xad, 0xed, 0x7b, 0x0e, 0x0b, 0x31,
	0x25, 0x9d, 0x3e, 0x59, 0xeb, 0x76, 0x27, 0x46, 0x22, 0xfb, 0x30, 0x1b, 0x53, 0x56, 0x66, 0x8c,
	0xb9, 0xac, 0xc8, 0xf9, 0x08, 0x46, 0x66, 0x89, 0x55, 0x98, 0xa3, 0x6d, 0xc7, 0x12, 0x1d, 0x7c,
	0xf3, 0x75, 0xda, 0xcd, 0xd2, 0xf6, 0xc9, 0xd3, 0xb6, 0xb3, 0xdf, 0xa9, 0x32, 0x7e, 0x97, 0x76,
	0xc9, 0xff, 0xc3, 0x32, 0x6b, 0x32, 0xee, 0x30, 0xcf, 0xd6, 0x89, 0xae, 0xdf, 0x66, 0x9c, 0xbb,
	0x75, 0x56, 0x04, 0x64, 0xf2, 0xd9, 0x78, 0x5a, 0x9a, 0xee, 0xbe, 0x9e, 0xbc, 0xfd, 0xd3, 0x02,
	0x4c, 0xe2, 0xcb, 0x20, 0x3f, 0x86, 0x29, 0xf5, 0x95, 0x8d, 0x0c, 0x2b, 0x42, 0x07, 0x3f, 0xec,
	0x95, 0xae, 0x1c, 0xb7, 0x4c, 0x3d, 0xb1, 0xf2, 0x2b, 0x1f, 0xff, 0xf5, 0x9f, 0xbf, 0x1a, 0x3b,
	0x47, 0x56, 0x2a, 0xa3, 0xbe, 0x2d, 0x4a, 0xd9, 0x3a, 0x39, 0x1c, 0x29, 0xbb, 0xe7, 0xfb, 0xde,
	0x68, 0xd9, 0xbd, 0xdf, 0xfb, 0x8e, 0x94, 0xad, 0x52, 0x5a, 0xf2, 0xa9, 0x01, 0x33, 0x49, 0x29,
	0xb2, 0x3e, 0x0a, 0xb8, 0xff, 0x03, 0x4e, 0xe9, 0xda, 0x0b, 0xac, 0xd4, 0x5a, 0xbc, 0x8a, 0x5a,
	0xac, 0x91, 0xf3, 0x43, 0xb4, 0x88, 0xeb, 0x28, 0x54, 0x24, 0xe9, 0xf9, 0x8e, 0x54, 0xa4, 0xff,
	0xe3, 0xc0, 0x68, 0x45, 0x06, 0x5a, 0xdf, 0x47, 0x2a, 0x12, 0xf7, 0xad, 0x49, 0x1b, 0x26, 0xb1,
	0x96, 0x27, 0xaf, 0x8e, 0x42, 0x4e, 0xb7, 0x93, 0x4b, 0x97, 0x8f, 0x59, 0xa5, 0x65, 0x5f, 0x44,
	0xd9, 0x25, 0x52, 0x1c, 0x22, 0x5b, 0x15, 0xfc, 0xbf, 0x35, 0xa0, 0xd0, 0xd3, 0xec, 0x20, 0x37,
	0x8f, 0x84, 0xee, 0x6b, 0xf6, 0x95, 0x6e, 0xbd, 0xe0, 0x6a, 0xad, 0xd0, 0x6b, 0xa8, 0xd0, 0x75,
	0xb2, 0x3e, 0x4a, 0xa1, 0x8a, 0xea, 0xbb, 0x55, 0x3e, 0x52, 0xff, 0x7f, 0x4a, 0x3e, 0x37, 0x60,
	0x36, 0xdd, 0xe5, 0x20, 0x37, 0x8e, 0x91, 0x98, 0xee, 0xc5, 0x94, 0x6e, 0xbe, 0xd8, 0x62, 0xad,
	0xdd, 0x26, 0x6a, 0x77, 0x83, 0x5c, 0x1b, 0xa9, 0x1d, 0x26, 0xc8, 0x95, 0x8f, 0xa2, 0xbc, 0xf9,
	0x29, 0xf9, 0xd8, 0x80, 0x5c, 0x9c, 0x63, 0x5c, 0x1d, 0x25, 0xad, 0xaf, 0x4b, 0x51, 0x5a, 0x3f,
	0x7e, 0xa1, 0x56, 0xe9, 0x12, 0xaa, 0xb4, 0x4a, 0xce, 0x0d, 0x51, 0x29, 0xf2, 0x6e, 0xe4, 0xe7,
	0x06, 0xe4, 0x53, 0x55, 0x0a, 0xb9, 0x3e, 0xd2, 0x4b, 0x0c, 0x94, 0xbd, 0xa5, 0x1b, 0x2f, 0xb4,
	0x56, 0x6b, 0x73, 0x05, 0xb5, 0xb9, 0x48, 0xd6, 0x86, 0xb9, 0x95, 0x94, 0x02, 0xbf, 0x36, 0x60,
	0x36, 0x5d, 0x73, 0x8c, 0xbe, 0xb4, 0x21, 0x15, 0xcd, 0xe8, 0x4b, 0x1b, 0x56, 0xc6, 0x94, 0x6f,
	0xa0, 0x4e, 0x97, 0xc9, 0xa5, 0x21, 0x3a, 0x0d, 0x5c, 0xd7, 0x27, 0x06, 0xe4, 0xa2, 0xac, 0x76,
	0xf4, 0x75, 0xf5, 0x25, 0xc4, 0xa3, 0xaf, 0xab, 0x3f, 0x41, 0x2e, 0x5f, 0x46, 0x65, 0x2e, 0x90,
	0xd5, 0x21, 0xca, 0xc8, 0xb4, 0xb3, 0x82, 0xed, 0x43, 0xf2, 0x13, 0x03, 0x72, 0x71, 0x53, 0xf6,
	0xea, 0x51, 0x1c, 0x4d, 0x65, 0x54, 0xa3, 0xd5, 0xe8, 0xcf, 0xb0, 0x8e, 0xf4, 0x39, 0x92, 0xc8,
	0xb7, 0x64, 0x45, 0xbd, 0xfd, 0xda, 0x17, 0xcf, 0xd6, 0x8c, 0x2f, 0x9f, 0xad, 0x19, 0xff, 0x78,
	0xb6, 0x66, 0xfc, 0xe2, 0xf9, 0xda, 0xa9, 0x2f, 0x9f, 0xaf, 0x9d, 0xfa, 0xdb, 0xf3, 0xb5, 0x53,
	0xef, 0x2f, 0xc9, 0x6d, 0x9d, 0xf4, 0x46, 0xd1, 0x0d, 0x58, 0x58, 0x9b, 0xc2, 0x7f, 0x74, 0xf2,
	0x7f, 0xff, 0x0b, 0x00, 0x00, 0xff, 0xff, 0x9a, 0x3e, 0x88, 0xdf, 0x72, 0x23, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// QueryClient is the client API for Query service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type QueryClient interface {
	// Parameters queries the tokenomics parameters.
	Params(ctx context.Context, in *QueryParamsRequest, opts ...grpc.CallOption) (*QueryParamsResponse, error)
	// Supply queries the current token supply metrics
	Supply(ctx context.Context, in *QuerySupplyRequest, opts ...grpc.CallOption) (*QuerySupplyResponse, error)
	// Inflation queries the current inflation metrics
	Inflation(ctx context.Context, in *QueryInflationRequest, opts ...grpc.CallOption) (*QueryInflationResponse, error)
	// Emissions queries the current emission distribution
	Emissions(ctx context.Context, in *QueryEmissionsRequest, opts ...grpc.CallOption) (*QueryEmissionsResponse, error)
	// Burns queries burn history and statistics
	Burns(ctx context.Context, in *QueryBurnsRequest, opts ...grpc.CallOption) (*QueryBurnsResponse, error)
	// BurnsBySource queries burns filtered by source
	BurnsBySource(ctx context.Context, in *QueryBurnsBySourceRequest, opts ...grpc.CallOption) (*QueryBurnsBySourceResponse, error)
	// BurnsByChain queries burns filtered by chain
	BurnsByChain(ctx context.Context, in *QueryBurnsByChainRequest, opts ...grpc.CallOption) (*QueryBurnsByChainResponse, error)
	// Treasury queries the DAO treasury status
	Treasury(ctx context.Context, in *QueryTreasuryRequest, opts ...grpc.CallOption) (*QueryTreasuryResponse, error)
	// Projections queries future supply projections
	Projections(ctx context.Context, in *QueryProjectionsRequest, opts ...grpc.CallOption) (*QueryProjectionsResponse, error)
	// ChainMetrics queries per-chain tokenomics metrics
	ChainMetrics(ctx context.Context, in *QueryChainMetricsRequest, opts ...grpc.CallOption) (*QueryChainMetricsResponse, error)
	// FeeStats queries fee burn statistics (90/10 mechanism)
	FeeStats(ctx context.Context, in *QueryFeeStatsRequest, opts ...grpc.CallOption) (*QueryFeeStatsResponse, error)
	// BurnRate queries the current adaptive burn rate and trigger
	BurnRate(ctx context.Context, in *QueryBurnRateRequest, opts ...grpc.CallOption) (*QueryBurnRateResponse, error)
}

type queryClient struct {
	cc grpc1.ClientConn
}

func NewQueryClient(cc grpc1.ClientConn) QueryClient {
	return &queryClient{cc}
}

func (c *queryClient) Params(ctx context.Context, in *QueryParamsRequest, opts ...grpc.CallOption) (*QueryParamsResponse, error) {
	out := new(QueryParamsResponse)
	err := c.cc.Invoke(ctx, "/pos.tokenomics.v1.Query/Params", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) Supply(ctx context.Context, in *QuerySupplyRequest, opts ...grpc.CallOption) (*QuerySupplyResponse, error) {
	out := new(QuerySupplyResponse)
	err := c.cc.Invoke(ctx, "/pos.tokenomics.v1.Query/Supply", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) Inflation(ctx context.Context, in *QueryInflationRequest, opts ...grpc.CallOption) (*QueryInflationResponse, error) {
	out := new(QueryInflationResponse)
	err := c.cc.Invoke(ctx, "/pos.tokenomics.v1.Query/Inflation", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) Emissions(ctx context.Context, in *QueryEmissionsRequest, opts ...grpc.CallOption) (*QueryEmissionsResponse, error) {
	out := new(QueryEmissionsResponse)
	err := c.cc.Invoke(ctx, "/pos.tokenomics.v1.Query/Emissions", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) Burns(ctx context.Context, in *QueryBurnsRequest, opts ...grpc.CallOption) (*QueryBurnsResponse, error) {
	out := new(QueryBurnsResponse)
	err := c.cc.Invoke(ctx, "/pos.tokenomics.v1.Query/Burns", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) BurnsBySource(ctx context.Context, in *QueryBurnsBySourceRequest, opts ...grpc.CallOption) (*QueryBurnsBySourceResponse, error) {
	out := new(QueryBurnsBySourceResponse)
	err := c.cc.Invoke(ctx, "/pos.tokenomics.v1.Query/BurnsBySource", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) BurnsByChain(ctx context.Context, in *QueryBurnsByChainRequest, opts ...grpc.CallOption) (*QueryBurnsByChainResponse, error) {
	out := new(QueryBurnsByChainResponse)
	err := c.cc.Invoke(ctx, "/pos.tokenomics.v1.Query/BurnsByChain", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) Treasury(ctx context.Context, in *QueryTreasuryRequest, opts ...grpc.CallOption) (*QueryTreasuryResponse, error) {
	out := new(QueryTreasuryResponse)
	err := c.cc.Invoke(ctx, "/pos.tokenomics.v1.Query/Treasury", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) Projections(ctx context.Context, in *QueryProjectionsRequest, opts ...grpc.CallOption) (*QueryProjectionsResponse, error) {
	out := new(QueryProjectionsResponse)
	err := c.cc.Invoke(ctx, "/pos.tokenomics.v1.Query/Projections", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) ChainMetrics(ctx context.Context, in *QueryChainMetricsRequest, opts ...grpc.CallOption) (*QueryChainMetricsResponse, error) {
	out := new(QueryChainMetricsResponse)
	err := c.cc.Invoke(ctx, "/pos.tokenomics.v1.Query/ChainMetrics", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) FeeStats(ctx context.Context, in *QueryFeeStatsRequest, opts ...grpc.CallOption) (*QueryFeeStatsResponse, error) {
	out := new(QueryFeeStatsResponse)
	err := c.cc.Invoke(ctx, "/pos.tokenomics.v1.Query/FeeStats", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) BurnRate(ctx context.Context, in *QueryBurnRateRequest, opts ...grpc.CallOption) (*QueryBurnRateResponse, error) {
	out := new(QueryBurnRateResponse)
	err := c.cc.Invoke(ctx, "/pos.tokenomics.v1.Query/BurnRate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// QueryServer is the server API for Query service.
type QueryServer interface {
	// Parameters queries the tokenomics parameters.
	Params(context.Context, *QueryParamsRequest) (*QueryParamsResponse, error)
	// Supply queries the current token supply metrics
	Supply(context.Context, *QuerySupplyRequest) (*QuerySupplyResponse, error)
	// Inflation queries the current inflation metrics
	Inflation(context.Context, *QueryInflationRequest) (*QueryInflationResponse, error)
	// Emissions queries the current emission distribution
	Emissions(context.Context, *QueryEmissionsRequest) (*QueryEmissionsResponse, error)
	// Burns queries burn history and statistics
	Burns(context.Context, *QueryBurnsRequest) (*QueryBurnsResponse, error)
	// BurnsBySource queries burns filtered by source
	BurnsBySource(context.Context, *QueryBurnsBySourceRequest) (*QueryBurnsBySourceResponse, error)
	// BurnsByChain queries burns filtered by chain
	BurnsByChain(context.Context, *QueryBurnsByChainRequest) (*QueryBurnsByChainResponse, error)
	// Treasury queries the DAO treasury status
	Treasury(context.Context, *QueryTreasuryRequest) (*QueryTreasuryResponse, error)
	// Projections queries future supply projections
	Projections(context.Context, *QueryProjectionsRequest) (*QueryProjectionsResponse, error)
	// ChainMetrics queries per-chain tokenomics metrics
	ChainMetrics(context.Context, *QueryChainMetricsRequest) (*QueryChainMetricsResponse, error)
	// FeeStats queries fee burn statistics (90/10 mechanism)
	FeeStats(context.Context, *QueryFeeStatsRequest) (*QueryFeeStatsResponse, error)
	// BurnRate queries the current adaptive burn rate and trigger
	BurnRate(context.Context, *QueryBurnRateRequest) (*QueryBurnRateResponse, error)
}

// UnimplementedQueryServer can be embedded to have forward compatible implementations.
type UnimplementedQueryServer struct {
}

func (*UnimplementedQueryServer) Params(ctx context.Context, req *QueryParamsRequest) (*QueryParamsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Params not implemented")
}
func (*UnimplementedQueryServer) Supply(ctx context.Context, req *QuerySupplyRequest) (*QuerySupplyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Supply not implemented")
}
func (*UnimplementedQueryServer) Inflation(ctx context.Context, req *QueryInflationRequest) (*QueryInflationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Inflation not implemented")
}
func (*UnimplementedQueryServer) Emissions(ctx context.Context, req *QueryEmissionsRequest) (*QueryEmissionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Emissions not implemented")
}
func (*UnimplementedQueryServer) Burns(ctx context.Context, req *QueryBurnsRequest) (*QueryBurnsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Burns not implemented")
}
func (*UnimplementedQueryServer) BurnsBySource(ctx context.Context, req *QueryBurnsBySourceRequest) (*QueryBurnsBySourceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BurnsBySource not implemented")
}
func (*UnimplementedQueryServer) BurnsByChain(ctx context.Context, req *QueryBurnsByChainRequest) (*QueryBurnsByChainResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BurnsByChain not implemented")
}
func (*UnimplementedQueryServer) Treasury(ctx context.Context, req *QueryTreasuryRequest) (*QueryTreasuryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Treasury not implemented")
}
func (*UnimplementedQueryServer) Projections(ctx context.Context, req *QueryProjectionsRequest) (*QueryProjectionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Projections not implemented")
}
func (*UnimplementedQueryServer) ChainMetrics(ctx context.Context, req *QueryChainMetricsRequest) (*QueryChainMetricsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ChainMetrics not implemented")
}
func (*UnimplementedQueryServer) FeeStats(ctx context.Context, req *QueryFeeStatsRequest) (*QueryFeeStatsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FeeStats not implemented")
}
func (*UnimplementedQueryServer) BurnRate(ctx context.Context, req *QueryBurnRateRequest) (*QueryBurnRateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BurnRate not implemented")
}

func RegisterQueryServer(s grpc1.Server, srv QueryServer) {
	s.RegisterService(&_Query_serviceDesc, srv)
}

func _Query_Params_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryParamsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).Params(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pos.tokenomics.v1.Query/Params",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).Params(ctx, req.(*QueryParamsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_Supply_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QuerySupplyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).Supply(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pos.tokenomics.v1.Query/Supply",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).Supply(ctx, req.(*QuerySupplyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_Inflation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryInflationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).Inflation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pos.tokenomics.v1.Query/Inflation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).Inflation(ctx, req.(*QueryInflationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_Emissions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryEmissionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).Emissions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pos.tokenomics.v1.Query/Emissions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).Emissions(ctx, req.(*QueryEmissionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_Burns_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryBurnsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).Burns(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pos.tokenomics.v1.Query/Burns",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).Burns(ctx, req.(*QueryBurnsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_BurnsBySource_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryBurnsBySourceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).BurnsBySource(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pos.tokenomics.v1.Query/BurnsBySource",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).BurnsBySource(ctx, req.(*QueryBurnsBySourceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_BurnsByChain_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryBurnsByChainRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).BurnsByChain(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pos.tokenomics.v1.Query/BurnsByChain",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).BurnsByChain(ctx, req.(*QueryBurnsByChainRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_Treasury_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryTreasuryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).Treasury(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pos.tokenomics.v1.Query/Treasury",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).Treasury(ctx, req.(*QueryTreasuryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_Projections_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryProjectionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).Projections(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pos.tokenomics.v1.Query/Projections",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).Projections(ctx, req.(*QueryProjectionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_ChainMetrics_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryChainMetricsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).ChainMetrics(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pos.tokenomics.v1.Query/ChainMetrics",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).ChainMetrics(ctx, req.(*QueryChainMetricsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_FeeStats_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryFeeStatsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).FeeStats(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pos.tokenomics.v1.Query/FeeStats",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).FeeStats(ctx, req.(*QueryFeeStatsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_BurnRate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryBurnRateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).BurnRate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pos.tokenomics.v1.Query/BurnRate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).BurnRate(ctx, req.(*QueryBurnRateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var Query_serviceDesc = _Query_serviceDesc
var _Query_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pos.tokenomics.v1.Query",
	HandlerType: (*QueryServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Params",
			Handler:    _Query_Params_Handler,
		},
		{
			MethodName: "Supply",
			Handler:    _Query_Supply_Handler,
		},
		{
			MethodName: "Inflation",
			Handler:    _Query_Inflation_Handler,
		},
		{
			MethodName: "Emissions",
			Handler:    _Query_Emissions_Handler,
		},
		{
			MethodName: "Burns",
			Handler:    _Query_Burns_Handler,
		},
		{
			MethodName: "BurnsBySource",
			Handler:    _Query_BurnsBySource_Handler,
		},
		{
			MethodName: "BurnsByChain",
			Handler:    _Query_BurnsByChain_Handler,
		},
		{
			MethodName: "Treasury",
			Handler:    _Query_Treasury_Handler,
		},
		{
			MethodName: "Projections",
			Handler:    _Query_Projections_Handler,
		},
		{
			MethodName: "ChainMetrics",
			Handler:    _Query_ChainMetrics_Handler,
		},
		{
			MethodName: "FeeStats",
			Handler:    _Query_FeeStats_Handler,
		},
		{
			MethodName: "BurnRate",
			Handler:    _Query_BurnRate_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "pos/tokenomics/v1/query.proto",
}

func (m *QueryParamsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryParamsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryParamsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *QueryParamsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryParamsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryParamsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Params.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintQuery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *QuerySupplyRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QuerySupplyRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QuerySupplyRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *QuerySupplyResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QuerySupplyResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QuerySupplyResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.NetInflationRate.Size()
		i -= size
		if _, err := m.NetInflationRate.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintQuery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	{
		size := m.SupplyPctOfCap.Size()
		i -= size
		if _, err := m.SupplyPctOfCap.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintQuery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	{
		size := m.RemainingMintable.Size()
		i -= size
		if _, err := m.RemainingMintable.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintQuery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size := m.TotalBurned.Size()
		i -= size
		if _, err := m.TotalBurned.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintQuery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size := m.TotalMinted.Size()
		i -= size
		if _, err := m.TotalMinted.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintQuery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.CurrentTotalSupply.Size()
		i -= size
		if _, err := m.CurrentTotalSupply.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintQuery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size := m.TotalSupplyCap.Size()
		i -= size
		if _, err := m.TotalSupplyCap.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintQuery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *QueryInflationRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryInflationRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryInflationRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *QueryInflationResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryInflationResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryInflationResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.BlocksPerYear != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.BlocksPerYear))
		i--
		dAtA[i] = 0x30
	}
	{
		size := m.BlockProvisions.Size()
		i -= size
		if _, err := m.BlockProvisions.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintQuery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size := m.AnnualProvisions.Size()
		i -= size
		if _, err := m.AnnualProvisions.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintQuery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size := m.InflationMax.Size()
		i -= size
		if _, err := m.InflationMax.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintQuery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.InflationMin.Size()
		i -= size
		if _, err := m.InflationMin.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintQuery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size := m.CurrentInflationRate.Size()
		i -= size
		if _, err := m.CurrentInflationRate.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintQuery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *QueryEmissionsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryEmissionsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryEmissionsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *EmissionAllocation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EmissionAllocation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EmissionAllocation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.TotalDistributed.Size()
		i -= size
		if _, err := m.TotalDistributed.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintQuery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size := m.AnnualAmount.Size()
		i -= size
		if _, err := m.AnnualAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintQuery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.Percentage.Size()
		i -= size
		if _, err := m.Percentage.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintQuery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Category) > 0 {
		i -= len(m.Category)
		copy(dAtA[i:], m.Category)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Category)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryEmissionsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryEmissionsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryEmissionsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LastDistributionHeight != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.LastDistributionHeight))
		i--
		dAtA[i] = 0x18
	}
	{
		size := m.TotalAnnualEmissions.Size()
		i -= size
		if _, err := m.TotalAnnualEmissions.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintQuery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Allocations) > 0 {
		for iNdEx := len(m.Allocations) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Allocations[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *QueryBurnsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryBurnsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryBurnsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Pagination != nil {
		{
			size, err := m.Pagination.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BurnRecord) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BurnRecord) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BurnRecord) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.TreasuryRedirect.Size()
		i -= size
		if _, err := m.TreasuryRedirect.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintQuery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x4a
	if len(m.BurnerAddress) > 0 {
		i -= len(m.BurnerAddress)
		copy(dAtA[i:], m.BurnerAddress)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.BurnerAddress)))
		i--
		dAtA[i] = 0x42
	}
	if m.Timestamp != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x38
	}
	if len(m.TxHash) > 0 {
		i -= len(m.TxHash)
		copy(dAtA[i:], m.TxHash)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.TxHash)))
		i--
		dAtA[i] = 0x32
	}
	if m.BlockHeight != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.BlockHeight))
		i--
		dAtA[i] = 0x28
	}
	if len(m.ChainId) > 0 {
		i -= len(m.ChainId)
		copy(dAtA[i:], m.ChainId)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.ChainId)))
		i--
		dAtA[i] = 0x22
	}
	if m.Source != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.Source))
		i--
		dAtA[i] = 0x18
	}
	{
		size := m.Amount.Size()
		i -= size
		if _, err := m.Amount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintQuery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.BurnId != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.BurnId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *QueryBurnsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryBurnsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryBurnsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.TotalBurned.Size()
		i -= size
		if _, err := m.TotalBurned.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintQuery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.Pagination != nil {
		{
			size, err := m.Pagination.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Burns) > 0 {
		for iNdEx := len(m.Burns) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Burns[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *QueryBurnsBySourceRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryBurnsBySourceRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryBurnsBySourceRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Pagination != nil {
		{
			size, err := m.Pagination.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Source != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.Source))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BurnsBySourceStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BurnsBySourceStats) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BurnsBySourceStats) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.AverageBurnAmount.Size()
		i -= size
		if _, err := m.AverageBurnAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintQuery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size := m.CurrentBurnRate.Size()
		i -= size
		if _, err := m.CurrentBurnRate.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintQuery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if m.BurnCount != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.BurnCount))
		i--
		dAtA[i] = 0x18
	}
	{
		size := m.TotalAmount.Size()
		i -= size
		if _, err := m.TotalAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintQuery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.Source != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.Source))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *QueryBurnsBySourceResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryBurnsBySourceResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryBurnsBySourceResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Stats.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintQuery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.Pagination != nil {
		{
			size, err := m.Pagination.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Burns) > 0 {
		for iNdEx := len(m.Burns) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Burns[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *QueryBurnsByChainRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryBurnsByChainRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryBurnsByChainRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Pagination != nil {
		{
			size, err := m.Pagination.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.ChainId) > 0 {
		i -= len(m.ChainId)
		copy(dAtA[i:], m.ChainId)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.ChainId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryBurnsByChainResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryBurnsByChainResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryBurnsByChainResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.TotalBurnedOnChain.Size()
		i -= size
		if _, err := m.TotalBurnedOnChain.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintQuery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.Pagination != nil {
		{
			size, err := m.Pagination.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Burns) > 0 {
		for iNdEx := len(m.Burns) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Burns[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *QueryTreasuryRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryTreasuryRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryTreasuryRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *QueryTreasuryResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryTreasuryResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryTreasuryResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TreasuryAddress) > 0 {
		i -= len(m.TreasuryAddress)
		copy(dAtA[i:], m.TreasuryAddress)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.TreasuryAddress)))
		i--
		dAtA[i] = 0x32
	}
	{
		size := m.TreasuryBurnRedirectPct.Size()
		i -= size
		if _, err := m.TreasuryBurnRedirectPct.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintQuery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size := m.FromBurnRedirect.Size()
		i -= size
		if _, err := m.FromBurnRedirect.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintQuery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size := m.FromInflation.Size()
		i -= size
		if _, err := m.FromInflation.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintQuery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.TotalTreasuryInflows.Size()
		i -= size
		if _, err := m.TotalTreasuryInflows.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintQuery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size := m.TreasuryBalance.Size()
		i -= size
		if _, err := m.TreasuryBalance.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintQuery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *QueryProjectionsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryProjectionsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryProjectionsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AssumeConstantBurnRate {
		i--
		if m.AssumeConstantBurnRate {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.YearsAhead != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.YearsAhead))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SupplyProjection) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SupplyProjection) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SupplyProjection) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.YearsUntilCap != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.YearsUntilCap))
		i--
		dAtA[i] = 0x30
	}
	{
		size := m.NetGrowthRate.Size()
		i -= size
		if _, err := m.NetGrowthRate.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintQuery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size := m.ProjectedBurned.Size()
		i -= size
		if _, err := m.ProjectedBurned.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintQuery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size := m.ProjectedMinted.Size()
		i -= size
		if _, err := m.ProjectedMinted.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintQuery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.ProjectedSupply.Size()
		i -= size
		if _, err := m.ProjectedSupply.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintQuery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.Year != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.Year))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *QueryProjectionsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryProjectionsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryProjectionsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Assumptions) > 0 {
		i -= len(m.Assumptions)
		copy(dAtA[i:], m.Assumptions)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Assumptions)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Projections) > 0 {
		for iNdEx := len(m.Projections) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Projections[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *QueryChainMetricsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryChainMetricsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryChainMetricsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ChainId) > 0 {
		i -= len(m.ChainId)
		copy(dAtA[i:], m.ChainId)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.ChainId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryChainMetricsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryChainMetricsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryChainMetricsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LastBurnReportHeight != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.LastBurnReportHeight))
		i--
		dAtA[i] = 0x40
	}
	if m.LastRewardHeight != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.LastRewardHeight))
		i--
		dAtA[i] = 0x38
	}
	{
		size := m.GasConversionRatio.Size()
		i -= size
		if _, err := m.GasConversionRatio.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintQuery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	if len(m.IbcChannel) > 0 {
		i -= len(m.IbcChannel)
		copy(dAtA[i:], m.IbcChannel)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.IbcChannel)))
		i--
		dAtA[i] = 0x2a
	}
	{
		size := m.NetFlow.Size()
		i -= size
		if _, err := m.NetFlow.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintQuery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size := m.TotalRewardsReceived.Size()
		i -= size
		if _, err := m.TotalRewardsReceived.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintQuery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.TotalBurned.Size()
		i -= size
		if _, err := m.TotalBurned.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintQuery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.ChainId) > 0 {
		i -= len(m.ChainId)
		copy(dAtA[i:], m.ChainId)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.ChainId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryFeeStatsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryFeeStatsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryFeeStatsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *QueryFeeStatsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryFeeStatsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryFeeStatsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.TreasuryFeeRatio.Size()
		i -= size
		if _, err := m.TreasuryFeeRatio.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintQuery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	{
		size := m.FeeBurnRatio.Size()
		i -= size
		if _, err := m.FeeBurnRatio.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintQuery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	if m.FeeBurnEnabled {
		i--
		if m.FeeBurnEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	{
		size := m.AverageFeesBurnedPerBlock.Size()
		i -= size
		if _, err := m.AverageFeesBurnedPerBlock.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintQuery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.TotalFeesToTreasury.Size()
		i -= size
		if _, err := m.TotalFeesToTreasury.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintQuery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size := m.TotalFeesBurned.Size()
		i -= size
		if _, err := m.TotalFeesBurned.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintQuery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *QueryBurnRateRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryBurnRateRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryBurnRateRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *QueryBurnRateResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryBurnRateResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryBurnRateResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.EmergencyBurnOverride {
		i--
		if m.EmergencyBurnOverride {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	{
		size := m.AvgTxPerDay.Size()
		i -= size
		if _, err := m.AvgTxPerDay.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintQuery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x4a
	{
		size := m.TreasuryPct.Size()
		i -= size
		if _, err := m.TreasuryPct.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintQuery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x42
	{
		size := m.BlockCongestion.Size()
		i -= size
		if _, err := m.BlockCongestion.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintQuery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	{
		size := m.DefaultBurnRatio.Size()
		i -= size
		if _, err := m.DefaultBurnRatio.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintQuery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	{
		size := m.MaxBurnRatio.Size()
		i -= size
		if _, err := m.MaxBurnRatio.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintQuery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size := m.MinBurnRatio.Size()
		i -= size
		if _, err := m.MinBurnRatio.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintQuery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.Trigger) > 0 {
		i -= len(m.Trigger)
		copy(dAtA[i:], m.Trigger)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Trigger)))
		i--
		dAtA[i] = 0x1a
	}
	{
		size := m.CurrentBurnRatio.Size()
		i -= size
		if _, err := m.CurrentBurnRatio.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintQuery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.AdaptiveBurnEnabled {
		i--
		if m.AdaptiveBurnEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintQuery(dAtA []byte, offset int, v uint64) int {
	offset -= sovQuery(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *QueryParamsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *QueryParamsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Params.Size()
	n += 1 + l + sovQuery(uint64(l))
	return n
}

func (m *QuerySupplyRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *QuerySupplyResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.TotalSupplyCap.Size()
	n += 1 + l + sovQuery(uint64(l))
	l = m.CurrentTotalSupply.Size()
	n += 1 + l + sovQuery(uint64(l))
	l = m.TotalMinted.Size()
	n += 1 + l + sovQuery(uint64(l))
	l = m.TotalBurned.Size()
	n += 1 + l + sovQuery(uint64(l))
	l = m.RemainingMintable.Size()
	n += 1 + l + sovQuery(uint64(l))
	l = m.SupplyPctOfCap.Size()
	n += 1 + l + sovQuery(uint64(l))
	l = m.NetInflationRate.Size()
	n += 1 + l + sovQuery(uint64(l))
	return n
}

func (m *QueryInflationRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *QueryInflationResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.CurrentInflationRate.Size()
	n += 1 + l + sovQuery(uint64(l))
	l = m.InflationMin.Size()
	n += 1 + l + sovQuery(uint64(l))
	l = m.InflationMax.Size()
	n += 1 + l + sovQuery(uint64(l))
	l = m.AnnualProvisions.Size()
	n += 1 + l + sovQuery(uint64(l))
	l = m.BlockProvisions.Size()
	n += 1 + l + sovQuery(uint64(l))
	if m.BlocksPerYear != 0 {
		n += 1 + sovQuery(uint64(m.BlocksPerYear))
	}
	return n
}

func (m *QueryEmissionsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *EmissionAllocation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Category)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = m.Percentage.Size()
	n += 1 + l + sovQuery(uint64(l))
	l = m.AnnualAmount.Size()
	n += 1 + l + sovQuery(uint64(l))
	l = m.TotalDistributed.Size()
	n += 1 + l + sovQuery(uint64(l))
	return n
}

func (m *QueryEmissionsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Allocations) > 0 {
		for _, e := range m.Allocations {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	l = m.TotalAnnualEmissions.Size()
	n += 1 + l + sovQuery(uint64(l))
	if m.LastDistributionHeight != 0 {
		n += 1 + sovQuery(uint64(m.LastDistributionHeight))
	}
	return n
}

func (m *QueryBurnsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Pagination != nil {
		l = m.Pagination.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *BurnRecord) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BurnId != 0 {
		n += 1 + sovQuery(uint64(m.BurnId))
	}
	l = m.Amount.Size()
	n += 1 + l + sovQuery(uint64(l))
	if m.Source != 0 {
		n += 1 + sovQuery(uint64(m.Source))
	}
	l = len(m.ChainId)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.BlockHeight != 0 {
		n += 1 + sovQuery(uint64(m.BlockHeight))
	}
	l = len(m.TxHash)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.Timestamp != 0 {
		n += 1 + sovQuery(uint64(m.Timestamp))
	}
	l = len(m.BurnerAddress)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = m.TreasuryRedirect.Size()
	n += 1 + l + sovQuery(uint64(l))
	return n
}

func (m *QueryBurnsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Burns) > 0 {
		for _, e := range m.Burns {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	if m.Pagination != nil {
		l = m.Pagination.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	l = m.TotalBurned.Size()
	n += 1 + l + sovQuery(uint64(l))
	return n
}

func (m *QueryBurnsBySourceRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Source != 0 {
		n += 1 + sovQuery(uint64(m.Source))
	}
	if m.Pagination != nil {
		l = m.Pagination.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *BurnsBySourceStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Source != 0 {
		n += 1 + sovQuery(uint64(m.Source))
	}
	l = m.TotalAmount.Size()
	n += 1 + l + sovQuery(uint64(l))
	if m.BurnCount != 0 {
		n += 1 + sovQuery(uint64(m.BurnCount))
	}
	l = m.CurrentBurnRate.Size()
	n += 1 + l + sovQuery(uint64(l))
	l = m.AverageBurnAmount.Size()
	n += 1 + l + sovQuery(uint64(l))
	return n
}

func (m *QueryBurnsBySourceResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Burns) > 0 {
		for _, e := range m.Burns {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	if m.Pagination != nil {
		l = m.Pagination.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	l = m.Stats.Size()
	n += 1 + l + sovQuery(uint64(l))
	return n
}

func (m *QueryBurnsByChainRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ChainId)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.Pagination != nil {
		l = m.Pagination.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryBurnsByChainResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Burns) > 0 {
		for _, e := range m.Burns {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	if m.Pagination != nil {
		l = m.Pagination.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	l = m.TotalBurnedOnChain.Size()
	n += 1 + l + sovQuery(uint64(l))
	return n
}

func (m *QueryTreasuryRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *QueryTreasuryResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.TreasuryBalance.Size()
	n += 1 + l + sovQuery(uint64(l))
	l = m.TotalTreasuryInflows.Size()
	n += 1 + l + sovQuery(uint64(l))
	l = m.FromInflation.Size()
	n += 1 + l + sovQuery(uint64(l))
	l = m.FromBurnRedirect.Size()
	n += 1 + l + sovQuery(uint64(l))
	l = m.TreasuryBurnRedirectPct.Size()
	n += 1 + l + sovQuery(uint64(l))
	l = len(m.TreasuryAddress)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryProjectionsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.YearsAhead != 0 {
		n += 1 + sovQuery(uint64(m.YearsAhead))
	}
	if m.AssumeConstantBurnRate {
		n += 2
	}
	return n
}

func (m *SupplyProjection) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Year != 0 {
		n += 1 + sovQuery(uint64(m.Year))
	}
	l = m.ProjectedSupply.Size()
	n += 1 + l + sovQuery(uint64(l))
	l = m.ProjectedMinted.Size()
	n += 1 + l + sovQuery(uint64(l))
	l = m.ProjectedBurned.Size()
	n += 1 + l + sovQuery(uint64(l))
	l = m.NetGrowthRate.Size()
	n += 1 + l + sovQuery(uint64(l))
	if m.YearsUntilCap != 0 {
		n += 1 + sovQuery(uint64(m.YearsUntilCap))
	}
	return n
}

func (m *QueryProjectionsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Projections) > 0 {
		for _, e := range m.Projections {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	l = len(m.Assumptions)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryChainMetricsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ChainId)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryChainMetricsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ChainId)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = m.TotalBurned.Size()
	n += 1 + l + sovQuery(uint64(l))
	l = m.TotalRewardsReceived.Size()
	n += 1 + l + sovQuery(uint64(l))
	l = m.NetFlow.Size()
	n += 1 + l + sovQuery(uint64(l))
	l = len(m.IbcChannel)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = m.GasConversionRatio.Size()
	n += 1 + l + sovQuery(uint64(l))
	if m.LastRewardHeight != 0 {
		n += 1 + sovQuery(uint64(m.LastRewardHeight))
	}
	if m.LastBurnReportHeight != 0 {
		n += 1 + sovQuery(uint64(m.LastBurnReportHeight))
	}
	return n
}

func (m *QueryFeeStatsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *QueryFeeStatsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.TotalFeesBurned.Size()
	n += 1 + l + sovQuery(uint64(l))
	l = m.TotalFeesToTreasury.Size()
	n += 1 + l + sovQuery(uint64(l))
	l = m.AverageFeesBurnedPerBlock.Size()
	n += 1 + l + sovQuery(uint64(l))
	if m.FeeBurnEnabled {
		n += 2
	}
	l = m.FeeBurnRatio.Size()
	n += 1 + l + sovQuery(uint64(l))
	l = m.TreasuryFeeRatio.Size()
	n += 1 + l + sovQuery(uint64(l))
	return n
}

func (m *QueryBurnRateRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *QueryBurnRateResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AdaptiveBurnEnabled {
		n += 2
	}
	l = m.CurrentBurnRatio.Size()
	n += 1 + l + sovQuery(uint64(l))
	l = len(m.Trigger)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = m.MinBurnRatio.Size()
	n += 1 + l + sovQuery(uint64(l))
	l = m.MaxBurnRatio.Size()
	n += 1 + l + sovQuery(uint64(l))
	l = m.DefaultBurnRatio.Size()
	n += 1 + l + sovQuery(uint64(l))
	l = m.BlockCongestion.Size()
	n += 1 + l + sovQuery(uint64(l))
	l = m.TreasuryPct.Size()
	n += 1 + l + sovQuery(uint64(l))
	l = m.AvgTxPerDay.Size()
	n += 1 + l + sovQuery(uint64(l))
	if m.EmergencyBurnOverride {
		n += 2
	}
	return n
}

func sovQuery(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozQuery(x uint64) (n int) {
	return sovQuery(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *QueryParamsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryParamsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryParamsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryParamsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryParamsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryParamsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QuerySupplyRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QuerySupplyRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QuerySupplyRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QuerySupplyResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QuerySupplyResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QuerySupplyResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalSupplyCap", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalSupplyCap.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentTotalSupply", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CurrentTotalSupply.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalMinted", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalMinted.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalBurned", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalBurned.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemainingMintable", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RemainingMintable.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SupplyPctOfCap", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SupplyPctOfCap.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetInflationRate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.NetInflationRate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryInflationRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryInflationRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryInflationRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryInflationResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryInflationResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryInflationResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentInflationRate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CurrentInflationRate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InflationMin", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.InflationMin.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InflationMax", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.InflationMax.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnnualProvisions", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AnnualProvisions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockProvisions", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.BlockProvisions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlocksPerYear", wireType)
			}
			m.BlocksPerYear = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlocksPerYear |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryEmissionsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryEmissionsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryEmissionsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EmissionAllocation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EmissionAllocation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EmissionAllocation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Category", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Category = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Percentage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Percentage.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnnualAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AnnualAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalDistributed", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalDistributed.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryEmissionsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryEmissionsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryEmissionsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Allocations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Allocations = append(m.Allocations, EmissionAllocation{})
			if err := m.Allocations[len(m.Allocations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalAnnualEmissions", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalAnnualEmissions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastDistributionHeight", wireType)
			}
			m.LastDistributionHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastDistributionHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryBurnsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryBurnsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryBurnsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pagination", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pagination == nil {
				m.Pagination = &query.PageRequest{}
			}
			if err := m.Pagination.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BurnRecord) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BurnRecord: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BurnRecord: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BurnId", wireType)
			}
			m.BurnId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BurnId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			m.Source = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Source |= BurnSource(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChainId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockHeight", wireType)
			}
			m.BlockHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BurnerAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BurnerAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TreasuryRedirect", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TreasuryRedirect.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryBurnsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryBurnsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryBurnsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Burns", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Burns = append(m.Burns, BurnRecord{})
			if err := m.Burns[len(m.Burns)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pagination", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pagination == nil {
				m.Pagination = &query.PageResponse{}
			}
			if err := m.Pagination.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalBurned", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalBurned.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryBurnsBySourceRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryBurnsBySourceRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryBurnsBySourceRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			m.Source = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Source |= BurnSource(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pagination", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pagination == nil {
				m.Pagination = &query.PageRequest{}
			}
			if err := m.Pagination.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BurnsBySourceStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BurnsBySourceStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BurnsBySourceStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			m.Source = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Source |= BurnSource(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BurnCount", wireType)
			}
			m.BurnCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BurnCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentBurnRate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CurrentBurnRate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AverageBurnAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AverageBurnAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryBurnsBySourceResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryBurnsBySourceResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryBurnsBySourceResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Burns", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Burns = append(m.Burns, BurnRecord{})
			if err := m.Burns[len(m.Burns)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pagination", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pagination == nil {
				m.Pagination = &query.PageResponse{}
			}
			if err := m.Pagination.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryBurnsByChainRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryBurnsByChainRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryBurnsByChainRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChainId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pagination", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pagination == nil {
				m.Pagination = &query.PageRequest{}
			}
			if err := m.Pagination.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryBurnsByChainResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryBurnsByChainResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryBurnsByChainResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Burns", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Burns = append(m.Burns, BurnRecord{})
			if err := m.Burns[len(m.Burns)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pagination", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pagination == nil {
				m.Pagination = &query.PageResponse{}
			}
			if err := m.Pagination.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalBurnedOnChain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalBurnedOnChain.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryTreasuryRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryTreasuryRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryTreasuryRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryTreasuryResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryTreasuryResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryTreasuryResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TreasuryBalance", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TreasuryBalance.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalTreasuryInflows", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalTreasuryInflows.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromInflation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.FromInflation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromBurnRedirect", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.FromBurnRedirect.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TreasuryBurnRedirectPct", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TreasuryBurnRedirectPct.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TreasuryAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TreasuryAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryProjectionsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryProjectionsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryProjectionsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field YearsAhead", wireType)
			}
			m.YearsAhead = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.YearsAhead |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssumeConstantBurnRate", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AssumeConstantBurnRate = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SupplyProjection) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SupplyProjection: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SupplyProjection: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Year", wireType)
			}
			m.Year = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Year |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProjectedSupply", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ProjectedSupply.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProjectedMinted", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ProjectedMinted.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProjectedBurned", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ProjectedBurned.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetGrowthRate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.NetGrowthRate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field YearsUntilCap", wireType)
			}
			m.YearsUntilCap = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.YearsUntilCap |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryProjectionsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryProjectionsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryProjectionsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Projections", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Projections = append(m.Projections, SupplyProjection{})
			if err := m.Projections[len(m.Projections)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Assumptions", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Assumptions = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryChainMetricsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryChainMetricsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryChainMetricsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChainId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryChainMetricsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryChainMetricsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryChainMetricsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChainId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalBurned", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalBurned.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalRewardsReceived", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalRewardsReceived.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetFlow", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.NetFlow.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IbcChannel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IbcChannel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GasConversionRatio", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.GasConversionRatio.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastRewardHeight", wireType)
			}
			m.LastRewardHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastRewardHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastBurnReportHeight", wireType)
			}
			m.LastBurnReportHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastBurnReportHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryFeeStatsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryFeeStatsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryFeeStatsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryFeeStatsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryFeeStatsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryFeeStatsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalFeesBurned", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalFeesBurned.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalFeesToTreasury", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalFeesToTreasury.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AverageFeesBurnedPerBlock", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AverageFeesBurnedPerBlock.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeeBurnEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.FeeBurnEnabled = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeeBurnRatio", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.FeeBurnRatio.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TreasuryFeeRatio", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TreasuryFeeRatio.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryBurnRateRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryBurnRateRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryBurnRateRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryBurnRateResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryBurnRateResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryBurnRateResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdaptiveBurnEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AdaptiveBurnEnabled = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentBurnRatio", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CurrentBurnRatio.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Trigger", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Trigger = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinBurnRatio", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MinBurnRatio.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxBurnRatio", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MaxBurnRatio.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultBurnRatio", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.DefaultBurnRatio.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockCongestion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.BlockCongestion.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TreasuryPct", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TreasuryPct.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AvgTxPerDay", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AvgTxPerDay.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EmergencyBurnOverride", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EmergencyBurnOverride = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipQuery(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthQuery
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupQuery
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthQuery
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthQuery        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowQuery          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupQuery = fmt.Errorf("proto: unexpected end of group")
)
