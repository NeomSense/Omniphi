// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: pos/tokenomics/v1/genesis.proto

package types

import (
	cosmossdk_io_math "cosmossdk.io/math"
	fmt "fmt"
	_ "github.com/cosmos/cosmos-proto"
	_ "github.com/cosmos/cosmos-sdk/types/tx/amino"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// AllocationCategory defines the type of genesis allocation
type AllocationCategory int32

const (
	AllocationCategory_ALLOCATION_CATEGORY_UNSPECIFIED AllocationCategory = 0
	AllocationCategory_ALLOCATION_CATEGORY_TREASURY    AllocationCategory = 1
	AllocationCategory_ALLOCATION_CATEGORY_VALIDATORS  AllocationCategory = 2
	AllocationCategory_ALLOCATION_CATEGORY_TEAM        AllocationCategory = 3
	AllocationCategory_ALLOCATION_CATEGORY_INVESTORS   AllocationCategory = 4
	AllocationCategory_ALLOCATION_CATEGORY_COMMUNITY   AllocationCategory = 5
	AllocationCategory_ALLOCATION_CATEGORY_LIQUIDITY   AllocationCategory = 6
	AllocationCategory_ALLOCATION_CATEGORY_ECOSYSTEM   AllocationCategory = 7
	AllocationCategory_ALLOCATION_CATEGORY_RESERVE     AllocationCategory = 8
)

var AllocationCategory_name = map[int32]string{
	0: "ALLOCATION_CATEGORY_UNSPECIFIED",
	1: "ALLOCATION_CATEGORY_TREASURY",
	2: "ALLOCATION_CATEGORY_VALIDATORS",
	3: "ALLOCATION_CATEGORY_TEAM",
	4: "ALLOCATION_CATEGORY_INVESTORS",
	5: "ALLOCATION_CATEGORY_COMMUNITY",
	6: "ALLOCATION_CATEGORY_LIQUIDITY",
	7: "ALLOCATION_CATEGORY_ECOSYSTEM",
	8: "ALLOCATION_CATEGORY_RESERVE",
}

var AllocationCategory_value = map[string]int32{
	"ALLOCATION_CATEGORY_UNSPECIFIED": 0,
	"ALLOCATION_CATEGORY_TREASURY":    1,
	"ALLOCATION_CATEGORY_VALIDATORS":  2,
	"ALLOCATION_CATEGORY_TEAM":        3,
	"ALLOCATION_CATEGORY_INVESTORS":   4,
	"ALLOCATION_CATEGORY_COMMUNITY":   5,
	"ALLOCATION_CATEGORY_LIQUIDITY":   6,
	"ALLOCATION_CATEGORY_ECOSYSTEM":   7,
	"ALLOCATION_CATEGORY_RESERVE":     8,
}

func (x AllocationCategory) String() string {
	return proto.EnumName(AllocationCategory_name, int32(x))
}

func (AllocationCategory) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_51e100557b0d7630, []int{0}
}

// GenesisState defines the tokenomics module's genesis state.
type GenesisState struct {
	// params defines all the parameters of the module.
	Params TokenomicsParams `protobuf:"bytes,1,opt,name=params,proto3" json:"params"`
	// supply_state tracks the token supply at genesis
	SupplyState SupplyState `protobuf:"bytes,2,opt,name=supply_state,json=supplyState,proto3" json:"supply_state"`
	// allocations defines the initial token distribution
	Allocations []GenesisAllocation `protobuf:"bytes,3,rep,name=allocations,proto3" json:"allocations"`
	// burn_records contains historical burn data (optional, for chain upgrades)
	BurnRecords []BurnRecord `protobuf:"bytes,4,rep,name=burn_records,json=burnRecords,proto3" json:"burn_records"`
	// emission_history contains historical emission data (optional, for chain upgrades)
	EmissionRecords []EmissionRecord `protobuf:"bytes,5,rep,name=emission_records,json=emissionRecords,proto3" json:"emission_records"`
	// treasury_state tracks the DAO treasury at genesis
	TreasuryState TreasuryState `protobuf:"bytes,6,opt,name=treasury_state,json=treasuryState,proto3" json:"treasury_state"`
	// chain_states tracks per-chain metrics (for tri-chain coordination)
	ChainStates []ChainState `protobuf:"bytes,7,rep,name=chain_states,json=chainStates,proto3" json:"chain_states"`
}

func (m *GenesisState) Reset()         { *m = GenesisState{} }
func (m *GenesisState) String() string { return proto.CompactTextString(m) }
func (*GenesisState) ProtoMessage()    {}
func (*GenesisState) Descriptor() ([]byte, []int) {
	return fileDescriptor_51e100557b0d7630, []int{0}
}
func (m *GenesisState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GenesisState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GenesisState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GenesisState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GenesisState.Merge(m, src)
}
func (m *GenesisState) XXX_Size() int {
	return m.Size()
}
func (m *GenesisState) XXX_DiscardUnknown() {
	xxx_messageInfo_GenesisState.DiscardUnknown(m)
}

var xxx_messageInfo_GenesisState proto.InternalMessageInfo

func (m *GenesisState) GetParams() TokenomicsParams {
	if m != nil {
		return m.Params
	}
	return TokenomicsParams{}
}

func (m *GenesisState) GetSupplyState() SupplyState {
	if m != nil {
		return m.SupplyState
	}
	return SupplyState{}
}

func (m *GenesisState) GetAllocations() []GenesisAllocation {
	if m != nil {
		return m.Allocations
	}
	return nil
}

func (m *GenesisState) GetBurnRecords() []BurnRecord {
	if m != nil {
		return m.BurnRecords
	}
	return nil
}

func (m *GenesisState) GetEmissionRecords() []EmissionRecord {
	if m != nil {
		return m.EmissionRecords
	}
	return nil
}

func (m *GenesisState) GetTreasuryState() TreasuryState {
	if m != nil {
		return m.TreasuryState
	}
	return TreasuryState{}
}

func (m *GenesisState) GetChainStates() []ChainState {
	if m != nil {
		return m.ChainStates
	}
	return nil
}

// SupplyState tracks the token supply at genesis
type SupplyState struct {
	// current_total_supply is the circulating supply at genesis
	// Default: 375,000,000 OMNI (25% of 1.5B cap)
	CurrentTotalSupply cosmossdk_io_math.Int `protobuf:"bytes,1,opt,name=current_total_supply,json=currentTotalSupply,proto3,customtype=cosmossdk.io/math.Int" json:"current_total_supply"`
	// total_minted is the cumulative minted amount
	// Default: 375,000,000 OMNI (genesis allocation)
	TotalMinted cosmossdk_io_math.Int `protobuf:"bytes,2,opt,name=total_minted,json=totalMinted,proto3,customtype=cosmossdk.io/math.Int" json:"total_minted"`
	// total_burned is the cumulative burned amount
	// Default: 0 OMNI (no burns at genesis)
	TotalBurned cosmossdk_io_math.Int `protobuf:"bytes,3,opt,name=total_burned,json=totalBurned,proto3,customtype=cosmossdk.io/math.Int" json:"total_burned"`
}

func (m *SupplyState) Reset()         { *m = SupplyState{} }
func (m *SupplyState) String() string { return proto.CompactTextString(m) }
func (*SupplyState) ProtoMessage()    {}
func (*SupplyState) Descriptor() ([]byte, []int) {
	return fileDescriptor_51e100557b0d7630, []int{1}
}
func (m *SupplyState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SupplyState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SupplyState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SupplyState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SupplyState.Merge(m, src)
}
func (m *SupplyState) XXX_Size() int {
	return m.Size()
}
func (m *SupplyState) XXX_DiscardUnknown() {
	xxx_messageInfo_SupplyState.DiscardUnknown(m)
}

var xxx_messageInfo_SupplyState proto.InternalMessageInfo

// VestingSchedule defines token vesting parameters
type VestingSchedule struct {
	// cliff_duration is the time before vesting starts (seconds)
	CliffDuration uint64 `protobuf:"varint,1,opt,name=cliff_duration,json=cliffDuration,proto3" json:"cliff_duration,omitempty"`
	// vesting_duration is the total vesting period (seconds)
	VestingDuration uint64 `protobuf:"varint,2,opt,name=vesting_duration,json=vestingDuration,proto3" json:"vesting_duration,omitempty"`
	// start_time is the vesting start timestamp (Unix seconds)
	StartTime int64 `protobuf:"varint,3,opt,name=start_time,json=startTime,proto3" json:"start_time,omitempty"`
	// is_continuous is true for linear vesting, false for milestone-based
	IsContinuous bool `protobuf:"varint,4,opt,name=is_continuous,json=isContinuous,proto3" json:"is_continuous,omitempty"`
}

func (m *VestingSchedule) Reset()         { *m = VestingSchedule{} }
func (m *VestingSchedule) String() string { return proto.CompactTextString(m) }
func (*VestingSchedule) ProtoMessage()    {}
func (*VestingSchedule) Descriptor() ([]byte, []int) {
	return fileDescriptor_51e100557b0d7630, []int{2}
}
func (m *VestingSchedule) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VestingSchedule) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VestingSchedule.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VestingSchedule) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VestingSchedule.Merge(m, src)
}
func (m *VestingSchedule) XXX_Size() int {
	return m.Size()
}
func (m *VestingSchedule) XXX_DiscardUnknown() {
	xxx_messageInfo_VestingSchedule.DiscardUnknown(m)
}

var xxx_messageInfo_VestingSchedule proto.InternalMessageInfo

func (m *VestingSchedule) GetCliffDuration() uint64 {
	if m != nil {
		return m.CliffDuration
	}
	return 0
}

func (m *VestingSchedule) GetVestingDuration() uint64 {
	if m != nil {
		return m.VestingDuration
	}
	return 0
}

func (m *VestingSchedule) GetStartTime() int64 {
	if m != nil {
		return m.StartTime
	}
	return 0
}

func (m *VestingSchedule) GetIsContinuous() bool {
	if m != nil {
		return m.IsContinuous
	}
	return false
}

// GenesisAllocation defines an initial token distribution
type GenesisAllocation struct {
	// address is the recipient address or module account
	Address string `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	// amount is the allocated amount in micro-OMNI
	Amount cosmossdk_io_math.Int `protobuf:"bytes,2,opt,name=amount,proto3,customtype=cosmossdk.io/math.Int" json:"amount"`
	// category is the allocation type
	Category AllocationCategory `protobuf:"varint,3,opt,name=category,proto3,enum=pos.tokenomics.v1.AllocationCategory" json:"category,omitempty"`
	// vesting_schedule defines vesting parameters (optional)
	VestingSchedule *VestingSchedule `protobuf:"bytes,4,opt,name=vesting_schedule,json=vestingSchedule,proto3" json:"vesting_schedule,omitempty"`
	// description explains the allocation (e.g., "Team - Co-Founder Alice")
	Description string `protobuf:"bytes,5,opt,name=description,proto3" json:"description,omitempty"`
	// is_vested is true if tokens are subject to vesting
	IsVested bool `protobuf:"varint,6,opt,name=is_vested,json=isVested,proto3" json:"is_vested,omitempty"`
	// percentage_of_genesis is the allocation as % of genesis supply
	PercentageOfGenesis cosmossdk_io_math.LegacyDec `protobuf:"bytes,7,opt,name=percentage_of_genesis,json=percentageOfGenesis,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"percentage_of_genesis"`
}

func (m *GenesisAllocation) Reset()         { *m = GenesisAllocation{} }
func (m *GenesisAllocation) String() string { return proto.CompactTextString(m) }
func (*GenesisAllocation) ProtoMessage()    {}
func (*GenesisAllocation) Descriptor() ([]byte, []int) {
	return fileDescriptor_51e100557b0d7630, []int{3}
}
func (m *GenesisAllocation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GenesisAllocation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GenesisAllocation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GenesisAllocation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GenesisAllocation.Merge(m, src)
}
func (m *GenesisAllocation) XXX_Size() int {
	return m.Size()
}
func (m *GenesisAllocation) XXX_DiscardUnknown() {
	xxx_messageInfo_GenesisAllocation.DiscardUnknown(m)
}

var xxx_messageInfo_GenesisAllocation proto.InternalMessageInfo

func (m *GenesisAllocation) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *GenesisAllocation) GetCategory() AllocationCategory {
	if m != nil {
		return m.Category
	}
	return AllocationCategory_ALLOCATION_CATEGORY_UNSPECIFIED
}

func (m *GenesisAllocation) GetVestingSchedule() *VestingSchedule {
	if m != nil {
		return m.VestingSchedule
	}
	return nil
}

func (m *GenesisAllocation) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *GenesisAllocation) GetIsVested() bool {
	if m != nil {
		return m.IsVested
	}
	return false
}

// EmissionRecord tracks historical emission events
type EmissionRecord struct {
	// emission_id is a unique identifier
	EmissionId uint64 `protobuf:"varint,1,opt,name=emission_id,json=emissionId,proto3" json:"emission_id,omitempty"`
	// block_height is when the emission occurred
	BlockHeight int64 `protobuf:"varint,2,opt,name=block_height,json=blockHeight,proto3" json:"block_height,omitempty"`
	// total_emitted is the total amount distributed
	TotalEmitted cosmossdk_io_math.Int `protobuf:"bytes,3,opt,name=total_emitted,json=totalEmitted,proto3,customtype=cosmossdk.io/math.Int" json:"total_emitted"`
	// to_staking is the amount sent to PoS validators
	ToStaking cosmossdk_io_math.Int `protobuf:"bytes,4,opt,name=to_staking,json=toStaking,proto3,customtype=cosmossdk.io/math.Int" json:"to_staking"`
	// to_poc is the amount sent to PoC contributors
	ToPoc cosmossdk_io_math.Int `protobuf:"bytes,5,opt,name=to_poc,json=toPoc,proto3,customtype=cosmossdk.io/math.Int" json:"to_poc"`
	// to_sequencer is the amount sent to sequencer operators
	ToSequencer cosmossdk_io_math.Int `protobuf:"bytes,6,opt,name=to_sequencer,json=toSequencer,proto3,customtype=cosmossdk.io/math.Int" json:"to_sequencer"`
	// to_treasury is the amount sent to DAO treasury
	ToTreasury cosmossdk_io_math.Int `protobuf:"bytes,7,opt,name=to_treasury,json=toTreasury,proto3,customtype=cosmossdk.io/math.Int" json:"to_treasury"`
	// timestamp is the block timestamp
	Timestamp int64 `protobuf:"varint,8,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
}

func (m *EmissionRecord) Reset()         { *m = EmissionRecord{} }
func (m *EmissionRecord) String() string { return proto.CompactTextString(m) }
func (*EmissionRecord) ProtoMessage()    {}
func (*EmissionRecord) Descriptor() ([]byte, []int) {
	return fileDescriptor_51e100557b0d7630, []int{4}
}
func (m *EmissionRecord) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EmissionRecord) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EmissionRecord.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EmissionRecord) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EmissionRecord.Merge(m, src)
}
func (m *EmissionRecord) XXX_Size() int {
	return m.Size()
}
func (m *EmissionRecord) XXX_DiscardUnknown() {
	xxx_messageInfo_EmissionRecord.DiscardUnknown(m)
}

var xxx_messageInfo_EmissionRecord proto.InternalMessageInfo

func (m *EmissionRecord) GetEmissionId() uint64 {
	if m != nil {
		return m.EmissionId
	}
	return 0
}

func (m *EmissionRecord) GetBlockHeight() int64 {
	if m != nil {
		return m.BlockHeight
	}
	return 0
}

func (m *EmissionRecord) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

// TreasuryState tracks the DAO treasury at genesis
type TreasuryState struct {
	// treasury_address is the DAO treasury account
	TreasuryAddress string `protobuf:"bytes,1,opt,name=treasury_address,json=treasuryAddress,proto3" json:"treasury_address,omitempty"`
	// initial_balance is the genesis treasury allocation
	InitialBalance cosmossdk_io_math.Int `protobuf:"bytes,2,opt,name=initial_balance,json=initialBalance,proto3,customtype=cosmossdk.io/math.Int" json:"initial_balance"`
	// total_inflows is cumulative treasury deposits
	TotalInflows cosmossdk_io_math.Int `protobuf:"bytes,3,opt,name=total_inflows,json=totalInflows,proto3,customtype=cosmossdk.io/math.Int" json:"total_inflows"`
	// from_inflation is the amount from emission splits
	FromInflation cosmossdk_io_math.Int `protobuf:"bytes,4,opt,name=from_inflation,json=fromInflation,proto3,customtype=cosmossdk.io/math.Int" json:"from_inflation"`
	// from_burn_redirect is the amount from burn redirection
	FromBurnRedirect cosmossdk_io_math.Int `protobuf:"bytes,5,opt,name=from_burn_redirect,json=fromBurnRedirect,proto3,customtype=cosmossdk.io/math.Int" json:"from_burn_redirect"`
}

func (m *TreasuryState) Reset()         { *m = TreasuryState{} }
func (m *TreasuryState) String() string { return proto.CompactTextString(m) }
func (*TreasuryState) ProtoMessage()    {}
func (*TreasuryState) Descriptor() ([]byte, []int) {
	return fileDescriptor_51e100557b0d7630, []int{5}
}
func (m *TreasuryState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TreasuryState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TreasuryState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TreasuryState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TreasuryState.Merge(m, src)
}
func (m *TreasuryState) XXX_Size() int {
	return m.Size()
}
func (m *TreasuryState) XXX_DiscardUnknown() {
	xxx_messageInfo_TreasuryState.DiscardUnknown(m)
}

var xxx_messageInfo_TreasuryState proto.InternalMessageInfo

func (m *TreasuryState) GetTreasuryAddress() string {
	if m != nil {
		return m.TreasuryAddress
	}
	return ""
}

// ChainState tracks per-chain tokenomics metrics
type ChainState struct {
	// chain_id identifies the chain (e.g., "omniphi-core", "omniphi-continuity")
	ChainId string `protobuf:"bytes,1,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	// total_burned is the cumulative burns from this chain
	TotalBurned cosmossdk_io_math.Int `protobuf:"bytes,2,opt,name=total_burned,json=totalBurned,proto3,customtype=cosmossdk.io/math.Int" json:"total_burned"`
	// total_rewards_sent is the cumulative IBC rewards sent to this chain
	TotalRewardsSent cosmossdk_io_math.Int `protobuf:"bytes,3,opt,name=total_rewards_sent,json=totalRewardsSent,proto3,customtype=cosmossdk.io/math.Int" json:"total_rewards_sent"`
	// ibc_channel is the IBC channel ID (e.g., "channel-0")
	IbcChannel string `protobuf:"bytes,4,opt,name=ibc_channel,json=ibcChannel,proto3" json:"ibc_channel,omitempty"`
	// is_active indicates if the chain is currently operational
	IsActive bool `protobuf:"varint,5,opt,name=is_active,json=isActive,proto3" json:"is_active,omitempty"`
	// last_sync_height is the last block height synchronized with Core
	LastSyncHeight int64 `protobuf:"varint,6,opt,name=last_sync_height,json=lastSyncHeight,proto3" json:"last_sync_height,omitempty"`
}

func (m *ChainState) Reset()         { *m = ChainState{} }
func (m *ChainState) String() string { return proto.CompactTextString(m) }
func (*ChainState) ProtoMessage()    {}
func (*ChainState) Descriptor() ([]byte, []int) {
	return fileDescriptor_51e100557b0d7630, []int{6}
}
func (m *ChainState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChainState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChainState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ChainState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChainState.Merge(m, src)
}
func (m *ChainState) XXX_Size() int {
	return m.Size()
}
func (m *ChainState) XXX_DiscardUnknown() {
	xxx_messageInfo_ChainState.DiscardUnknown(m)
}

var xxx_messageInfo_ChainState proto.InternalMessageInfo

func (m *ChainState) GetChainId() string {
	if m != nil {
		return m.ChainId
	}
	return ""
}

func (m *ChainState) GetIbcChannel() string {
	if m != nil {
		return m.IbcChannel
	}
	return ""
}

func (m *ChainState) GetIsActive() bool {
	if m != nil {
		return m.IsActive
	}
	return false
}

func (m *ChainState) GetLastSyncHeight() int64 {
	if m != nil {
		return m.LastSyncHeight
	}
	return 0
}

// DefaultGenesisState returns the default tokenomics genesis state
// This defines the INITIAL token distribution for mainnet launch
type DefaultGenesisState struct {
	// Treasury: 30% = 112,500,000 OMNI
	// Purpose: DAO-controlled funds for ecosystem development
	TreasuryAllocation string `protobuf:"bytes,1,opt,name=treasury_allocation,json=treasuryAllocation,proto3" json:"treasury_allocation,omitempty"`
	// Validators: 15% = 56,250,000 OMNI
	// Purpose: Initial validator genesis stake for network security
	ValidatorAllocation string `protobuf:"bytes,2,opt,name=validator_allocation,json=validatorAllocation,proto3" json:"validator_allocation,omitempty"`
	// Team: 20% = 75,000,000 OMNI (4-year vest, 1-year cliff)
	// Purpose: Core team incentive alignment
	TeamAllocation string `protobuf:"bytes,3,opt,name=team_allocation,json=teamAllocation,proto3" json:"team_allocation,omitempty"`
	// Investors: 15% = 56,250,000 OMNI (3-year vest, 6-month cliff)
	// Purpose: Strategic investors and VCs
	InvestorAllocation string `protobuf:"bytes,4,opt,name=investor_allocation,json=investorAllocation,proto3" json:"investor_allocation,omitempty"`
	// Community: 10% = 37,500,000 OMNI
	// Purpose: Airdrops, grants, community rewards
	CommunityAllocation string `protobuf:"bytes,5,opt,name=community_allocation,json=communityAllocation,proto3" json:"community_allocation,omitempty"`
	// Liquidity: 5% = 18,750,000 OMNI
	// Purpose: DEX liquidity pools (Osmosis, etc.)
	LiquidityAllocation string `protobuf:"bytes,6,opt,name=liquidity_allocation,json=liquidityAllocation,proto3" json:"liquidity_allocation,omitempty"`
	// Ecosystem: 3% = 11,250,000 OMNI
	// Purpose: Developer grants, hackathons, integrations
	EcosystemAllocation string `protobuf:"bytes,7,opt,name=ecosystem_allocation,json=ecosystemAllocation,proto3" json:"ecosystem_allocation,omitempty"`
	// Reserve: 2% = 7,500,000 OMNI
	// Purpose: Emergency reserve for unforeseen events
	ReserveAllocation string `protobuf:"bytes,8,opt,name=reserve_allocation,json=reserveAllocation,proto3" json:"reserve_allocation,omitempty"`
}

func (m *DefaultGenesisState) Reset()         { *m = DefaultGenesisState{} }
func (m *DefaultGenesisState) String() string { return proto.CompactTextString(m) }
func (*DefaultGenesisState) ProtoMessage()    {}
func (*DefaultGenesisState) Descriptor() ([]byte, []int) {
	return fileDescriptor_51e100557b0d7630, []int{7}
}
func (m *DefaultGenesisState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DefaultGenesisState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DefaultGenesisState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DefaultGenesisState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DefaultGenesisState.Merge(m, src)
}
func (m *DefaultGenesisState) XXX_Size() int {
	return m.Size()
}
func (m *DefaultGenesisState) XXX_DiscardUnknown() {
	xxx_messageInfo_DefaultGenesisState.DiscardUnknown(m)
}

var xxx_messageInfo_DefaultGenesisState proto.InternalMessageInfo

func (m *DefaultGenesisState) GetTreasuryAllocation() string {
	if m != nil {
		return m.TreasuryAllocation
	}
	return ""
}

func (m *DefaultGenesisState) GetValidatorAllocation() string {
	if m != nil {
		return m.ValidatorAllocation
	}
	return ""
}

func (m *DefaultGenesisState) GetTeamAllocation() string {
	if m != nil {
		return m.TeamAllocation
	}
	return ""
}

func (m *DefaultGenesisState) GetInvestorAllocation() string {
	if m != nil {
		return m.InvestorAllocation
	}
	return ""
}

func (m *DefaultGenesisState) GetCommunityAllocation() string {
	if m != nil {
		return m.CommunityAllocation
	}
	return ""
}

func (m *DefaultGenesisState) GetLiquidityAllocation() string {
	if m != nil {
		return m.LiquidityAllocation
	}
	return ""
}

func (m *DefaultGenesisState) GetEcosystemAllocation() string {
	if m != nil {
		return m.EcosystemAllocation
	}
	return ""
}

func (m *DefaultGenesisState) GetReserveAllocation() string {
	if m != nil {
		return m.ReserveAllocation
	}
	return ""
}

// ValidateGenesisState validates the genesis state
// Enforces:
// 1. Total allocations = genesis supply (375M OMNI)
// 2. Genesis supply <= total_supply_cap (1.5B OMNI)
// 3. All allocation percentages sum to 100%
// 4. Vesting schedules are valid (cliff < vesting_duration)
// 5. Treasury address is valid bech32
// 6. IBC channels are properly formatted
type GenesisValidation struct {
	// total_allocated is the sum of all genesis allocations
	TotalAllocated cosmossdk_io_math.Int `protobuf:"bytes,1,opt,name=total_allocated,json=totalAllocated,proto3,customtype=cosmossdk.io/math.Int" json:"total_allocated"`
	// expected_genesis_supply is the target genesis supply (375M OMNI)
	ExpectedGenesisSupply cosmossdk_io_math.Int `protobuf:"bytes,2,opt,name=expected_genesis_supply,json=expectedGenesisSupply,proto3,customtype=cosmossdk.io/math.Int" json:"expected_genesis_supply"`
	// is_valid is true if all validation checks pass
	IsValid bool `protobuf:"varint,3,opt,name=is_valid,json=isValid,proto3" json:"is_valid,omitempty"`
	// validation_errors contains any validation failures
	ValidationErrors []string `protobuf:"bytes,4,rep,name=validation_errors,json=validationErrors,proto3" json:"validation_errors,omitempty"`
}

func (m *GenesisValidation) Reset()         { *m = GenesisValidation{} }
func (m *GenesisValidation) String() string { return proto.CompactTextString(m) }
func (*GenesisValidation) ProtoMessage()    {}
func (*GenesisValidation) Descriptor() ([]byte, []int) {
	return fileDescriptor_51e100557b0d7630, []int{8}
}
func (m *GenesisValidation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GenesisValidation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GenesisValidation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GenesisValidation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GenesisValidation.Merge(m, src)
}
func (m *GenesisValidation) XXX_Size() int {
	return m.Size()
}
func (m *GenesisValidation) XXX_DiscardUnknown() {
	xxx_messageInfo_GenesisValidation.DiscardUnknown(m)
}

var xxx_messageInfo_GenesisValidation proto.InternalMessageInfo

func (m *GenesisValidation) GetIsValid() bool {
	if m != nil {
		return m.IsValid
	}
	return false
}

func (m *GenesisValidation) GetValidationErrors() []string {
	if m != nil {
		return m.ValidationErrors
	}
	return nil
}

func init() {
	proto.RegisterEnum("pos.tokenomics.v1.AllocationCategory", AllocationCategory_name, AllocationCategory_value)
	proto.RegisterType((*GenesisState)(nil), "pos.tokenomics.v1.GenesisState")
	proto.RegisterType((*SupplyState)(nil), "pos.tokenomics.v1.SupplyState")
	proto.RegisterType((*VestingSchedule)(nil), "pos.tokenomics.v1.VestingSchedule")
	proto.RegisterType((*GenesisAllocation)(nil), "pos.tokenomics.v1.GenesisAllocation")
	proto.RegisterType((*EmissionRecord)(nil), "pos.tokenomics.v1.EmissionRecord")
	proto.RegisterType((*TreasuryState)(nil), "pos.tokenomics.v1.TreasuryState")
	proto.RegisterType((*ChainState)(nil), "pos.tokenomics.v1.ChainState")
	proto.RegisterType((*DefaultGenesisState)(nil), "pos.tokenomics.v1.DefaultGenesisState")
	proto.RegisterType((*GenesisValidation)(nil), "pos.tokenomics.v1.GenesisValidation")
}

func init() { proto.RegisterFile("pos/tokenomics/v1/genesis.proto", fileDescriptor_51e100557b0d7630) }

var fileDescriptor_51e100557b0d7630 = []byte{
	// 1485 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x97, 0x4f, 0x6f, 0x1b, 0x45,
	0x14, 0xc0, 0x63, 0x3b, 0x71, 0xec, 0xe7, 0xc4, 0x71, 0x26, 0x29, 0xb8, 0x7f, 0xe2, 0xa4, 0x2e,
	0x15, 0xa1, 0x55, 0x63, 0x12, 0x3e, 0x81, 0xed, 0xb8, 0xc5, 0x28, 0xff, 0x58, 0x3b, 0x91, 0x82,
	0x84, 0x56, 0x9b, 0xd9, 0x89, 0x33, 0x8a, 0x77, 0xc6, 0xdd, 0x99, 0x4d, 0xeb, 0xef, 0xc0, 0x81,
	0x13, 0x17, 0x2e, 0xdc, 0x40, 0xe2, 0xc2, 0xa1, 0x27, 0xce, 0x1c, 0x2a, 0x4e, 0x55, 0x4f, 0x88,
	0x43, 0x85, 0xda, 0x03, 0x77, 0x3e, 0x01, 0xda, 0x99, 0xd9, 0xb5, 0xdd, 0x38, 0x12, 0x31, 0x97,
	0x28, 0xfb, 0xe6, 0xbd, 0x9f, 0xf7, 0xfd, 0x9f, 0x85, 0xd5, 0x1e, 0x17, 0x15, 0xc9, 0xcf, 0x09,
	0xe3, 0x1e, 0xc5, 0xa2, 0x72, 0xb1, 0x59, 0xe9, 0x10, 0x46, 0x04, 0x15, 0x1b, 0x3d, 0x9f, 0x4b,
	0x8e, 0x16, 0x7b, 0x5c, 0x6c, 0x0c, 0x14, 0x36, 0x2e, 0x36, 0x6f, 0x2d, 0x3a, 0x1e, 0x65, 0xbc,
	0xa2, 0xfe, 0x6a, 0xad, 0x5b, 0x37, 0x31, 0x17, 0x1e, 0x17, 0xb6, 0x7a, 0xaa, 0xe8, 0x07, 0x73,
	0xb4, 0xdc, 0xe1, 0x1d, 0xae, 0xe5, 0xe1, 0x7f, 0x46, 0x5a, 0xba, 0xfc, 0xbb, 0x3d, 0xc7, 0x77,
	0xbc, 0xc8, 0x6a, 0xe5, 0xf2, 0xf9, 0xd3, 0x80, 0xf8, 0x7d, 0x7d, 0x5c, 0xfe, 0x61, 0x1a, 0xe6,
	0x9e, 0xe8, 0xf7, 0x6c, 0x49, 0x47, 0x12, 0xf4, 0x18, 0xd2, 0xda, 0xbe, 0x98, 0x58, 0x4b, 0xac,
	0xe7, 0xb6, 0xee, 0x6d, 0x5c, 0x7a, 0xef, 0x8d, 0x76, 0xfc, 0x74, 0xa0, 0x54, 0x6b, 0xd9, 0x97,
	0x6f, 0x56, 0xa7, 0x7e, 0xfa, 0xfb, 0x97, 0x07, 0x09, 0xcb, 0x58, 0xa3, 0x27, 0x30, 0x27, 0x82,
	0x5e, 0xaf, 0xdb, 0xb7, 0x45, 0xc8, 0x2d, 0x26, 0x15, 0xad, 0x34, 0x86, 0xd6, 0x52, 0x6a, 0xea,
	0xd7, 0x6b, 0xd3, 0x21, 0xc8, 0xca, 0x89, 0x81, 0x08, 0xed, 0x40, 0xce, 0xe9, 0x76, 0x39, 0x76,
	0x24, 0xe5, 0x4c, 0x14, 0x53, 0x6b, 0xa9, 0xf5, 0xdc, 0xd6, 0x47, 0x63, 0x38, 0xc6, 0x8d, 0x6a,
	0xac, 0x1c, 0xd1, 0x86, 0xcc, 0xd1, 0x63, 0x98, 0x3b, 0x09, 0x7c, 0x66, 0xfb, 0x04, 0x73, 0xdf,
	0x15, 0xc5, 0x69, 0x85, 0x5b, 0x19, 0x83, 0xab, 0x05, 0x3e, 0xb3, 0x94, 0x56, 0xc4, 0x39, 0x89,
	0x25, 0x02, 0x59, 0x50, 0x20, 0x1e, 0x15, 0x82, 0xf2, 0x01, 0x6b, 0x46, 0xb1, 0xee, 0x8e, 0x61,
	0x35, 0x8c, 0xea, 0x08, 0x6f, 0x81, 0x8c, 0x48, 0x05, 0xda, 0x85, 0xbc, 0xf4, 0x89, 0x23, 0x02,
	0x3f, 0x0a, 0x5a, 0x5a, 0x05, 0x6d, 0x6d, 0x5c, 0x0a, 0x8c, 0xe2, 0x70, 0xd8, 0xe6, 0xe5, 0xb0,
	0x30, 0x74, 0x15, 0x9f, 0x39, 0x94, 0x69, 0x96, 0x28, 0xce, 0x5e, 0xe9, 0x6a, 0x3d, 0x54, 0x1b,
	0x49, 0x00, 0x8e, 0x25, 0xa2, 0xfc, 0x4d, 0x12, 0x72, 0x43, 0x39, 0x42, 0x5f, 0xc3, 0x32, 0x0e,
	0x7c, 0x9f, 0x30, 0x69, 0x4b, 0x2e, 0x9d, 0xae, 0xad, 0xb3, 0xa5, 0xea, 0x25, 0x5b, 0x7b, 0x18,
	0x02, 0xfe, 0x7c, 0xb3, 0x7a, 0x43, 0xd7, 0xae, 0x70, 0xcf, 0x37, 0x28, 0xaf, 0x78, 0x8e, 0x3c,
	0xdb, 0x68, 0x32, 0xf9, 0xfa, 0xc5, 0x23, 0x30, 0x45, 0xdd, 0x64, 0xd2, 0x42, 0x06, 0xd4, 0x0e,
	0x39, 0xfa, 0x37, 0xd0, 0x1e, 0xcc, 0x69, 0xac, 0x47, 0x99, 0x24, 0xae, 0x2a, 0x9c, 0x6b, 0x62,
	0x73, 0x0a, 0xb0, 0xab, 0xec, 0x07, 0xbc, 0x30, 0x7d, 0xc4, 0x2d, 0xa6, 0x26, 0xe5, 0xd5, 0x94,
	0x7d, 0xf9, 0xc7, 0x04, 0x2c, 0x1c, 0x11, 0x21, 0x29, 0xeb, 0xb4, 0xf0, 0x19, 0x71, 0x83, 0x2e,
	0x41, 0xf7, 0x21, 0x8f, 0xbb, 0xf4, 0xf4, 0xd4, 0x76, 0x03, 0x5f, 0x15, 0x9a, 0x0a, 0xc6, 0xb4,
	0x35, 0xaf, 0xa4, 0xdb, 0x46, 0x88, 0x3e, 0x81, 0xc2, 0x85, 0xb6, 0x1c, 0x28, 0x26, 0x95, 0xe2,
	0x82, 0x91, 0xc7, 0xaa, 0x2b, 0x00, 0x42, 0x3a, 0xbe, 0xb4, 0x25, 0xf5, 0x88, 0x7a, 0xe7, 0x94,
	0x95, 0x55, 0x92, 0x36, 0xf5, 0x08, 0xba, 0x07, 0xf3, 0x54, 0xd8, 0x98, 0x33, 0x49, 0x59, 0xc0,
	0x83, 0xb0, 0x8e, 0x13, 0xeb, 0x19, 0x6b, 0x8e, 0x8a, 0x7a, 0x2c, 0x2b, 0xff, 0x96, 0x82, 0xc5,
	0x4b, 0x4d, 0x81, 0xb6, 0x60, 0xd6, 0x71, 0x5d, 0x9f, 0x08, 0x61, 0x32, 0x56, 0x7c, 0xfd, 0xe2,
	0xd1, 0xb2, 0xf1, 0xb6, 0xaa, 0x4f, 0x5a, 0xd2, 0xa7, 0xac, 0x63, 0x45, 0x8a, 0xa8, 0x0e, 0x69,
	0xc7, 0xe3, 0x01, 0x93, 0x93, 0x64, 0xc3, 0x98, 0xa2, 0x2a, 0x64, 0xb0, 0x23, 0x49, 0x87, 0xfb,
	0x7d, 0xe5, 0x50, 0x7e, 0xeb, 0xfe, 0x98, 0x5a, 0x1c, 0xbc, 0x69, 0xdd, 0x28, 0x5b, 0xb1, 0x19,
	0xda, 0x1d, 0x04, 0x50, 0x98, 0xd8, 0x2b, 0xcf, 0x73, 0x5b, 0xe5, 0x31, 0xa8, 0xf7, 0xb2, 0x14,
	0x07, 0x39, 0x4e, 0xdb, 0x1a, 0xe4, 0x5c, 0x22, 0xb0, 0x4f, 0x7b, 0x2a, 0x15, 0x33, 0xa1, 0x6f,
	0xd6, 0xb0, 0x08, 0xdd, 0x86, 0x2c, 0x15, 0x76, 0x68, 0x47, 0x5c, 0xd5, 0x8d, 0x19, 0x2b, 0x43,
	0xc5, 0x91, 0x7a, 0x46, 0x04, 0x6e, 0xf4, 0x88, 0x8f, 0x09, 0x93, 0x4e, 0x87, 0xd8, 0xfc, 0xd4,
	0x36, 0x03, 0xbf, 0x38, 0xab, 0x82, 0xb4, 0x69, 0x82, 0x74, 0xfb, 0x72, 0x90, 0x76, 0x48, 0xc7,
	0xc1, 0xfd, 0x6d, 0x82, 0x87, 0x42, 0xb5, 0x4d, 0xb0, 0xb5, 0x34, 0xe0, 0xed, 0x9f, 0x9a, 0xd4,
	0x95, 0xff, 0x49, 0x41, 0x7e, 0x74, 0x80, 0xa0, 0x55, 0xc8, 0xc5, 0xd3, 0x87, 0xba, 0xa6, 0xd8,
	0x20, 0x12, 0x35, 0x5d, 0x74, 0x17, 0xe6, 0x4e, 0xba, 0x1c, 0x9f, 0xdb, 0x67, 0x84, 0x76, 0xce,
	0x74, 0xda, 0x52, 0x56, 0x4e, 0xc9, 0x3e, 0x57, 0x22, 0x74, 0x00, 0xf3, 0xba, 0x2f, 0x88, 0x47,
	0xa5, 0x9c, 0xac, 0x31, 0x74, 0x67, 0x35, 0x34, 0x00, 0x7d, 0x01, 0x20, 0x79, 0x38, 0x6d, 0xce,
	0x29, 0xeb, 0xa8, 0xbc, 0x5c, 0x13, 0x97, 0x95, 0xbc, 0xa5, 0xad, 0x51, 0x0d, 0xd2, 0x92, 0xdb,
	0x3d, 0x8e, 0x75, 0x56, 0xae, 0xc7, 0x99, 0x91, 0xfc, 0x80, 0x63, 0xdd, 0xf9, 0xb6, 0x20, 0x4f,
	0x03, 0xc2, 0x30, 0xf1, 0x55, 0xfe, 0xae, 0xdf, 0xf9, 0xad, 0xc8, 0x3e, 0xdc, 0x44, 0x92, 0xdb,
	0xd1, 0x90, 0x35, 0x59, 0xbe, 0x16, 0x0e, 0x24, 0x8f, 0x06, 0x37, 0xba, 0x03, 0xd9, 0xb0, 0xb7,
	0x85, 0x74, 0xbc, 0x5e, 0x31, 0xa3, 0x1b, 0x3c, 0x16, 0x94, 0x7f, 0x4e, 0xc1, 0xfc, 0xc8, 0x8c,
	0x47, 0x75, 0x28, 0xc4, 0xdb, 0xe1, 0xbf, 0x36, 0xf0, 0x42, 0x64, 0x61, 0xc4, 0xa8, 0x0d, 0x0b,
	0x94, 0x51, 0x49, 0xc3, 0x71, 0xe8, 0x74, 0x1d, 0x86, 0xc9, 0x24, 0x1d, 0x9d, 0x37, 0x8c, 0x9a,
	0x46, 0x0c, 0x4a, 0x89, 0xb2, 0xd3, 0x2e, 0x7f, 0x26, 0x26, 0x2f, 0xa5, 0xa6, 0x06, 0x20, 0x0b,
	0xf2, 0xa7, 0x3e, 0xf7, 0x14, 0x50, 0xcf, 0xc9, 0x09, 0xca, 0x69, 0x3e, 0x44, 0x34, 0x23, 0x02,
	0x3a, 0x06, 0xa4, 0x98, 0x66, 0xff, 0xbb, 0xd4, 0x27, 0x58, 0x4e, 0x52, 0x5e, 0x85, 0x10, 0xa3,
	0xaf, 0x07, 0x1a, 0x52, 0xfe, 0x35, 0x09, 0x30, 0x58, 0xa2, 0xe8, 0x26, 0x64, 0xf4, 0xe6, 0x35,
	0xbd, 0x99, 0xb5, 0x66, 0xd5, 0x73, 0xf3, 0xf2, 0x36, 0x4a, 0xfe, 0xbf, 0x6d, 0x14, 0x3a, 0xa5,
	0x79, 0x3e, 0x79, 0xe6, 0xf8, 0xae, 0xb0, 0x05, 0x61, 0x72, 0x92, 0xf8, 0x17, 0x14, 0xc6, 0xd2,
	0x94, 0x16, 0x61, 0x32, 0x1c, 0x32, 0xf4, 0x04, 0xdb, 0xf8, 0xcc, 0x61, 0x8c, 0x74, 0x75, 0x02,
	0x2c, 0xa0, 0x27, 0xb8, 0xae, 0x25, 0x66, 0x38, 0x3a, 0x58, 0xd2, 0x0b, 0xa2, 0xe2, 0xa8, 0x86,
	0x63, 0x55, 0x3d, 0xa3, 0x75, 0x28, 0x74, 0x1d, 0x21, 0x6d, 0xd1, 0x67, 0x38, 0x9a, 0x42, 0x69,
	0x55, 0xe5, 0xf9, 0x50, 0xde, 0xea, 0x33, 0xac, 0x07, 0x51, 0xf9, 0xfb, 0x14, 0x2c, 0x6d, 0x93,
	0x53, 0x27, 0xe8, 0xca, 0x91, 0x9b, 0x68, 0x05, 0x96, 0x06, 0x05, 0x1f, 0x6f, 0x05, 0x13, 0x50,
	0x14, 0x57, 0xf6, 0x60, 0xb3, 0x6d, 0xc2, 0xf2, 0x85, 0xd3, 0xa5, 0xae, 0x23, 0xb9, 0x3f, 0x6c,
	0xa1, 0x62, 0x6c, 0x2d, 0xc5, 0x67, 0x43, 0x26, 0x1f, 0xc3, 0x82, 0x24, 0x8e, 0x37, 0xac, 0xad,
	0x62, 0x67, 0xe5, 0x43, 0xf1, 0x90, 0x62, 0x05, 0x96, 0x28, 0x0b, 0xf7, 0xc0, 0x28, 0x5a, 0x07,
	0x05, 0x45, 0x47, 0xa3, 0x2f, 0x83, 0xb9, 0xe7, 0x05, 0x8c, 0xca, 0x91, 0xd7, 0xd7, 0x4b, 0x66,
	0x29, 0x3e, 0x1b, 0x35, 0xe9, 0xd2, 0xa7, 0x01, 0x75, 0xdf, 0x33, 0x49, 0x6b, 0x93, 0xf8, 0x6c,
	0xd4, 0x84, 0x60, 0x2e, 0xfa, 0x42, 0x92, 0x11, 0x27, 0x66, 0xb5, 0x49, 0x7c, 0x36, 0x64, 0xf2,
	0x08, 0x90, 0x4f, 0x04, 0xf1, 0x2f, 0xc8, 0xb0, 0x41, 0x46, 0x19, 0x2c, 0x9a, 0x93, 0x81, 0x7a,
	0xf9, 0xbb, 0x64, 0x7c, 0x89, 0x38, 0xd2, 0x01, 0x0c, 0x21, 0x6d, 0x58, 0xd0, 0x65, 0x67, 0x10,
	0xc4, 0x9d, 0xe4, 0xfa, 0x97, 0x57, 0x8c, 0x6a, 0x84, 0x40, 0x18, 0x3e, 0x24, 0xcf, 0x7b, 0x04,
	0x4b, 0xe2, 0x46, 0xbb, 0x34, 0xba, 0x5c, 0x4e, 0xd0, 0x27, 0x37, 0x22, 0x56, 0x54, 0x55, 0xfa,
	0x7e, 0x79, 0x13, 0x32, 0xe1, 0x4a, 0x0f, 0x7d, 0x51, 0xb9, 0xce, 0x58, 0xb3, 0xc6, 0x35, 0xf4,
	0x10, 0x16, 0x2f, 0x62, 0x1f, 0x6d, 0xe2, 0xfb, 0xdc, 0xd7, 0x5f, 0x08, 0x59, 0xab, 0x30, 0x38,
	0x68, 0x28, 0xf9, 0x83, 0xdf, 0x93, 0x80, 0x2e, 0x5f, 0x56, 0xd0, 0x3d, 0x58, 0xad, 0xee, 0xec,
	0xec, 0xd7, 0xab, 0xed, 0xe6, 0xfe, 0x9e, 0x5d, 0xaf, 0xb6, 0x1b, 0x4f, 0xf6, 0xad, 0x63, 0xfb,
	0x70, 0xaf, 0x75, 0xd0, 0xa8, 0x37, 0x1f, 0x37, 0x1b, 0xdb, 0x85, 0x29, 0xb4, 0x06, 0x77, 0xc6,
	0x29, 0xb5, 0xad, 0x46, 0xb5, 0x75, 0x68, 0x1d, 0x17, 0x12, 0xa8, 0x0c, 0xa5, 0x71, 0x1a, 0x47,
	0xd5, 0x9d, 0xe6, 0x76, 0xb5, 0xbd, 0x6f, 0xb5, 0x0a, 0x49, 0x74, 0x07, 0x8a, 0x63, 0x29, 0x8d,
	0xea, 0x6e, 0x21, 0x85, 0xee, 0xc2, 0xca, 0xb8, 0xd3, 0xe6, 0xde, 0x51, 0xa3, 0xa5, 0x00, 0xd3,
	0x57, 0xa9, 0xd4, 0xf7, 0x77, 0x77, 0x0f, 0xf7, 0x9a, 0xed, 0xe3, 0xc2, 0xcc, 0x55, 0x2a, 0x3b,
	0xcd, 0x2f, 0x0f, 0x9b, 0xdb, 0xa1, 0x4a, 0xfa, 0x2a, 0x95, 0x46, 0x7d, 0xbf, 0x75, 0xdc, 0x6a,
	0x37, 0x76, 0x0b, 0xb3, 0x68, 0x15, 0x6e, 0x8f, 0x53, 0xb1, 0x1a, 0xad, 0x86, 0x75, 0xd4, 0x28,
	0x64, 0x6a, 0x9f, 0xbe, 0x7c, 0x5b, 0x4a, 0xbc, 0x7a, 0x5b, 0x4a, 0xfc, 0xf5, 0xb6, 0x94, 0xf8,
	0xf6, 0x5d, 0x69, 0xea, 0xd5, 0xbb, 0xd2, 0xd4, 0x1f, 0xef, 0x4a, 0x53, 0x5f, 0x7d, 0x10, 0x7e,
	0xbf, 0x3e, 0x1f, 0xfe, 0x82, 0x95, 0xfd, 0x1e, 0x11, 0x27, 0x69, 0xf5, 0xfd, 0xfa, 0xd9, 0xbf,
	0x01, 0x00, 0x00, 0xff, 0xff, 0xd0, 0xd9, 0xdf, 0xd7, 0x78, 0x0f, 0x00, 0x00,
}

func (m *GenesisState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GenesisState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GenesisState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ChainStates) > 0 {
		for iNdEx := len(m.ChainStates) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ChainStates[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenesis(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	{
		size, err := m.TreasuryState.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenesis(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	if len(m.EmissionRecords) > 0 {
		for iNdEx := len(m.EmissionRecords) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.EmissionRecords[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenesis(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.BurnRecords) > 0 {
		for iNdEx := len(m.BurnRecords) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.BurnRecords[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenesis(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Allocations) > 0 {
		for iNdEx := len(m.Allocations) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Allocations[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenesis(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	{
		size, err := m.SupplyState.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenesis(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.Params.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenesis(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *SupplyState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SupplyState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SupplyState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.TotalBurned.Size()
		i -= size
		if _, err := m.TotalBurned.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintGenesis(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.TotalMinted.Size()
		i -= size
		if _, err := m.TotalMinted.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintGenesis(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size := m.CurrentTotalSupply.Size()
		i -= size
		if _, err := m.CurrentTotalSupply.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintGenesis(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *VestingSchedule) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VestingSchedule) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VestingSchedule) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IsContinuous {
		i--
		if m.IsContinuous {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.StartTime != 0 {
		i = encodeVarintGenesis(dAtA, i, uint64(m.StartTime))
		i--
		dAtA[i] = 0x18
	}
	if m.VestingDuration != 0 {
		i = encodeVarintGenesis(dAtA, i, uint64(m.VestingDuration))
		i--
		dAtA[i] = 0x10
	}
	if m.CliffDuration != 0 {
		i = encodeVarintGenesis(dAtA, i, uint64(m.CliffDuration))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GenesisAllocation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GenesisAllocation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GenesisAllocation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.PercentageOfGenesis.Size()
		i -= size
		if _, err := m.PercentageOfGenesis.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintGenesis(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	if m.IsVested {
		i--
		if m.IsVested {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintGenesis(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x2a
	}
	if m.VestingSchedule != nil {
		{
			size, err := m.VestingSchedule.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenesis(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Category != 0 {
		i = encodeVarintGenesis(dAtA, i, uint64(m.Category))
		i--
		dAtA[i] = 0x18
	}
	{
		size := m.Amount.Size()
		i -= size
		if _, err := m.Amount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintGenesis(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintGenesis(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EmissionRecord) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EmissionRecord) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EmissionRecord) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Timestamp != 0 {
		i = encodeVarintGenesis(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x40
	}
	{
		size := m.ToTreasury.Size()
		i -= size
		if _, err := m.ToTreasury.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintGenesis(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	{
		size := m.ToSequencer.Size()
		i -= size
		if _, err := m.ToSequencer.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintGenesis(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	{
		size := m.ToPoc.Size()
		i -= size
		if _, err := m.ToPoc.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintGenesis(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size := m.ToStaking.Size()
		i -= size
		if _, err := m.ToStaking.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintGenesis(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size := m.TotalEmitted.Size()
		i -= size
		if _, err := m.TotalEmitted.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintGenesis(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.BlockHeight != 0 {
		i = encodeVarintGenesis(dAtA, i, uint64(m.BlockHeight))
		i--
		dAtA[i] = 0x10
	}
	if m.EmissionId != 0 {
		i = encodeVarintGenesis(dAtA, i, uint64(m.EmissionId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TreasuryState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TreasuryState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TreasuryState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.FromBurnRedirect.Size()
		i -= size
		if _, err := m.FromBurnRedirect.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintGenesis(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size := m.FromInflation.Size()
		i -= size
		if _, err := m.FromInflation.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintGenesis(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size := m.TotalInflows.Size()
		i -= size
		if _, err := m.TotalInflows.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintGenesis(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.InitialBalance.Size()
		i -= size
		if _, err := m.InitialBalance.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintGenesis(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.TreasuryAddress) > 0 {
		i -= len(m.TreasuryAddress)
		copy(dAtA[i:], m.TreasuryAddress)
		i = encodeVarintGenesis(dAtA, i, uint64(len(m.TreasuryAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ChainState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChainState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ChainState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LastSyncHeight != 0 {
		i = encodeVarintGenesis(dAtA, i, uint64(m.LastSyncHeight))
		i--
		dAtA[i] = 0x30
	}
	if m.IsActive {
		i--
		if m.IsActive {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if len(m.IbcChannel) > 0 {
		i -= len(m.IbcChannel)
		copy(dAtA[i:], m.IbcChannel)
		i = encodeVarintGenesis(dAtA, i, uint64(len(m.IbcChannel)))
		i--
		dAtA[i] = 0x22
	}
	{
		size := m.TotalRewardsSent.Size()
		i -= size
		if _, err := m.TotalRewardsSent.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintGenesis(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.TotalBurned.Size()
		i -= size
		if _, err := m.TotalBurned.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintGenesis(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.ChainId) > 0 {
		i -= len(m.ChainId)
		copy(dAtA[i:], m.ChainId)
		i = encodeVarintGenesis(dAtA, i, uint64(len(m.ChainId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DefaultGenesisState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DefaultGenesisState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DefaultGenesisState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ReserveAllocation) > 0 {
		i -= len(m.ReserveAllocation)
		copy(dAtA[i:], m.ReserveAllocation)
		i = encodeVarintGenesis(dAtA, i, uint64(len(m.ReserveAllocation)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.EcosystemAllocation) > 0 {
		i -= len(m.EcosystemAllocation)
		copy(dAtA[i:], m.EcosystemAllocation)
		i = encodeVarintGenesis(dAtA, i, uint64(len(m.EcosystemAllocation)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.LiquidityAllocation) > 0 {
		i -= len(m.LiquidityAllocation)
		copy(dAtA[i:], m.LiquidityAllocation)
		i = encodeVarintGenesis(dAtA, i, uint64(len(m.LiquidityAllocation)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.CommunityAllocation) > 0 {
		i -= len(m.CommunityAllocation)
		copy(dAtA[i:], m.CommunityAllocation)
		i = encodeVarintGenesis(dAtA, i, uint64(len(m.CommunityAllocation)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.InvestorAllocation) > 0 {
		i -= len(m.InvestorAllocation)
		copy(dAtA[i:], m.InvestorAllocation)
		i = encodeVarintGenesis(dAtA, i, uint64(len(m.InvestorAllocation)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.TeamAllocation) > 0 {
		i -= len(m.TeamAllocation)
		copy(dAtA[i:], m.TeamAllocation)
		i = encodeVarintGenesis(dAtA, i, uint64(len(m.TeamAllocation)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ValidatorAllocation) > 0 {
		i -= len(m.ValidatorAllocation)
		copy(dAtA[i:], m.ValidatorAllocation)
		i = encodeVarintGenesis(dAtA, i, uint64(len(m.ValidatorAllocation)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.TreasuryAllocation) > 0 {
		i -= len(m.TreasuryAllocation)
		copy(dAtA[i:], m.TreasuryAllocation)
		i = encodeVarintGenesis(dAtA, i, uint64(len(m.TreasuryAllocation)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GenesisValidation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GenesisValidation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GenesisValidation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ValidationErrors) > 0 {
		for iNdEx := len(m.ValidationErrors) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ValidationErrors[iNdEx])
			copy(dAtA[i:], m.ValidationErrors[iNdEx])
			i = encodeVarintGenesis(dAtA, i, uint64(len(m.ValidationErrors[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if m.IsValid {
		i--
		if m.IsValid {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	{
		size := m.ExpectedGenesisSupply.Size()
		i -= size
		if _, err := m.ExpectedGenesisSupply.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintGenesis(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size := m.TotalAllocated.Size()
		i -= size
		if _, err := m.TotalAllocated.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintGenesis(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func encodeVarintGenesis(dAtA []byte, offset int, v uint64) int {
	offset -= sovGenesis(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *GenesisState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Params.Size()
	n += 1 + l + sovGenesis(uint64(l))
	l = m.SupplyState.Size()
	n += 1 + l + sovGenesis(uint64(l))
	if len(m.Allocations) > 0 {
		for _, e := range m.Allocations {
			l = e.Size()
			n += 1 + l + sovGenesis(uint64(l))
		}
	}
	if len(m.BurnRecords) > 0 {
		for _, e := range m.BurnRecords {
			l = e.Size()
			n += 1 + l + sovGenesis(uint64(l))
		}
	}
	if len(m.EmissionRecords) > 0 {
		for _, e := range m.EmissionRecords {
			l = e.Size()
			n += 1 + l + sovGenesis(uint64(l))
		}
	}
	l = m.TreasuryState.Size()
	n += 1 + l + sovGenesis(uint64(l))
	if len(m.ChainStates) > 0 {
		for _, e := range m.ChainStates {
			l = e.Size()
			n += 1 + l + sovGenesis(uint64(l))
		}
	}
	return n
}

func (m *SupplyState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.CurrentTotalSupply.Size()
	n += 1 + l + sovGenesis(uint64(l))
	l = m.TotalMinted.Size()
	n += 1 + l + sovGenesis(uint64(l))
	l = m.TotalBurned.Size()
	n += 1 + l + sovGenesis(uint64(l))
	return n
}

func (m *VestingSchedule) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CliffDuration != 0 {
		n += 1 + sovGenesis(uint64(m.CliffDuration))
	}
	if m.VestingDuration != 0 {
		n += 1 + sovGenesis(uint64(m.VestingDuration))
	}
	if m.StartTime != 0 {
		n += 1 + sovGenesis(uint64(m.StartTime))
	}
	if m.IsContinuous {
		n += 2
	}
	return n
}

func (m *GenesisAllocation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovGenesis(uint64(l))
	}
	l = m.Amount.Size()
	n += 1 + l + sovGenesis(uint64(l))
	if m.Category != 0 {
		n += 1 + sovGenesis(uint64(m.Category))
	}
	if m.VestingSchedule != nil {
		l = m.VestingSchedule.Size()
		n += 1 + l + sovGenesis(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovGenesis(uint64(l))
	}
	if m.IsVested {
		n += 2
	}
	l = m.PercentageOfGenesis.Size()
	n += 1 + l + sovGenesis(uint64(l))
	return n
}

func (m *EmissionRecord) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EmissionId != 0 {
		n += 1 + sovGenesis(uint64(m.EmissionId))
	}
	if m.BlockHeight != 0 {
		n += 1 + sovGenesis(uint64(m.BlockHeight))
	}
	l = m.TotalEmitted.Size()
	n += 1 + l + sovGenesis(uint64(l))
	l = m.ToStaking.Size()
	n += 1 + l + sovGenesis(uint64(l))
	l = m.ToPoc.Size()
	n += 1 + l + sovGenesis(uint64(l))
	l = m.ToSequencer.Size()
	n += 1 + l + sovGenesis(uint64(l))
	l = m.ToTreasury.Size()
	n += 1 + l + sovGenesis(uint64(l))
	if m.Timestamp != 0 {
		n += 1 + sovGenesis(uint64(m.Timestamp))
	}
	return n
}

func (m *TreasuryState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TreasuryAddress)
	if l > 0 {
		n += 1 + l + sovGenesis(uint64(l))
	}
	l = m.InitialBalance.Size()
	n += 1 + l + sovGenesis(uint64(l))
	l = m.TotalInflows.Size()
	n += 1 + l + sovGenesis(uint64(l))
	l = m.FromInflation.Size()
	n += 1 + l + sovGenesis(uint64(l))
	l = m.FromBurnRedirect.Size()
	n += 1 + l + sovGenesis(uint64(l))
	return n
}

func (m *ChainState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ChainId)
	if l > 0 {
		n += 1 + l + sovGenesis(uint64(l))
	}
	l = m.TotalBurned.Size()
	n += 1 + l + sovGenesis(uint64(l))
	l = m.TotalRewardsSent.Size()
	n += 1 + l + sovGenesis(uint64(l))
	l = len(m.IbcChannel)
	if l > 0 {
		n += 1 + l + sovGenesis(uint64(l))
	}
	if m.IsActive {
		n += 2
	}
	if m.LastSyncHeight != 0 {
		n += 1 + sovGenesis(uint64(m.LastSyncHeight))
	}
	return n
}

func (m *DefaultGenesisState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TreasuryAllocation)
	if l > 0 {
		n += 1 + l + sovGenesis(uint64(l))
	}
	l = len(m.ValidatorAllocation)
	if l > 0 {
		n += 1 + l + sovGenesis(uint64(l))
	}
	l = len(m.TeamAllocation)
	if l > 0 {
		n += 1 + l + sovGenesis(uint64(l))
	}
	l = len(m.InvestorAllocation)
	if l > 0 {
		n += 1 + l + sovGenesis(uint64(l))
	}
	l = len(m.CommunityAllocation)
	if l > 0 {
		n += 1 + l + sovGenesis(uint64(l))
	}
	l = len(m.LiquidityAllocation)
	if l > 0 {
		n += 1 + l + sovGenesis(uint64(l))
	}
	l = len(m.EcosystemAllocation)
	if l > 0 {
		n += 1 + l + sovGenesis(uint64(l))
	}
	l = len(m.ReserveAllocation)
	if l > 0 {
		n += 1 + l + sovGenesis(uint64(l))
	}
	return n
}

func (m *GenesisValidation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.TotalAllocated.Size()
	n += 1 + l + sovGenesis(uint64(l))
	l = m.ExpectedGenesisSupply.Size()
	n += 1 + l + sovGenesis(uint64(l))
	if m.IsValid {
		n += 2
	}
	if len(m.ValidationErrors) > 0 {
		for _, s := range m.ValidationErrors {
			l = len(s)
			n += 1 + l + sovGenesis(uint64(l))
		}
	}
	return n
}

func sovGenesis(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozGenesis(x uint64) (n int) {
	return sovGenesis(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *GenesisState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenesis
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GenesisState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GenesisState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SupplyState", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SupplyState.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Allocations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Allocations = append(m.Allocations, GenesisAllocation{})
			if err := m.Allocations[len(m.Allocations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BurnRecords", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BurnRecords = append(m.BurnRecords, BurnRecord{})
			if err := m.BurnRecords[len(m.BurnRecords)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EmissionRecords", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EmissionRecords = append(m.EmissionRecords, EmissionRecord{})
			if err := m.EmissionRecords[len(m.EmissionRecords)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TreasuryState", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TreasuryState.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainStates", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChainStates = append(m.ChainStates, ChainState{})
			if err := m.ChainStates[len(m.ChainStates)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenesis(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenesis
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SupplyState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenesis
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SupplyState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SupplyState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentTotalSupply", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CurrentTotalSupply.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalMinted", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalMinted.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalBurned", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalBurned.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenesis(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenesis
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VestingSchedule) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenesis
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VestingSchedule: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VestingSchedule: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CliffDuration", wireType)
			}
			m.CliffDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CliffDuration |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VestingDuration", wireType)
			}
			m.VestingDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VestingDuration |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			m.StartTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsContinuous", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsContinuous = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipGenesis(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenesis
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GenesisAllocation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenesis
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GenesisAllocation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GenesisAllocation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Category", wireType)
			}
			m.Category = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Category |= AllocationCategory(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VestingSchedule", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VestingSchedule == nil {
				m.VestingSchedule = &VestingSchedule{}
			}
			if err := m.VestingSchedule.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsVested", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsVested = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PercentageOfGenesis", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PercentageOfGenesis.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenesis(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenesis
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EmissionRecord) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenesis
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EmissionRecord: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EmissionRecord: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EmissionId", wireType)
			}
			m.EmissionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EmissionId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockHeight", wireType)
			}
			m.BlockHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalEmitted", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalEmitted.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToStaking", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ToStaking.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToPoc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ToPoc.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToSequencer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ToSequencer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToTreasury", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ToTreasury.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGenesis(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenesis
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TreasuryState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenesis
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TreasuryState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TreasuryState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TreasuryAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TreasuryAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitialBalance", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.InitialBalance.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalInflows", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalInflows.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromInflation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.FromInflation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromBurnRedirect", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.FromBurnRedirect.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenesis(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenesis
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChainState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenesis
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChainState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChainState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChainId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalBurned", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalBurned.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalRewardsSent", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalRewardsSent.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IbcChannel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IbcChannel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsActive", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsActive = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastSyncHeight", wireType)
			}
			m.LastSyncHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastSyncHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGenesis(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenesis
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DefaultGenesisState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenesis
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DefaultGenesisState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DefaultGenesisState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TreasuryAllocation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TreasuryAllocation = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidatorAllocation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValidatorAllocation = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TeamAllocation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TeamAllocation = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvestorAllocation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InvestorAllocation = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommunityAllocation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CommunityAllocation = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LiquidityAllocation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LiquidityAllocation = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EcosystemAllocation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EcosystemAllocation = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReserveAllocation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReserveAllocation = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenesis(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenesis
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GenesisValidation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenesis
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GenesisValidation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GenesisValidation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalAllocated", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalAllocated.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpectedGenesisSupply", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ExpectedGenesisSupply.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsValid", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsValid = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidationErrors", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValidationErrors = append(m.ValidationErrors, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenesis(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenesis
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipGenesis(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowGenesis
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthGenesis
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupGenesis
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthGenesis
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthGenesis        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowGenesis          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupGenesis = fmt.Errorf("proto: unexpected end of group")
)
