// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: pos/tokenomics/v1/params.proto

package types

import (
	cosmossdk_io_math "cosmossdk.io/math"
	fmt "fmt"
	_ "github.com/cosmos/cosmos-proto"
	_ "github.com/cosmos/cosmos-sdk/types/tx/amino"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// TokenomicsParams defines the DAO-controlled monetary policy parameters
// for the Omniphi tri-chain token economy
type TokenomicsParams struct {
	// total_supply_cap is the hard maximum supply (1.5B OMNI)
	// This is IMMUTABLE and enforced at protocol level
	TotalSupplyCap cosmossdk_io_math.Int `protobuf:"bytes,1,opt,name=total_supply_cap,json=totalSupplyCap,proto3,customtype=cosmossdk.io/math.Int" json:"total_supply_cap"`
	// current_total_supply tracks minted - burned across all chains
	CurrentTotalSupply cosmossdk_io_math.Int `protobuf:"bytes,2,opt,name=current_total_supply,json=currentTotalSupply,proto3,customtype=cosmossdk.io/math.Int" json:"current_total_supply"`
	// total_minted tracks cumulative minting (monotonic increase)
	TotalMinted cosmossdk_io_math.Int `protobuf:"bytes,3,opt,name=total_minted,json=totalMinted,proto3,customtype=cosmossdk.io/math.Int" json:"total_minted"`
	// total_burned tracks cumulative burns across all chains
	TotalBurned cosmossdk_io_math.Int `protobuf:"bytes,4,opt,name=total_burned,json=totalBurned,proto3,customtype=cosmossdk.io/math.Int" json:"total_burned"`
	// inflation_rate is the annual inflation percentage (0.01-0.05)
	// DAO can adjust between min and max
	InflationRate cosmossdk_io_math.LegacyDec `protobuf:"bytes,5,opt,name=inflation_rate,json=inflationRate,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"inflation_rate"`
	// inflation_min is the DAO-settable floor (default 1%)
	InflationMin cosmossdk_io_math.LegacyDec `protobuf:"bytes,6,opt,name=inflation_min,json=inflationMin,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"inflation_min"`
	// inflation_max is the PROTOCOL-ENFORCED ceiling (max 5%)
	// DAO proposals cannot exceed this
	InflationMax cosmossdk_io_math.LegacyDec `protobuf:"bytes,7,opt,name=inflation_max,json=inflationMax,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"inflation_max"`
	// emission_split_staking: % of inflation to PoS validators
	EmissionSplitStaking cosmossdk_io_math.LegacyDec `protobuf:"bytes,8,opt,name=emission_split_staking,json=emissionSplitStaking,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"emission_split_staking"`
	// emission_split_poc: % of inflation to PoC contributors
	EmissionSplitPoc cosmossdk_io_math.LegacyDec `protobuf:"bytes,9,opt,name=emission_split_poc,json=emissionSplitPoc,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"emission_split_poc"`
	// emission_split_sequencer: % of inflation to PoSeq operators
	EmissionSplitSequencer cosmossdk_io_math.LegacyDec `protobuf:"bytes,10,opt,name=emission_split_sequencer,json=emissionSplitSequencer,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"emission_split_sequencer"`
	// emission_split_treasury: % of inflation to DAO treasury
	EmissionSplitTreasury cosmossdk_io_math.LegacyDec `protobuf:"bytes,11,opt,name=emission_split_treasury,json=emissionSplitTreasury,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"emission_split_treasury"`
	// burn_rate_pos_gas: % of PoS gas fees burned (0-50%)
	BurnRatePosGas cosmossdk_io_math.LegacyDec `protobuf:"bytes,12,opt,name=burn_rate_pos_gas,json=burnRatePosGas,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"burn_rate_pos_gas"`
	// burn_rate_poc_anchoring: % of PoC anchoring fees burned (0-50%)
	BurnRatePocAnchoring cosmossdk_io_math.LegacyDec `protobuf:"bytes,13,opt,name=burn_rate_poc_anchoring,json=burnRatePocAnchoring,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"burn_rate_poc_anchoring"`
	// burn_rate_sequencer_gas: % of PoSeq gas fees burned (0-50%)
	BurnRateSequencerGas cosmossdk_io_math.LegacyDec `protobuf:"bytes,14,opt,name=burn_rate_sequencer_gas,json=burnRateSequencerGas,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"burn_rate_sequencer_gas"`
	// burn_rate_smart_contracts: % of smart contract fees burned (0-50%)
	BurnRateSmartContracts cosmossdk_io_math.LegacyDec `protobuf:"bytes,15,opt,name=burn_rate_smart_contracts,json=burnRateSmartContracts,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"burn_rate_smart_contracts"`
	// burn_rate_ai_queries: % of AI query fees burned (0-50%)
	BurnRateAiQueries cosmossdk_io_math.LegacyDec `protobuf:"bytes,16,opt,name=burn_rate_ai_queries,json=burnRateAiQueries,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"burn_rate_ai_queries"`
	// burn_rate_messaging: % of messaging fees burned (0-50%)
	BurnRateMessaging cosmossdk_io_math.LegacyDec `protobuf:"bytes,17,opt,name=burn_rate_messaging,json=burnRateMessaging,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"burn_rate_messaging"`
	// treasury_burn_redirect: % of burns redirected to treasury (0-20%)
	// Example: If 100 OMNI burned, 10 OMNI goes to treasury instead
	TreasuryBurnRedirect cosmossdk_io_math.LegacyDec `protobuf:"bytes,18,opt,name=treasury_burn_redirect,json=treasuryBurnRedirect,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"treasury_burn_redirect"`
	// fee_burn_enabled: Enable automatic fee burning (DAO toggle)
	FeeBurnEnabled bool `protobuf:"varint,31,opt,name=fee_burn_enabled,json=feeBurnEnabled,proto3" json:"fee_burn_enabled,omitempty"`
	// fee_burn_ratio: % of transaction fees to burn (default 0.90 = 90%)
	// DAO-adjustable, must sum with treasury_fee_ratio to 1.0
	FeeBurnRatio cosmossdk_io_math.LegacyDec `protobuf:"bytes,32,opt,name=fee_burn_ratio,json=feeBurnRatio,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"fee_burn_ratio"`
	// treasury_fee_ratio: % of transaction fees to treasury (default 0.10 = 10%)
	// DAO-adjustable, must sum with fee_burn_ratio to 1.0
	TreasuryFeeRatio cosmossdk_io_math.LegacyDec `protobuf:"bytes,33,opt,name=treasury_fee_ratio,json=treasuryFeeRatio,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"treasury_fee_ratio"`
	// min_gas_price: Minimum gas price for transaction acceptance
	// Prevents free transactions and spam attacks
	MinGasPrice cosmossdk_io_math.LegacyDec `protobuf:"bytes,19,opt,name=min_gas_price,json=minGasPrice,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"min_gas_price"`
	// gas_conversion_ratio_continuity: Continuity gas vs Core gas
	// Example: 0.5 = Continuity ops cost 50% of Core ops
	GasConversionRatioContinuity cosmossdk_io_math.LegacyDec `protobuf:"bytes,20,opt,name=gas_conversion_ratio_continuity,json=gasConversionRatioContinuity,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"gas_conversion_ratio_continuity"`
	// gas_conversion_ratio_sequencer: Sequencer gas vs Core gas
	// Example: 0.1 = Sequencer ops cost 10% of Core ops (micro-fees)
	GasConversionRatioSequencer cosmossdk_io_math.LegacyDec `protobuf:"bytes,21,opt,name=gas_conversion_ratio_sequencer,json=gasConversionRatioSequencer,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"gas_conversion_ratio_sequencer"`
	// poc_alpha: Weight factor for credit impact on effective power
	// Formula: Power = Stake × (1 + α × Credits)
	// Range: [0, 1.0] - bounded to prevent runaway credit multiplier
	PocAlpha cosmossdk_io_math.LegacyDec `protobuf:"bytes,22,opt,name=poc_alpha,json=pocAlpha,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"poc_alpha"`
	// reward_stream_interval: How often to send IBC rewards (blocks)
	RewardStreamInterval uint64 `protobuf:"varint,23,opt,name=reward_stream_interval,json=rewardStreamInterval,proto3" json:"reward_stream_interval,omitempty"`
	// continuity_ibc_channel: IBC channel to PoC Continuity
	ContinuityIbcChannel string `protobuf:"bytes,24,opt,name=continuity_ibc_channel,json=continuityIbcChannel,proto3" json:"continuity_ibc_channel,omitempty"`
	// sequencer_ibc_channel: IBC channel to PoSeq Sequencer
	SequencerIbcChannel string `protobuf:"bytes,25,opt,name=sequencer_ibc_channel,json=sequencerIbcChannel,proto3" json:"sequencer_ibc_channel,omitempty"`
	// param_change_delay: Minimum delay before param changes take effect (seconds)
	ParamChangeDelay uint64 `protobuf:"varint,26,opt,name=param_change_delay,json=paramChangeDelay,proto3" json:"param_change_delay,omitempty"`
	// min_proposal_deposit: Minimum OMNI deposit for proposals
	MinProposalDeposit cosmossdk_io_math.Int `protobuf:"bytes,27,opt,name=min_proposal_deposit,json=minProposalDeposit,proto3,customtype=cosmossdk.io/math.Int" json:"min_proposal_deposit"`
	// quorum_percentage: Minimum % of voting power to pass proposal
	QuorumPercentage cosmossdk_io_math.LegacyDec `protobuf:"bytes,28,opt,name=quorum_percentage,json=quorumPercentage,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"quorum_percentage"`
	// pass_percentage: Minimum % yes votes to pass
	PassPercentage cosmossdk_io_math.LegacyDec `protobuf:"bytes,29,opt,name=pass_percentage,json=passPercentage,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"pass_percentage"`
	// voting_period: Duration of voting period (seconds)
	VotingPeriod uint64 `protobuf:"varint,30,opt,name=voting_period,json=votingPeriod,proto3" json:"voting_period,omitempty"`
	// adaptive_burn_enabled: Enable dynamic burn rate adjustments
	// When true, burn ratio adjusts based on network conditions
	// When false, uses fixed fee_burn_ratio
	AdaptiveBurnEnabled bool `protobuf:"varint,34,opt,name=adaptive_burn_enabled,json=adaptiveBurnEnabled,proto3" json:"adaptive_burn_enabled,omitempty"`
	// min_burn_ratio: Minimum adaptive burn rate (default 0.80 = 80%)
	// Floor to ensure some deflationary pressure
	// Protocol bounds: 0.70 - 1.00
	MinBurnRatio cosmossdk_io_math.LegacyDec `protobuf:"bytes,35,opt,name=min_burn_ratio,json=minBurnRatio,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"min_burn_ratio"`
	// max_burn_ratio: Maximum adaptive burn rate (default 0.95 = 95%)
	// Ceiling to reserve some fees for validators/treasury
	// Protocol bounds: 0.70 - 0.95
	MaxBurnRatio cosmossdk_io_math.LegacyDec `protobuf:"bytes,36,opt,name=max_burn_ratio,json=maxBurnRatio,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"max_burn_ratio"`
	// default_burn_ratio: Baseline burn rate when no triggers active (default 0.90 = 90%)
	// Used when network conditions are normal
	DefaultBurnRatio cosmossdk_io_math.LegacyDec `protobuf:"bytes,37,opt,name=default_burn_ratio,json=defaultBurnRatio,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"default_burn_ratio"`
	// block_congestion_threshold: Gas usage % that triggers max burn (default 0.75 = 75%)
	// If block gas used > threshold → increase burn to max_burn_ratio
	// Range: 0.50 - 1.00
	BlockCongestionThreshold cosmossdk_io_math.LegacyDec `protobuf:"bytes,38,opt,name=block_congestion_threshold,json=blockCongestionThreshold,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"block_congestion_threshold"`
	// tx_per_day_target: Expected daily transaction volume (default 10,000)
	// If avg tx/day < target → reduce burn to encourage adoption
	// Smoothed over 7-day rolling window
	TxPerDayTarget uint64 `protobuf:"varint,39,opt,name=tx_per_day_target,json=txPerDayTarget,proto3" json:"tx_per_day_target,omitempty"`
	// treasury_floor_pct: Minimum treasury balance as % of total supply (default 0.05 = 5%)
	// If treasury < floor → reduce burn to min_burn_ratio
	// Ensures treasury solvency for operations
	TreasuryFloorPct cosmossdk_io_math.LegacyDec `protobuf:"bytes,40,opt,name=treasury_floor_pct,json=treasuryFloorPct,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"treasury_floor_pct"`
	// burn_adjustment_smoothing: Blocks over which to smooth rate changes (default 100)
	// Prevents rapid oscillation, provides predictability
	// Range: 10 - 1000 blocks
	BurnAdjustmentSmoothing uint64 `protobuf:"varint,41,opt,name=burn_adjustment_smoothing,json=burnAdjustmentSmoothing,proto3" json:"burn_adjustment_smoothing,omitempty"`
	// last_applied_burn_ratio: Read-only state tracking current burn rate
	// Updated each block by adaptive controller
	// Exposed via query endpoint for observability
	LastAppliedBurnRatio cosmossdk_io_math.LegacyDec `protobuf:"bytes,42,opt,name=last_applied_burn_ratio,json=lastAppliedBurnRatio,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"last_applied_burn_ratio"`
	// last_burn_trigger: Read-only state tracking reason for current rate
	// Examples: "congestion", "treasury_low", "low_adoption", "normal"
	LastBurnTrigger string `protobuf:"bytes,43,opt,name=last_burn_trigger,json=lastBurnTrigger,proto3" json:"last_burn_trigger,omitempty"`
	// emergency_burn_override: DAO emergency override to disable adaptive logic
	// When true, uses fee_burn_ratio regardless of conditions
	// Requires governance vote to enable/disable
	EmergencyBurnOverride bool `protobuf:"varint,44,opt,name=emergency_burn_override,json=emergencyBurnOverride,proto3" json:"emergency_burn_override,omitempty"`
	// treasury_redirect_enabled: Enable treasury redirect mechanism
	TreasuryRedirectEnabled bool `protobuf:"varint,45,opt,name=treasury_redirect_enabled,json=treasuryRedirectEnabled,proto3" json:"treasury_redirect_enabled,omitempty"`
	// treasury_redirect_ratio: Max % of treasury INFLOWS to redirect (0-10%)
	TreasuryRedirectRatio cosmossdk_io_math.LegacyDec `protobuf:"bytes,46,opt,name=treasury_redirect_ratio,json=treasuryRedirectRatio,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"treasury_redirect_ratio"`
	// redirect_to_ecosystem_grants: % of redirected funds to ecosystem grants
	RedirectToEcosystemGrants cosmossdk_io_math.LegacyDec `protobuf:"bytes,47,opt,name=redirect_to_ecosystem_grants,json=redirectToEcosystemGrants,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"redirect_to_ecosystem_grants"`
	// redirect_to_buy_and_burn: % of redirected funds for buy-and-burn
	RedirectToBuyAndBurn cosmossdk_io_math.LegacyDec `protobuf:"bytes,48,opt,name=redirect_to_buy_and_burn,json=redirectToBuyAndBurn,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"redirect_to_buy_and_burn"`
	// redirect_to_insurance_fund: % of redirected funds to insurance
	RedirectToInsuranceFund cosmossdk_io_math.LegacyDec `protobuf:"bytes,49,opt,name=redirect_to_insurance_fund,json=redirectToInsuranceFund,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"redirect_to_insurance_fund"`
	// redirect_to_research_fund: % of redirected funds to research
	RedirectToResearchFund cosmossdk_io_math.LegacyDec `protobuf:"bytes,50,opt,name=redirect_to_research_fund,json=redirectToResearchFund,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"redirect_to_research_fund"`
	// redirect_execution_interval: Blocks between redirect executions
	RedirectExecutionInterval uint64 `protobuf:"varint,51,opt,name=redirect_execution_interval,json=redirectExecutionInterval,proto3" json:"redirect_execution_interval,omitempty"`
	// last_redirect_height: Block height of last redirect execution
	LastRedirectHeight int64 `protobuf:"varint,52,opt,name=last_redirect_height,json=lastRedirectHeight,proto3" json:"last_redirect_height,omitempty"`
	// accumulated_redirect_inflows: Treasury inflows since last redirect
	AccumulatedRedirectInflows cosmossdk_io_math.Int `protobuf:"bytes,53,opt,name=accumulated_redirect_inflows,json=accumulatedRedirectInflows,proto3,customtype=cosmossdk.io/math.Int" json:"accumulated_redirect_inflows"`
}

func (m *TokenomicsParams) Reset()         { *m = TokenomicsParams{} }
func (m *TokenomicsParams) String() string { return proto.CompactTextString(m) }
func (*TokenomicsParams) ProtoMessage()    {}
func (*TokenomicsParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_017f958255b51c12, []int{0}
}
func (m *TokenomicsParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TokenomicsParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TokenomicsParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TokenomicsParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TokenomicsParams.Merge(m, src)
}
func (m *TokenomicsParams) XXX_Size() int {
	return m.Size()
}
func (m *TokenomicsParams) XXX_DiscardUnknown() {
	xxx_messageInfo_TokenomicsParams.DiscardUnknown(m)
}

var xxx_messageInfo_TokenomicsParams proto.InternalMessageInfo

func (m *TokenomicsParams) GetFeeBurnEnabled() bool {
	if m != nil {
		return m.FeeBurnEnabled
	}
	return false
}

func (m *TokenomicsParams) GetRewardStreamInterval() uint64 {
	if m != nil {
		return m.RewardStreamInterval
	}
	return 0
}

func (m *TokenomicsParams) GetContinuityIbcChannel() string {
	if m != nil {
		return m.ContinuityIbcChannel
	}
	return ""
}

func (m *TokenomicsParams) GetSequencerIbcChannel() string {
	if m != nil {
		return m.SequencerIbcChannel
	}
	return ""
}

func (m *TokenomicsParams) GetParamChangeDelay() uint64 {
	if m != nil {
		return m.ParamChangeDelay
	}
	return 0
}

func (m *TokenomicsParams) GetVotingPeriod() uint64 {
	if m != nil {
		return m.VotingPeriod
	}
	return 0
}

func (m *TokenomicsParams) GetAdaptiveBurnEnabled() bool {
	if m != nil {
		return m.AdaptiveBurnEnabled
	}
	return false
}

func (m *TokenomicsParams) GetTxPerDayTarget() uint64 {
	if m != nil {
		return m.TxPerDayTarget
	}
	return 0
}

func (m *TokenomicsParams) GetBurnAdjustmentSmoothing() uint64 {
	if m != nil {
		return m.BurnAdjustmentSmoothing
	}
	return 0
}

func (m *TokenomicsParams) GetLastBurnTrigger() string {
	if m != nil {
		return m.LastBurnTrigger
	}
	return ""
}

func (m *TokenomicsParams) GetEmergencyBurnOverride() bool {
	if m != nil {
		return m.EmergencyBurnOverride
	}
	return false
}

// DefaultParams returns the default tokenomics parameters
// These are the INITIAL values; DAO can modify within protocol constraints
type DefaultTokenomicsParams struct {
	// Supply (IMMUTABLE caps)
	TotalSupplyCap     string `protobuf:"bytes,1,opt,name=total_supply_cap,json=totalSupplyCap,proto3" json:"total_supply_cap,omitempty"`
	CurrentTotalSupply string `protobuf:"bytes,2,opt,name=current_total_supply,json=currentTotalSupply,proto3" json:"current_total_supply,omitempty"`
	TotalMinted        string `protobuf:"bytes,3,opt,name=total_minted,json=totalMinted,proto3" json:"total_minted,omitempty"`
	TotalBurned        string `protobuf:"bytes,4,opt,name=total_burned,json=totalBurned,proto3" json:"total_burned,omitempty"`
	// Inflation (DAO-adjustable 1-5%)
	InflationRate string `protobuf:"bytes,5,opt,name=inflation_rate,json=inflationRate,proto3" json:"inflation_rate,omitempty"`
	InflationMin  string `protobuf:"bytes,6,opt,name=inflation_min,json=inflationMin,proto3" json:"inflation_min,omitempty"`
	InflationMax  string `protobuf:"bytes,7,opt,name=inflation_max,json=inflationMax,proto3" json:"inflation_max,omitempty"`
	// Emission splits (must sum to 1.0)
	EmissionSplitStaking   string `protobuf:"bytes,8,opt,name=emission_split_staking,json=emissionSplitStaking,proto3" json:"emission_split_staking,omitempty"`
	EmissionSplitPoc       string `protobuf:"bytes,9,opt,name=emission_split_poc,json=emissionSplitPoc,proto3" json:"emission_split_poc,omitempty"`
	EmissionSplitSequencer string `protobuf:"bytes,10,opt,name=emission_split_sequencer,json=emissionSplitSequencer,proto3" json:"emission_split_sequencer,omitempty"`
	EmissionSplitTreasury  string `protobuf:"bytes,11,opt,name=emission_split_treasury,json=emissionSplitTreasury,proto3" json:"emission_split_treasury,omitempty"`
	// Burn rates (starting values, DAO-adjustable 0-50%)
	BurnRatePosGas         string `protobuf:"bytes,12,opt,name=burn_rate_pos_gas,json=burnRatePosGas,proto3" json:"burn_rate_pos_gas,omitempty"`
	BurnRatePocAnchoring   string `protobuf:"bytes,13,opt,name=burn_rate_poc_anchoring,json=burnRatePocAnchoring,proto3" json:"burn_rate_poc_anchoring,omitempty"`
	BurnRateSequencerGas   string `protobuf:"bytes,14,opt,name=burn_rate_sequencer_gas,json=burnRateSequencerGas,proto3" json:"burn_rate_sequencer_gas,omitempty"`
	BurnRateSmartContracts string `protobuf:"bytes,15,opt,name=burn_rate_smart_contracts,json=burnRateSmartContracts,proto3" json:"burn_rate_smart_contracts,omitempty"`
	BurnRateAiQueries      string `protobuf:"bytes,16,opt,name=burn_rate_ai_queries,json=burnRateAiQueries,proto3" json:"burn_rate_ai_queries,omitempty"`
	BurnRateMessaging      string `protobuf:"bytes,17,opt,name=burn_rate_messaging,json=burnRateMessaging,proto3" json:"burn_rate_messaging,omitempty"`
	// Treasury
	TreasuryBurnRedirect string `protobuf:"bytes,18,opt,name=treasury_burn_redirect,json=treasuryBurnRedirect,proto3" json:"treasury_burn_redirect,omitempty"`
	// Fee Burn & Treasury Split
	FeeBurnEnabled   bool   `protobuf:"varint,31,opt,name=fee_burn_enabled,json=feeBurnEnabled,proto3" json:"fee_burn_enabled,omitempty"`
	FeeBurnRatio     string `protobuf:"bytes,32,opt,name=fee_burn_ratio,json=feeBurnRatio,proto3" json:"fee_burn_ratio,omitempty"`
	TreasuryFeeRatio string `protobuf:"bytes,33,opt,name=treasury_fee_ratio,json=treasuryFeeRatio,proto3" json:"treasury_fee_ratio,omitempty"`
	// Gas & Fee Policy
	MinGasPrice                  string `protobuf:"bytes,19,opt,name=min_gas_price,json=minGasPrice,proto3" json:"min_gas_price,omitempty"`
	GasConversionRatioContinuity string `protobuf:"bytes,20,opt,name=gas_conversion_ratio_continuity,json=gasConversionRatioContinuity,proto3" json:"gas_conversion_ratio_continuity,omitempty"`
	GasConversionRatioSequencer  string `protobuf:"bytes,21,opt,name=gas_conversion_ratio_sequencer,json=gasConversionRatioSequencer,proto3" json:"gas_conversion_ratio_sequencer,omitempty"`
	// PoC Merit Engine
	PocAlpha string `protobuf:"bytes,22,opt,name=poc_alpha,json=pocAlpha,proto3" json:"poc_alpha,omitempty"`
	// IBC reward streams
	RewardStreamInterval uint64 `protobuf:"varint,23,opt,name=reward_stream_interval,json=rewardStreamInterval,proto3" json:"reward_stream_interval,omitempty"`
	ContinuityIbcChannel string `protobuf:"bytes,24,opt,name=continuity_ibc_channel,json=continuityIbcChannel,proto3" json:"continuity_ibc_channel,omitempty"`
	SequencerIbcChannel  string `protobuf:"bytes,25,opt,name=sequencer_ibc_channel,json=sequencerIbcChannel,proto3" json:"sequencer_ibc_channel,omitempty"`
	// Governance
	ParamChangeDelay   uint64 `protobuf:"varint,26,opt,name=param_change_delay,json=paramChangeDelay,proto3" json:"param_change_delay,omitempty"`
	MinProposalDeposit string `protobuf:"bytes,27,opt,name=min_proposal_deposit,json=minProposalDeposit,proto3" json:"min_proposal_deposit,omitempty"`
	QuorumPercentage   string `protobuf:"bytes,28,opt,name=quorum_percentage,json=quorumPercentage,proto3" json:"quorum_percentage,omitempty"`
	PassPercentage     string `protobuf:"bytes,29,opt,name=pass_percentage,json=passPercentage,proto3" json:"pass_percentage,omitempty"`
	VotingPeriod       uint64 `protobuf:"varint,30,opt,name=voting_period,json=votingPeriod,proto3" json:"voting_period,omitempty"`
}

func (m *DefaultTokenomicsParams) Reset()         { *m = DefaultTokenomicsParams{} }
func (m *DefaultTokenomicsParams) String() string { return proto.CompactTextString(m) }
func (*DefaultTokenomicsParams) ProtoMessage()    {}
func (*DefaultTokenomicsParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_017f958255b51c12, []int{1}
}
func (m *DefaultTokenomicsParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DefaultTokenomicsParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DefaultTokenomicsParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DefaultTokenomicsParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DefaultTokenomicsParams.Merge(m, src)
}
func (m *DefaultTokenomicsParams) XXX_Size() int {
	return m.Size()
}
func (m *DefaultTokenomicsParams) XXX_DiscardUnknown() {
	xxx_messageInfo_DefaultTokenomicsParams.DiscardUnknown(m)
}

var xxx_messageInfo_DefaultTokenomicsParams proto.InternalMessageInfo

func (m *DefaultTokenomicsParams) GetTotalSupplyCap() string {
	if m != nil {
		return m.TotalSupplyCap
	}
	return ""
}

func (m *DefaultTokenomicsParams) GetCurrentTotalSupply() string {
	if m != nil {
		return m.CurrentTotalSupply
	}
	return ""
}

func (m *DefaultTokenomicsParams) GetTotalMinted() string {
	if m != nil {
		return m.TotalMinted
	}
	return ""
}

func (m *DefaultTokenomicsParams) GetTotalBurned() string {
	if m != nil {
		return m.TotalBurned
	}
	return ""
}

func (m *DefaultTokenomicsParams) GetInflationRate() string {
	if m != nil {
		return m.InflationRate
	}
	return ""
}

func (m *DefaultTokenomicsParams) GetInflationMin() string {
	if m != nil {
		return m.InflationMin
	}
	return ""
}

func (m *DefaultTokenomicsParams) GetInflationMax() string {
	if m != nil {
		return m.InflationMax
	}
	return ""
}

func (m *DefaultTokenomicsParams) GetEmissionSplitStaking() string {
	if m != nil {
		return m.EmissionSplitStaking
	}
	return ""
}

func (m *DefaultTokenomicsParams) GetEmissionSplitPoc() string {
	if m != nil {
		return m.EmissionSplitPoc
	}
	return ""
}

func (m *DefaultTokenomicsParams) GetEmissionSplitSequencer() string {
	if m != nil {
		return m.EmissionSplitSequencer
	}
	return ""
}

func (m *DefaultTokenomicsParams) GetEmissionSplitTreasury() string {
	if m != nil {
		return m.EmissionSplitTreasury
	}
	return ""
}

func (m *DefaultTokenomicsParams) GetBurnRatePosGas() string {
	if m != nil {
		return m.BurnRatePosGas
	}
	return ""
}

func (m *DefaultTokenomicsParams) GetBurnRatePocAnchoring() string {
	if m != nil {
		return m.BurnRatePocAnchoring
	}
	return ""
}

func (m *DefaultTokenomicsParams) GetBurnRateSequencerGas() string {
	if m != nil {
		return m.BurnRateSequencerGas
	}
	return ""
}

func (m *DefaultTokenomicsParams) GetBurnRateSmartContracts() string {
	if m != nil {
		return m.BurnRateSmartContracts
	}
	return ""
}

func (m *DefaultTokenomicsParams) GetBurnRateAiQueries() string {
	if m != nil {
		return m.BurnRateAiQueries
	}
	return ""
}

func (m *DefaultTokenomicsParams) GetBurnRateMessaging() string {
	if m != nil {
		return m.BurnRateMessaging
	}
	return ""
}

func (m *DefaultTokenomicsParams) GetTreasuryBurnRedirect() string {
	if m != nil {
		return m.TreasuryBurnRedirect
	}
	return ""
}

func (m *DefaultTokenomicsParams) GetFeeBurnEnabled() bool {
	if m != nil {
		return m.FeeBurnEnabled
	}
	return false
}

func (m *DefaultTokenomicsParams) GetFeeBurnRatio() string {
	if m != nil {
		return m.FeeBurnRatio
	}
	return ""
}

func (m *DefaultTokenomicsParams) GetTreasuryFeeRatio() string {
	if m != nil {
		return m.TreasuryFeeRatio
	}
	return ""
}

func (m *DefaultTokenomicsParams) GetMinGasPrice() string {
	if m != nil {
		return m.MinGasPrice
	}
	return ""
}

func (m *DefaultTokenomicsParams) GetGasConversionRatioContinuity() string {
	if m != nil {
		return m.GasConversionRatioContinuity
	}
	return ""
}

func (m *DefaultTokenomicsParams) GetGasConversionRatioSequencer() string {
	if m != nil {
		return m.GasConversionRatioSequencer
	}
	return ""
}

func (m *DefaultTokenomicsParams) GetPocAlpha() string {
	if m != nil {
		return m.PocAlpha
	}
	return ""
}

func (m *DefaultTokenomicsParams) GetRewardStreamInterval() uint64 {
	if m != nil {
		return m.RewardStreamInterval
	}
	return 0
}

func (m *DefaultTokenomicsParams) GetContinuityIbcChannel() string {
	if m != nil {
		return m.ContinuityIbcChannel
	}
	return ""
}

func (m *DefaultTokenomicsParams) GetSequencerIbcChannel() string {
	if m != nil {
		return m.SequencerIbcChannel
	}
	return ""
}

func (m *DefaultTokenomicsParams) GetParamChangeDelay() uint64 {
	if m != nil {
		return m.ParamChangeDelay
	}
	return 0
}

func (m *DefaultTokenomicsParams) GetMinProposalDeposit() string {
	if m != nil {
		return m.MinProposalDeposit
	}
	return ""
}

func (m *DefaultTokenomicsParams) GetQuorumPercentage() string {
	if m != nil {
		return m.QuorumPercentage
	}
	return ""
}

func (m *DefaultTokenomicsParams) GetPassPercentage() string {
	if m != nil {
		return m.PassPercentage
	}
	return ""
}

func (m *DefaultTokenomicsParams) GetVotingPeriod() uint64 {
	if m != nil {
		return m.VotingPeriod
	}
	return 0
}

func init() {
	proto.RegisterType((*TokenomicsParams)(nil), "pos.tokenomics.v1.TokenomicsParams")
	proto.RegisterType((*DefaultTokenomicsParams)(nil), "pos.tokenomics.v1.DefaultTokenomicsParams")
}

func init() { proto.RegisterFile("pos/tokenomics/v1/params.proto", fileDescriptor_017f958255b51c12) }

var fileDescriptor_017f958255b51c12 = []byte{
	// 1414 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xdc, 0x98, 0xc1, 0x72, 0xdb, 0x44,
	0x1c, 0xc6, 0x63, 0x28, 0xa5, 0xdd, 0x26, 0x6e, 0xbc, 0x71, 0x92, 0x6d, 0xd2, 0x3a, 0x69, 0xd2,
	0xd2, 0xb4, 0x0d, 0x71, 0x0b, 0x6d, 0x07, 0x7a, 0x4b, 0x9d, 0xd2, 0xc9, 0x0c, 0x2d, 0xc6, 0x49,
	0x81, 0xe9, 0x00, 0x9a, 0xf5, 0x6a, 0x23, 0x2f, 0x91, 0xb4, 0xea, 0xee, 0xda, 0xd8, 0xaf, 0xc0,
	0x89, 0x47, 0xe0, 0x11, 0x98, 0x81, 0x87, 0xe8, 0xb1, 0xc3, 0x89, 0xe1, 0x50, 0x98, 0xf6, 0x00,
	0x8f, 0xc1, 0xec, 0x4a, 0x96, 0x64, 0x5b, 0x76, 0x5a, 0x85, 0x13, 0x97, 0x8c, 0xb3, 0x7f, 0xed,
	0xef, 0xd3, 0x6a, 0xd7, 0x7f, 0x7d, 0x9f, 0x41, 0x25, 0xe0, 0xb2, 0xaa, 0xf8, 0x21, 0xf5, 0xb9,
	0xc7, 0x88, 0xac, 0x76, 0x6e, 0x56, 0x03, 0x2c, 0xb0, 0x27, 0xb7, 0x02, 0xc1, 0x15, 0x87, 0xa5,
	0x80, 0xcb, 0xad, 0xa4, 0xbe, 0xd5, 0xb9, 0xb9, 0x54, 0xc2, 0x1e, 0xf3, 0x79, 0xd5, 0xfc, 0x0d,
	0xaf, 0x5a, 0x2a, 0x3b, 0xdc, 0xe1, 0xe6, 0x63, 0x55, 0x7f, 0x8a, 0x46, 0xcf, 0x11, 0x2e, 0x3d,
	0x2e, 0xad, 0xb0, 0x10, 0xfe, 0x13, 0x96, 0xd6, 0xfe, 0xbc, 0x00, 0x66, 0xf7, 0x63, 0x6a, 0xdd,
	0x28, 0xc2, 0xc7, 0x60, 0x56, 0x71, 0x85, 0x5d, 0x4b, 0xb6, 0x83, 0xc0, 0xed, 0x59, 0x04, 0x07,
	0xa8, 0xb0, 0x5a, 0xd8, 0x38, 0x7d, 0xef, 0xfa, 0xb3, 0x17, 0x2b, 0x53, 0x7f, 0xbc, 0x58, 0x99,
	0x0f, 0x21, 0xd2, 0x3e, 0xdc, 0x62, 0xbc, 0xea, 0x61, 0xd5, 0xda, 0xda, 0xf5, 0xd5, 0x6f, 0xbf,
	0xbe, 0x0f, 0x22, 0xfa, 0xae, 0xaf, 0x1a, 0x45, 0x03, 0xd9, 0x33, 0x8c, 0x1a, 0x0e, 0xe0, 0x37,
	0xa0, 0x4c, 0xda, 0x42, 0x50, 0x5f, 0x59, 0x69, 0x3c, 0x7a, 0xeb, 0xcd, 0xd1, 0x30, 0x02, 0xed,
	0x27, 0x0a, 0xf0, 0x11, 0x98, 0x0e, 0xb1, 0x1e, 0xf3, 0x15, 0xb5, 0xd1, 0xdb, 0x6f, 0x8e, 0x3d,
	0x63, 0x00, 0x0f, 0xcd, 0xfc, 0x84, 0xd7, 0x6c, 0x0b, 0x9f, 0xda, 0xe8, 0x44, 0x5e, 0xde, 0x3d,
	0x33, 0x1f, 0x7e, 0x05, 0x8a, 0xcc, 0x3f, 0x70, 0xb1, 0x62, 0xdc, 0xb7, 0x04, 0x56, 0x14, 0xbd,
	0x63, 0x88, 0x37, 0x23, 0xe2, 0xf2, 0x28, 0xf1, 0x53, 0xea, 0x60, 0xd2, 0xdb, 0xa1, 0x24, 0xc5,
	0xdd, 0xa1, 0xa4, 0x31, 0x13, 0x83, 0x1a, 0x58, 0x51, 0xf8, 0x05, 0x48, 0x06, 0xf4, 0xea, 0xd1,
	0xc9, 0xbc, 0xe0, 0xe9, 0x98, 0xf3, 0x90, 0xf9, 0x43, 0x5c, 0xdc, 0x45, 0xef, 0xfe, 0x07, 0x5c,
	0xdc, 0x85, 0x0e, 0x58, 0xa0, 0x1e, 0x93, 0x52, 0x63, 0x65, 0xe0, 0x32, 0x65, 0x49, 0x85, 0x0f,
	0x99, 0xef, 0xa0, 0x53, 0x79, 0x05, 0xca, 0x7d, 0xe0, 0x9e, 0xe6, 0xed, 0x85, 0x38, 0x68, 0x01,
	0x38, 0x24, 0x14, 0x70, 0x82, 0x4e, 0xe7, 0x15, 0x99, 0x1d, 0x10, 0xa9, 0x73, 0x02, 0x0f, 0x01,
	0x1a, 0x5e, 0x09, 0x7d, 0xda, 0xa6, 0x3e, 0xa1, 0x02, 0x81, 0xbc, 0x32, 0x0b, 0x83, 0x6b, 0xe9,
	0x03, 0x21, 0x03, 0x8b, 0x43, 0x62, 0x4a, 0x50, 0x2c, 0xdb, 0xa2, 0x87, 0xce, 0xe4, 0xd5, 0x9a,
	0x1f, 0xd0, 0xda, 0x8f, 0x78, 0xf0, 0x6b, 0x50, 0xd2, 0xa7, 0xde, 0x1c, 0x53, 0x2b, 0xe0, 0xd2,
	0x72, 0xb0, 0x44, 0xd3, 0x79, 0x45, 0x8a, 0x9a, 0xa5, 0x4f, 0x6a, 0x9d, 0xcb, 0x07, 0x58, 0xc2,
	0x16, 0x58, 0x4c, 0xd3, 0x89, 0x85, 0x7d, 0xd2, 0xe2, 0x42, 0x1f, 0x80, 0x99, 0xdc, 0x07, 0x20,
	0xd1, 0x20, 0xdb, 0x7d, 0xdc, 0xa0, 0x52, 0xbc, 0x35, 0x66, 0x35, 0xc5, 0x63, 0x2b, 0xc5, 0x3b,
	0xa3, 0xd7, 0xe4, 0x82, 0x73, 0x29, 0x25, 0x0f, 0x0b, 0x65, 0x11, 0xee, 0x2b, 0x81, 0x89, 0x92,
	0xe8, 0x6c, 0xee, 0xa3, 0x10, 0x6b, 0x69, 0x62, 0xad, 0x0f, 0x84, 0x4d, 0x50, 0x4e, 0xd4, 0x30,
	0xb3, 0x9e, 0xb6, 0xa9, 0x60, 0x54, 0xa2, 0xd9, 0xbc, 0x42, 0xa5, 0xbe, 0xd0, 0x36, 0xfb, 0x3c,
	0x64, 0x41, 0x0c, 0xe6, 0x12, 0x0d, 0x8f, 0x4a, 0x89, 0x1d, 0xbd, 0x43, 0xa5, 0x63, 0x4b, 0x3c,
	0xec, 0xb3, 0x74, 0x23, 0xe8, 0x1f, 0x61, 0x2b, 0xd4, 0xa2, 0x36, 0x13, 0x94, 0x28, 0x04, 0x73,
	0xef, 0x4e, 0x1f, 0xa8, 0xbb, 0x6e, 0x23, 0xc2, 0xc1, 0x0d, 0x30, 0x7b, 0x40, 0x69, 0xa8, 0x41,
	0x7d, 0xdc, 0x74, 0xa9, 0x8d, 0x56, 0x56, 0x0b, 0x1b, 0xa7, 0x1a, 0xc5, 0x03, 0x4a, 0xf5, 0xa5,
	0xf7, 0xc3, 0x51, 0xf8, 0x25, 0x28, 0xc6, 0x57, 0x0a, 0xdd, 0xb1, 0xd0, 0x6a, 0xee, 0xa6, 0x17,
	0xa1, 0x1b, 0x1a, 0xa3, 0x7b, 0x51, 0xbc, 0x56, 0xad, 0x10, 0xc2, 0x2f, 0xe6, 0xee, 0x45, 0x7d,
	0xd8, 0x27, 0x94, 0x86, 0x02, 0x8f, 0xc1, 0x8c, 0xc7, 0x7c, 0x7d, 0xb6, 0xad, 0x40, 0x30, 0x42,
	0xd1, 0x5c, 0x5e, 0xf6, 0x19, 0x8f, 0xf9, 0x0f, 0xb0, 0xac, 0x6b, 0x0a, 0xec, 0x82, 0x15, 0x8d,
	0x24, 0xdc, 0xef, 0x50, 0x21, 0xa3, 0x77, 0x17, 0xe3, 0xe6, 0x74, 0x33, 0xbf, 0xcd, 0x54, 0x0f,
	0x95, 0xf3, 0x0a, 0x9d, 0x77, 0xb0, 0xac, 0xc5, 0x60, 0xb3, 0x8c, 0x5a, 0x8c, 0x85, 0x1d, 0x50,
	0xc9, 0x54, 0x4e, 0x5a, 0xec, 0x7c, 0x5e, 0xe1, 0xe5, 0x51, 0xe1, 0xa4, 0xcf, 0x3e, 0x02, 0xa7,
	0x4d, 0x53, 0x72, 0x83, 0x16, 0x46, 0x0b, 0x79, 0x25, 0x4e, 0x05, 0x9c, 0x6c, 0x6b, 0x04, 0xbc,
	0x05, 0x16, 0x04, 0xfd, 0x1e, 0x0b, 0xdb, 0x92, 0x7a, 0xd3, 0x3c, 0x4b, 0xfb, 0x0b, 0xd1, 0xc1,
	0x2e, 0x5a, 0x5c, 0x2d, 0x6c, 0x9c, 0x68, 0x94, 0xc3, 0xea, 0x9e, 0x29, 0xee, 0x46, 0x35, 0x3d,
	0x2b, 0x79, 0xc4, 0x16, 0x6b, 0x12, 0x8b, 0xb4, 0xb0, 0xef, 0x53, 0x17, 0x21, 0x7d, 0x4b, 0x8d,
	0x72, 0x52, 0xdd, 0x6d, 0x92, 0x5a, 0x58, 0x83, 0x1f, 0x80, 0xf9, 0xa4, 0xcd, 0xa5, 0x27, 0x9d,
	0x33, 0x93, 0xe6, 0xe2, 0x62, 0x6a, 0xce, 0x26, 0x80, 0xc6, 0x6a, 0x9a, 0x6b, 0x1d, 0x6a, 0xd9,
	0xd4, 0xc5, 0x3d, 0xb4, 0x64, 0xee, 0x6d, 0xd6, 0x54, 0x6a, 0xa6, 0xb0, 0xa3, 0xc7, 0xb5, 0x8b,
	0xd3, 0xc7, 0x2c, 0x10, 0x3c, 0xe0, 0x12, 0xbb, 0x96, 0x4d, 0x03, 0x2e, 0x99, 0x42, 0xcb, 0x39,
	0x5c, 0x9c, 0xc7, 0xfc, 0x7a, 0xc4, 0xd9, 0x09, 0x31, 0xf0, 0x5b, 0x50, 0x7a, 0xda, 0xe6, 0xa2,
	0xed, 0x59, 0x01, 0x15, 0x84, 0xfa, 0x0a, 0x3b, 0x14, 0x9d, 0xcf, 0xfd, 0x2d, 0x09, 0x59, 0xf5,
	0x18, 0x05, 0x9f, 0x80, 0xb3, 0x01, 0x96, 0x32, 0x4d, 0xbf, 0x90, 0xfb, 0xbd, 0xa6, 0x49, 0x29,
	0xf6, 0x3a, 0x98, 0xe9, 0x70, 0xc5, 0x7c, 0x47, 0xd3, 0x19, 0xb7, 0x51, 0xc5, 0x3c, 0xc3, 0xe9,
	0x70, 0xb0, 0x6e, 0xc6, 0xf4, 0x0e, 0x61, 0x1b, 0x07, 0x8a, 0x75, 0x86, 0xfa, 0xd1, 0x9a, 0xe9,
	0x47, 0x73, 0xfd, 0xe2, 0x50, 0x53, 0xd2, 0xcf, 0x3c, 0xd5, 0x94, 0xd6, 0x73, 0x37, 0x25, 0x8f,
	0xf9, 0x49, 0x53, 0xd2, 0x60, 0xdc, 0x4d, 0x83, 0x2f, 0xe5, 0x07, 0xe3, 0xee, 0x40, 0xb7, 0xb3,
	0xe9, 0x01, 0x6e, 0xbb, 0x2a, 0x0d, 0xbf, 0x9c, 0x7b, 0x1f, 0x23, 0x58, 0x22, 0xc0, 0xc1, 0x52,
	0xd3, 0xe5, 0xe4, 0x50, 0xb7, 0x07, 0x87, 0x4a, 0x63, 0x51, 0x55, 0x4b, 0x50, 0xd9, 0xe2, 0xae,
	0x8d, 0xde, 0xcb, 0x2b, 0x84, 0x0c, 0xb4, 0x16, 0x33, 0xf7, 0xfb, 0x48, 0x78, 0x15, 0x94, 0x54,
	0x57, 0x6f, 0xac, 0x65, 0xe3, 0x9e, 0xa5, 0xb0, 0x70, 0xa8, 0x42, 0x57, 0xcc, 0x06, 0x17, 0x55,
	0xb7, 0x4e, 0xc5, 0x0e, 0xee, 0xed, 0x9b, 0xd1, 0xc1, 0x56, 0xef, 0x72, 0x2e, 0xac, 0x80, 0x28,
	0xb4, 0x71, 0xfc, 0x56, 0xaf, 0x59, 0x75, 0xa2, 0xe0, 0xdd, 0xc8, 0x6c, 0x60, 0xfb, 0xbb, 0xb6,
	0x54, 0x9e, 0x4e, 0x54, 0xd2, 0xe3, 0x5c, 0xb5, 0xf4, 0x0b, 0xfa, 0xaa, 0xb9, 0x27, 0xe3, 0x7b,
	0xb6, 0xe3, 0xfa, 0x5e, 0xbf, 0xac, 0x2d, 0x91, 0x8b, 0xa5, 0xb2, 0x70, 0x10, 0xb8, 0x8c, 0xda,
	0xe9, 0xed, 0xb9, 0x96, 0xfb, 0xa5, 0xab, 0x89, 0xdb, 0x21, 0x30, 0xd9, 0xa2, 0x6b, 0xa0, 0x64,
	0x94, 0x8c, 0x82, 0x12, 0xcc, 0x71, 0xa8, 0x40, 0xd7, 0x4d, 0x1f, 0x3a, 0xab, 0x0b, 0xfa, 0xca,
	0xfd, 0x70, 0x18, 0xde, 0xd1, 0xde, 0x96, 0x0a, 0x87, 0xfa, 0x24, 0xb2, 0x02, 0xbc, 0x43, 0x85,
	0x60, 0x36, 0x45, 0x9b, 0xe6, 0x7b, 0x31, 0x1f, 0x97, 0xf5, 0xb4, 0xcf, 0xa2, 0xe2, 0xdd, 0xd5,
	0x7f, 0x7e, 0x5a, 0x29, 0xfc, 0xf0, 0xf7, 0xcf, 0xd7, 0x16, 0x75, 0x7e, 0xee, 0xa6, 0x13, 0x74,
	0x18, 0x66, 0xd7, 0x7e, 0x99, 0x06, 0x8b, 0x3b, 0xe1, 0xe9, 0x19, 0x09, 0xba, 0x1b, 0xe3, 0x82,
	0xee, 0x48, 0x76, 0xbd, 0x31, 0x29, 0xbb, 0x66, 0xc6, 0xd1, 0x8b, 0x59, 0x71, 0x74, 0x30, 0x61,
	0x5e, 0xcc, 0x4a, 0x98, 0x83, 0xa1, 0xf1, 0x72, 0x76, 0x68, 0x1c, 0x4e, 0x80, 0xeb, 0x99, 0x09,
	0x70, 0x28, 0xce, 0xad, 0x67, 0xc6, 0xb9, 0xa1, 0x6c, 0x76, 0x6b, 0x72, 0x36, 0x1b, 0x13, 0xb4,
	0x36, 0xc7, 0x07, 0xad, 0x8c, 0xd4, 0xf4, 0xd1, 0x51, 0xa9, 0x69, 0x6c, 0x04, 0xba, 0x73, 0x44,
	0x04, 0x1a, 0x97, 0x67, 0xae, 0x8e, 0xcd, 0x33, 0x23, 0xe1, 0xe4, 0xf6, 0x11, 0xe1, 0x64, 0x4c,
	0xd2, 0xb8, 0x7d, 0x44, 0xd2, 0x18, 0x13, 0x1b, 0x3e, 0x3e, 0x32, 0x36, 0x8c, 0xcd, 0x00, 0xd5,
	0x49, 0x19, 0x20, 0xcb, 0xd0, 0x6f, 0x4d, 0x30, 0xf4, 0x59, 0xee, 0xfc, 0xd6, 0x64, 0x77, 0x7e,
	0x6c, 0xab, 0x7d, 0x29, 0xdb, 0x6a, 0x0f, 0xf9, 0xe6, 0xcd, 0xf1, 0xbe, 0x39, 0xc3, 0x04, 0xaf,
	0x65, 0x9a, 0xe0, 0x41, 0x47, 0x7b, 0xff, 0x35, 0x1d, 0xed, 0x11, 0xf6, 0xb4, 0xf6, 0x7a, 0xf6,
	0x74, 0xb2, 0xd7, 0x5c, 0x1e, 0xf1, 0x9a, 0xff, 0x5b, 0xe3, 0x78, 0x63, 0x92, 0x71, 0xcc, 0xf4,
	0x82, 0xd7, 0xc7, 0x7a, 0xc1, 0x0c, 0x63, 0x77, 0x65, 0x8c, 0xb1, 0xcb, 0xe5, 0xd2, 0xee, 0xdd,
	0x78, 0xf6, 0xb2, 0x52, 0x78, 0xfe, 0xb2, 0x52, 0xf8, 0xeb, 0x65, 0xa5, 0xf0, 0xe3, 0xab, 0xca,
	0xd4, 0xf3, 0x57, 0x95, 0xa9, 0xdf, 0x5f, 0x55, 0xa6, 0x9e, 0x2c, 0x8c, 0xbc, 0x68, 0x54, 0x2f,
	0xa0, 0xb2, 0x79, 0xd2, 0xfc, 0xa0, 0xfa, 0xe1, 0xbf, 0x01, 0x00, 0x00, 0xff, 0xff, 0xe6, 0xfb,
	0x7f, 0x2c, 0xc9, 0x15, 0x00, 0x00,
}

func (this *TokenomicsParams) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TokenomicsParams)
	if !ok {
		that2, ok := that.(TokenomicsParams)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.TotalSupplyCap.Equal(that1.TotalSupplyCap) {
		return false
	}
	if !this.CurrentTotalSupply.Equal(that1.CurrentTotalSupply) {
		return false
	}
	if !this.TotalMinted.Equal(that1.TotalMinted) {
		return false
	}
	if !this.TotalBurned.Equal(that1.TotalBurned) {
		return false
	}
	if !this.InflationRate.Equal(that1.InflationRate) {
		return false
	}
	if !this.InflationMin.Equal(that1.InflationMin) {
		return false
	}
	if !this.InflationMax.Equal(that1.InflationMax) {
		return false
	}
	if !this.EmissionSplitStaking.Equal(that1.EmissionSplitStaking) {
		return false
	}
	if !this.EmissionSplitPoc.Equal(that1.EmissionSplitPoc) {
		return false
	}
	if !this.EmissionSplitSequencer.Equal(that1.EmissionSplitSequencer) {
		return false
	}
	if !this.EmissionSplitTreasury.Equal(that1.EmissionSplitTreasury) {
		return false
	}
	if !this.BurnRatePosGas.Equal(that1.BurnRatePosGas) {
		return false
	}
	if !this.BurnRatePocAnchoring.Equal(that1.BurnRatePocAnchoring) {
		return false
	}
	if !this.BurnRateSequencerGas.Equal(that1.BurnRateSequencerGas) {
		return false
	}
	if !this.BurnRateSmartContracts.Equal(that1.BurnRateSmartContracts) {
		return false
	}
	if !this.BurnRateAiQueries.Equal(that1.BurnRateAiQueries) {
		return false
	}
	if !this.BurnRateMessaging.Equal(that1.BurnRateMessaging) {
		return false
	}
	if !this.TreasuryBurnRedirect.Equal(that1.TreasuryBurnRedirect) {
		return false
	}
	if this.FeeBurnEnabled != that1.FeeBurnEnabled {
		return false
	}
	if !this.FeeBurnRatio.Equal(that1.FeeBurnRatio) {
		return false
	}
	if !this.TreasuryFeeRatio.Equal(that1.TreasuryFeeRatio) {
		return false
	}
	if !this.MinGasPrice.Equal(that1.MinGasPrice) {
		return false
	}
	if !this.GasConversionRatioContinuity.Equal(that1.GasConversionRatioContinuity) {
		return false
	}
	if !this.GasConversionRatioSequencer.Equal(that1.GasConversionRatioSequencer) {
		return false
	}
	if !this.PocAlpha.Equal(that1.PocAlpha) {
		return false
	}
	if this.RewardStreamInterval != that1.RewardStreamInterval {
		return false
	}
	if this.ContinuityIbcChannel != that1.ContinuityIbcChannel {
		return false
	}
	if this.SequencerIbcChannel != that1.SequencerIbcChannel {
		return false
	}
	if this.ParamChangeDelay != that1.ParamChangeDelay {
		return false
	}
	if !this.MinProposalDeposit.Equal(that1.MinProposalDeposit) {
		return false
	}
	if !this.QuorumPercentage.Equal(that1.QuorumPercentage) {
		return false
	}
	if !this.PassPercentage.Equal(that1.PassPercentage) {
		return false
	}
	if this.VotingPeriod != that1.VotingPeriod {
		return false
	}
	if this.AdaptiveBurnEnabled != that1.AdaptiveBurnEnabled {
		return false
	}
	if !this.MinBurnRatio.Equal(that1.MinBurnRatio) {
		return false
	}
	if !this.MaxBurnRatio.Equal(that1.MaxBurnRatio) {
		return false
	}
	if !this.DefaultBurnRatio.Equal(that1.DefaultBurnRatio) {
		return false
	}
	if !this.BlockCongestionThreshold.Equal(that1.BlockCongestionThreshold) {
		return false
	}
	if this.TxPerDayTarget != that1.TxPerDayTarget {
		return false
	}
	if !this.TreasuryFloorPct.Equal(that1.TreasuryFloorPct) {
		return false
	}
	if this.BurnAdjustmentSmoothing != that1.BurnAdjustmentSmoothing {
		return false
	}
	if !this.LastAppliedBurnRatio.Equal(that1.LastAppliedBurnRatio) {
		return false
	}
	if this.LastBurnTrigger != that1.LastBurnTrigger {
		return false
	}
	if this.EmergencyBurnOverride != that1.EmergencyBurnOverride {
		return false
	}
	return true
}
func (m *TokenomicsParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TokenomicsParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TokenomicsParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.EmergencyBurnOverride {
		i--
		if m.EmergencyBurnOverride {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xe0
	}
	if len(m.LastBurnTrigger) > 0 {
		i -= len(m.LastBurnTrigger)
		copy(dAtA[i:], m.LastBurnTrigger)
		i = encodeVarintParams(dAtA, i, uint64(len(m.LastBurnTrigger)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xda
	}
	{
		size := m.LastAppliedBurnRatio.Size()
		i -= size
		if _, err := m.LastAppliedBurnRatio.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintParams(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2
	i--
	dAtA[i] = 0xd2
	if m.BurnAdjustmentSmoothing != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.BurnAdjustmentSmoothing))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xc8
	}
	{
		size := m.TreasuryFloorPct.Size()
		i -= size
		if _, err := m.TreasuryFloorPct.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintParams(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2
	i--
	dAtA[i] = 0xc2
	if m.TxPerDayTarget != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.TxPerDayTarget))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xb8
	}
	{
		size := m.BlockCongestionThreshold.Size()
		i -= size
		if _, err := m.BlockCongestionThreshold.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintParams(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2
	i--
	dAtA[i] = 0xb2
	{
		size := m.DefaultBurnRatio.Size()
		i -= size
		if _, err := m.DefaultBurnRatio.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintParams(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2
	i--
	dAtA[i] = 0xaa
	{
		size := m.MaxBurnRatio.Size()
		i -= size
		if _, err := m.MaxBurnRatio.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintParams(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2
	i--
	dAtA[i] = 0xa2
	{
		size := m.MinBurnRatio.Size()
		i -= size
		if _, err := m.MinBurnRatio.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintParams(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2
	i--
	dAtA[i] = 0x9a
	if m.AdaptiveBurnEnabled {
		i--
		if m.AdaptiveBurnEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x90
	}
	{
		size := m.TreasuryFeeRatio.Size()
		i -= size
		if _, err := m.TreasuryFeeRatio.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintParams(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2
	i--
	dAtA[i] = 0x8a
	{
		size := m.FeeBurnRatio.Size()
		i -= size
		if _, err := m.FeeBurnRatio.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintParams(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2
	i--
	dAtA[i] = 0x82
	if m.FeeBurnEnabled {
		i--
		if m.FeeBurnEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf8
	}
	if m.VotingPeriod != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.VotingPeriod))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf0
	}
	{
		size := m.PassPercentage.Size()
		i -= size
		if _, err := m.PassPercentage.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintParams(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xea
	{
		size := m.QuorumPercentage.Size()
		i -= size
		if _, err := m.QuorumPercentage.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintParams(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xe2
	{
		size := m.MinProposalDeposit.Size()
		i -= size
		if _, err := m.MinProposalDeposit.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintParams(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xda
	if m.ParamChangeDelay != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.ParamChangeDelay))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd0
	}
	if len(m.SequencerIbcChannel) > 0 {
		i -= len(m.SequencerIbcChannel)
		copy(dAtA[i:], m.SequencerIbcChannel)
		i = encodeVarintParams(dAtA, i, uint64(len(m.SequencerIbcChannel)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xca
	}
	if len(m.ContinuityIbcChannel) > 0 {
		i -= len(m.ContinuityIbcChannel)
		copy(dAtA[i:], m.ContinuityIbcChannel)
		i = encodeVarintParams(dAtA, i, uint64(len(m.ContinuityIbcChannel)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc2
	}
	if m.RewardStreamInterval != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.RewardStreamInterval))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb8
	}
	{
		size := m.PocAlpha.Size()
		i -= size
		if _, err := m.PocAlpha.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintParams(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xb2
	{
		size := m.GasConversionRatioSequencer.Size()
		i -= size
		if _, err := m.GasConversionRatioSequencer.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintParams(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xaa
	{
		size := m.GasConversionRatioContinuity.Size()
		i -= size
		if _, err := m.GasConversionRatioContinuity.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintParams(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xa2
	{
		size := m.MinGasPrice.Size()
		i -= size
		if _, err := m.MinGasPrice.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintParams(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x9a
	{
		size := m.TreasuryBurnRedirect.Size()
		i -= size
		if _, err := m.TreasuryBurnRedirect.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintParams(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x92
	{
		size := m.BurnRateMessaging.Size()
		i -= size
		if _, err := m.BurnRateMessaging.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintParams(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x8a
	{
		size := m.BurnRateAiQueries.Size()
		i -= size
		if _, err := m.BurnRateAiQueries.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintParams(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x82
	{
		size := m.BurnRateSmartContracts.Size()
		i -= size
		if _, err := m.BurnRateSmartContracts.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintParams(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x7a
	{
		size := m.BurnRateSequencerGas.Size()
		i -= size
		if _, err := m.BurnRateSequencerGas.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintParams(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x72
	{
		size := m.BurnRatePocAnchoring.Size()
		i -= size
		if _, err := m.BurnRatePocAnchoring.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintParams(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x6a
	{
		size := m.BurnRatePosGas.Size()
		i -= size
		if _, err := m.BurnRatePosGas.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintParams(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x62
	{
		size := m.EmissionSplitTreasury.Size()
		i -= size
		if _, err := m.EmissionSplitTreasury.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintParams(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x5a
	{
		size := m.EmissionSplitSequencer.Size()
		i -= size
		if _, err := m.EmissionSplitSequencer.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintParams(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x52
	{
		size := m.EmissionSplitPoc.Size()
		i -= size
		if _, err := m.EmissionSplitPoc.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintParams(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x4a
	{
		size := m.EmissionSplitStaking.Size()
		i -= size
		if _, err := m.EmissionSplitStaking.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintParams(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x42
	{
		size := m.InflationMax.Size()
		i -= size
		if _, err := m.InflationMax.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintParams(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	{
		size := m.InflationMin.Size()
		i -= size
		if _, err := m.InflationMin.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintParams(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	{
		size := m.InflationRate.Size()
		i -= size
		if _, err := m.InflationRate.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintParams(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size := m.TotalBurned.Size()
		i -= size
		if _, err := m.TotalBurned.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintParams(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size := m.TotalMinted.Size()
		i -= size
		if _, err := m.TotalMinted.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintParams(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.CurrentTotalSupply.Size()
		i -= size
		if _, err := m.CurrentTotalSupply.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintParams(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size := m.TotalSupplyCap.Size()
		i -= size
		if _, err := m.TotalSupplyCap.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintParams(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *DefaultTokenomicsParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DefaultTokenomicsParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DefaultTokenomicsParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TreasuryFeeRatio) > 0 {
		i -= len(m.TreasuryFeeRatio)
		copy(dAtA[i:], m.TreasuryFeeRatio)
		i = encodeVarintParams(dAtA, i, uint64(len(m.TreasuryFeeRatio)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x8a
	}
	if len(m.FeeBurnRatio) > 0 {
		i -= len(m.FeeBurnRatio)
		copy(dAtA[i:], m.FeeBurnRatio)
		i = encodeVarintParams(dAtA, i, uint64(len(m.FeeBurnRatio)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x82
	}
	if m.FeeBurnEnabled {
		i--
		if m.FeeBurnEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf8
	}
	if m.VotingPeriod != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.VotingPeriod))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf0
	}
	if len(m.PassPercentage) > 0 {
		i -= len(m.PassPercentage)
		copy(dAtA[i:], m.PassPercentage)
		i = encodeVarintParams(dAtA, i, uint64(len(m.PassPercentage)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xea
	}
	if len(m.QuorumPercentage) > 0 {
		i -= len(m.QuorumPercentage)
		copy(dAtA[i:], m.QuorumPercentage)
		i = encodeVarintParams(dAtA, i, uint64(len(m.QuorumPercentage)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe2
	}
	if len(m.MinProposalDeposit) > 0 {
		i -= len(m.MinProposalDeposit)
		copy(dAtA[i:], m.MinProposalDeposit)
		i = encodeVarintParams(dAtA, i, uint64(len(m.MinProposalDeposit)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xda
	}
	if m.ParamChangeDelay != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.ParamChangeDelay))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd0
	}
	if len(m.SequencerIbcChannel) > 0 {
		i -= len(m.SequencerIbcChannel)
		copy(dAtA[i:], m.SequencerIbcChannel)
		i = encodeVarintParams(dAtA, i, uint64(len(m.SequencerIbcChannel)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xca
	}
	if len(m.ContinuityIbcChannel) > 0 {
		i -= len(m.ContinuityIbcChannel)
		copy(dAtA[i:], m.ContinuityIbcChannel)
		i = encodeVarintParams(dAtA, i, uint64(len(m.ContinuityIbcChannel)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc2
	}
	if m.RewardStreamInterval != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.RewardStreamInterval))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb8
	}
	if len(m.PocAlpha) > 0 {
		i -= len(m.PocAlpha)
		copy(dAtA[i:], m.PocAlpha)
		i = encodeVarintParams(dAtA, i, uint64(len(m.PocAlpha)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	if len(m.GasConversionRatioSequencer) > 0 {
		i -= len(m.GasConversionRatioSequencer)
		copy(dAtA[i:], m.GasConversionRatioSequencer)
		i = encodeVarintParams(dAtA, i, uint64(len(m.GasConversionRatioSequencer)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	if len(m.GasConversionRatioContinuity) > 0 {
		i -= len(m.GasConversionRatioContinuity)
		copy(dAtA[i:], m.GasConversionRatioContinuity)
		i = encodeVarintParams(dAtA, i, uint64(len(m.GasConversionRatioContinuity)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if len(m.MinGasPrice) > 0 {
		i -= len(m.MinGasPrice)
		copy(dAtA[i:], m.MinGasPrice)
		i = encodeVarintParams(dAtA, i, uint64(len(m.MinGasPrice)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	if len(m.TreasuryBurnRedirect) > 0 {
		i -= len(m.TreasuryBurnRedirect)
		copy(dAtA[i:], m.TreasuryBurnRedirect)
		i = encodeVarintParams(dAtA, i, uint64(len(m.TreasuryBurnRedirect)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	if len(m.BurnRateMessaging) > 0 {
		i -= len(m.BurnRateMessaging)
		copy(dAtA[i:], m.BurnRateMessaging)
		i = encodeVarintParams(dAtA, i, uint64(len(m.BurnRateMessaging)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if len(m.BurnRateAiQueries) > 0 {
		i -= len(m.BurnRateAiQueries)
		copy(dAtA[i:], m.BurnRateAiQueries)
		i = encodeVarintParams(dAtA, i, uint64(len(m.BurnRateAiQueries)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if len(m.BurnRateSmartContracts) > 0 {
		i -= len(m.BurnRateSmartContracts)
		copy(dAtA[i:], m.BurnRateSmartContracts)
		i = encodeVarintParams(dAtA, i, uint64(len(m.BurnRateSmartContracts)))
		i--
		dAtA[i] = 0x7a
	}
	if len(m.BurnRateSequencerGas) > 0 {
		i -= len(m.BurnRateSequencerGas)
		copy(dAtA[i:], m.BurnRateSequencerGas)
		i = encodeVarintParams(dAtA, i, uint64(len(m.BurnRateSequencerGas)))
		i--
		dAtA[i] = 0x72
	}
	if len(m.BurnRatePocAnchoring) > 0 {
		i -= len(m.BurnRatePocAnchoring)
		copy(dAtA[i:], m.BurnRatePocAnchoring)
		i = encodeVarintParams(dAtA, i, uint64(len(m.BurnRatePocAnchoring)))
		i--
		dAtA[i] = 0x6a
	}
	if len(m.BurnRatePosGas) > 0 {
		i -= len(m.BurnRatePosGas)
		copy(dAtA[i:], m.BurnRatePosGas)
		i = encodeVarintParams(dAtA, i, uint64(len(m.BurnRatePosGas)))
		i--
		dAtA[i] = 0x62
	}
	if len(m.EmissionSplitTreasury) > 0 {
		i -= len(m.EmissionSplitTreasury)
		copy(dAtA[i:], m.EmissionSplitTreasury)
		i = encodeVarintParams(dAtA, i, uint64(len(m.EmissionSplitTreasury)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.EmissionSplitSequencer) > 0 {
		i -= len(m.EmissionSplitSequencer)
		copy(dAtA[i:], m.EmissionSplitSequencer)
		i = encodeVarintParams(dAtA, i, uint64(len(m.EmissionSplitSequencer)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.EmissionSplitPoc) > 0 {
		i -= len(m.EmissionSplitPoc)
		copy(dAtA[i:], m.EmissionSplitPoc)
		i = encodeVarintParams(dAtA, i, uint64(len(m.EmissionSplitPoc)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.EmissionSplitStaking) > 0 {
		i -= len(m.EmissionSplitStaking)
		copy(dAtA[i:], m.EmissionSplitStaking)
		i = encodeVarintParams(dAtA, i, uint64(len(m.EmissionSplitStaking)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.InflationMax) > 0 {
		i -= len(m.InflationMax)
		copy(dAtA[i:], m.InflationMax)
		i = encodeVarintParams(dAtA, i, uint64(len(m.InflationMax)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.InflationMin) > 0 {
		i -= len(m.InflationMin)
		copy(dAtA[i:], m.InflationMin)
		i = encodeVarintParams(dAtA, i, uint64(len(m.InflationMin)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.InflationRate) > 0 {
		i -= len(m.InflationRate)
		copy(dAtA[i:], m.InflationRate)
		i = encodeVarintParams(dAtA, i, uint64(len(m.InflationRate)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.TotalBurned) > 0 {
		i -= len(m.TotalBurned)
		copy(dAtA[i:], m.TotalBurned)
		i = encodeVarintParams(dAtA, i, uint64(len(m.TotalBurned)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.TotalMinted) > 0 {
		i -= len(m.TotalMinted)
		copy(dAtA[i:], m.TotalMinted)
		i = encodeVarintParams(dAtA, i, uint64(len(m.TotalMinted)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.CurrentTotalSupply) > 0 {
		i -= len(m.CurrentTotalSupply)
		copy(dAtA[i:], m.CurrentTotalSupply)
		i = encodeVarintParams(dAtA, i, uint64(len(m.CurrentTotalSupply)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.TotalSupplyCap) > 0 {
		i -= len(m.TotalSupplyCap)
		copy(dAtA[i:], m.TotalSupplyCap)
		i = encodeVarintParams(dAtA, i, uint64(len(m.TotalSupplyCap)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintParams(dAtA []byte, offset int, v uint64) int {
	offset -= sovParams(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *TokenomicsParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.TotalSupplyCap.Size()
	n += 1 + l + sovParams(uint64(l))
	l = m.CurrentTotalSupply.Size()
	n += 1 + l + sovParams(uint64(l))
	l = m.TotalMinted.Size()
	n += 1 + l + sovParams(uint64(l))
	l = m.TotalBurned.Size()
	n += 1 + l + sovParams(uint64(l))
	l = m.InflationRate.Size()
	n += 1 + l + sovParams(uint64(l))
	l = m.InflationMin.Size()
	n += 1 + l + sovParams(uint64(l))
	l = m.InflationMax.Size()
	n += 1 + l + sovParams(uint64(l))
	l = m.EmissionSplitStaking.Size()
	n += 1 + l + sovParams(uint64(l))
	l = m.EmissionSplitPoc.Size()
	n += 1 + l + sovParams(uint64(l))
	l = m.EmissionSplitSequencer.Size()
	n += 1 + l + sovParams(uint64(l))
	l = m.EmissionSplitTreasury.Size()
	n += 1 + l + sovParams(uint64(l))
	l = m.BurnRatePosGas.Size()
	n += 1 + l + sovParams(uint64(l))
	l = m.BurnRatePocAnchoring.Size()
	n += 1 + l + sovParams(uint64(l))
	l = m.BurnRateSequencerGas.Size()
	n += 1 + l + sovParams(uint64(l))
	l = m.BurnRateSmartContracts.Size()
	n += 1 + l + sovParams(uint64(l))
	l = m.BurnRateAiQueries.Size()
	n += 2 + l + sovParams(uint64(l))
	l = m.BurnRateMessaging.Size()
	n += 2 + l + sovParams(uint64(l))
	l = m.TreasuryBurnRedirect.Size()
	n += 2 + l + sovParams(uint64(l))
	l = m.MinGasPrice.Size()
	n += 2 + l + sovParams(uint64(l))
	l = m.GasConversionRatioContinuity.Size()
	n += 2 + l + sovParams(uint64(l))
	l = m.GasConversionRatioSequencer.Size()
	n += 2 + l + sovParams(uint64(l))
	l = m.PocAlpha.Size()
	n += 2 + l + sovParams(uint64(l))
	if m.RewardStreamInterval != 0 {
		n += 2 + sovParams(uint64(m.RewardStreamInterval))
	}
	l = len(m.ContinuityIbcChannel)
	if l > 0 {
		n += 2 + l + sovParams(uint64(l))
	}
	l = len(m.SequencerIbcChannel)
	if l > 0 {
		n += 2 + l + sovParams(uint64(l))
	}
	if m.ParamChangeDelay != 0 {
		n += 2 + sovParams(uint64(m.ParamChangeDelay))
	}
	l = m.MinProposalDeposit.Size()
	n += 2 + l + sovParams(uint64(l))
	l = m.QuorumPercentage.Size()
	n += 2 + l + sovParams(uint64(l))
	l = m.PassPercentage.Size()
	n += 2 + l + sovParams(uint64(l))
	if m.VotingPeriod != 0 {
		n += 2 + sovParams(uint64(m.VotingPeriod))
	}
	if m.FeeBurnEnabled {
		n += 3
	}
	l = m.FeeBurnRatio.Size()
	n += 2 + l + sovParams(uint64(l))
	l = m.TreasuryFeeRatio.Size()
	n += 2 + l + sovParams(uint64(l))
	if m.AdaptiveBurnEnabled {
		n += 3
	}
	l = m.MinBurnRatio.Size()
	n += 2 + l + sovParams(uint64(l))
	l = m.MaxBurnRatio.Size()
	n += 2 + l + sovParams(uint64(l))
	l = m.DefaultBurnRatio.Size()
	n += 2 + l + sovParams(uint64(l))
	l = m.BlockCongestionThreshold.Size()
	n += 2 + l + sovParams(uint64(l))
	if m.TxPerDayTarget != 0 {
		n += 2 + sovParams(uint64(m.TxPerDayTarget))
	}
	l = m.TreasuryFloorPct.Size()
	n += 2 + l + sovParams(uint64(l))
	if m.BurnAdjustmentSmoothing != 0 {
		n += 2 + sovParams(uint64(m.BurnAdjustmentSmoothing))
	}
	l = m.LastAppliedBurnRatio.Size()
	n += 2 + l + sovParams(uint64(l))
	l = len(m.LastBurnTrigger)
	if l > 0 {
		n += 2 + l + sovParams(uint64(l))
	}
	if m.EmergencyBurnOverride {
		n += 3
	}
	return n
}

func (m *DefaultTokenomicsParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TotalSupplyCap)
	if l > 0 {
		n += 1 + l + sovParams(uint64(l))
	}
	l = len(m.CurrentTotalSupply)
	if l > 0 {
		n += 1 + l + sovParams(uint64(l))
	}
	l = len(m.TotalMinted)
	if l > 0 {
		n += 1 + l + sovParams(uint64(l))
	}
	l = len(m.TotalBurned)
	if l > 0 {
		n += 1 + l + sovParams(uint64(l))
	}
	l = len(m.InflationRate)
	if l > 0 {
		n += 1 + l + sovParams(uint64(l))
	}
	l = len(m.InflationMin)
	if l > 0 {
		n += 1 + l + sovParams(uint64(l))
	}
	l = len(m.InflationMax)
	if l > 0 {
		n += 1 + l + sovParams(uint64(l))
	}
	l = len(m.EmissionSplitStaking)
	if l > 0 {
		n += 1 + l + sovParams(uint64(l))
	}
	l = len(m.EmissionSplitPoc)
	if l > 0 {
		n += 1 + l + sovParams(uint64(l))
	}
	l = len(m.EmissionSplitSequencer)
	if l > 0 {
		n += 1 + l + sovParams(uint64(l))
	}
	l = len(m.EmissionSplitTreasury)
	if l > 0 {
		n += 1 + l + sovParams(uint64(l))
	}
	l = len(m.BurnRatePosGas)
	if l > 0 {
		n += 1 + l + sovParams(uint64(l))
	}
	l = len(m.BurnRatePocAnchoring)
	if l > 0 {
		n += 1 + l + sovParams(uint64(l))
	}
	l = len(m.BurnRateSequencerGas)
	if l > 0 {
		n += 1 + l + sovParams(uint64(l))
	}
	l = len(m.BurnRateSmartContracts)
	if l > 0 {
		n += 1 + l + sovParams(uint64(l))
	}
	l = len(m.BurnRateAiQueries)
	if l > 0 {
		n += 2 + l + sovParams(uint64(l))
	}
	l = len(m.BurnRateMessaging)
	if l > 0 {
		n += 2 + l + sovParams(uint64(l))
	}
	l = len(m.TreasuryBurnRedirect)
	if l > 0 {
		n += 2 + l + sovParams(uint64(l))
	}
	l = len(m.MinGasPrice)
	if l > 0 {
		n += 2 + l + sovParams(uint64(l))
	}
	l = len(m.GasConversionRatioContinuity)
	if l > 0 {
		n += 2 + l + sovParams(uint64(l))
	}
	l = len(m.GasConversionRatioSequencer)
	if l > 0 {
		n += 2 + l + sovParams(uint64(l))
	}
	l = len(m.PocAlpha)
	if l > 0 {
		n += 2 + l + sovParams(uint64(l))
	}
	if m.RewardStreamInterval != 0 {
		n += 2 + sovParams(uint64(m.RewardStreamInterval))
	}
	l = len(m.ContinuityIbcChannel)
	if l > 0 {
		n += 2 + l + sovParams(uint64(l))
	}
	l = len(m.SequencerIbcChannel)
	if l > 0 {
		n += 2 + l + sovParams(uint64(l))
	}
	if m.ParamChangeDelay != 0 {
		n += 2 + sovParams(uint64(m.ParamChangeDelay))
	}
	l = len(m.MinProposalDeposit)
	if l > 0 {
		n += 2 + l + sovParams(uint64(l))
	}
	l = len(m.QuorumPercentage)
	if l > 0 {
		n += 2 + l + sovParams(uint64(l))
	}
	l = len(m.PassPercentage)
	if l > 0 {
		n += 2 + l + sovParams(uint64(l))
	}
	if m.VotingPeriod != 0 {
		n += 2 + sovParams(uint64(m.VotingPeriod))
	}
	if m.FeeBurnEnabled {
		n += 3
	}
	l = len(m.FeeBurnRatio)
	if l > 0 {
		n += 2 + l + sovParams(uint64(l))
	}
	l = len(m.TreasuryFeeRatio)
	if l > 0 {
		n += 2 + l + sovParams(uint64(l))
	}
	return n
}

func sovParams(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozParams(x uint64) (n int) {
	return sovParams(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *TokenomicsParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowParams
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TokenomicsParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TokenomicsParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalSupplyCap", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalSupplyCap.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentTotalSupply", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CurrentTotalSupply.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalMinted", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalMinted.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalBurned", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalBurned.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InflationRate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.InflationRate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InflationMin", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.InflationMin.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InflationMax", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.InflationMax.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EmissionSplitStaking", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.EmissionSplitStaking.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EmissionSplitPoc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.EmissionSplitPoc.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EmissionSplitSequencer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.EmissionSplitSequencer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EmissionSplitTreasury", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.EmissionSplitTreasury.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BurnRatePosGas", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.BurnRatePosGas.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BurnRatePocAnchoring", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.BurnRatePocAnchoring.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BurnRateSequencerGas", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.BurnRateSequencerGas.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BurnRateSmartContracts", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.BurnRateSmartContracts.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BurnRateAiQueries", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.BurnRateAiQueries.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BurnRateMessaging", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.BurnRateMessaging.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TreasuryBurnRedirect", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TreasuryBurnRedirect.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinGasPrice", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MinGasPrice.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GasConversionRatioContinuity", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.GasConversionRatioContinuity.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GasConversionRatioSequencer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.GasConversionRatioSequencer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PocAlpha", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PocAlpha.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardStreamInterval", wireType)
			}
			m.RewardStreamInterval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RewardStreamInterval |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContinuityIbcChannel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContinuityIbcChannel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SequencerIbcChannel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SequencerIbcChannel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 26:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParamChangeDelay", wireType)
			}
			m.ParamChangeDelay = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ParamChangeDelay |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinProposalDeposit", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MinProposalDeposit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QuorumPercentage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.QuorumPercentage.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 29:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PassPercentage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PassPercentage.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 30:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VotingPeriod", wireType)
			}
			m.VotingPeriod = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VotingPeriod |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 31:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeeBurnEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.FeeBurnEnabled = bool(v != 0)
		case 32:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeeBurnRatio", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.FeeBurnRatio.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 33:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TreasuryFeeRatio", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TreasuryFeeRatio.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 34:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdaptiveBurnEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AdaptiveBurnEnabled = bool(v != 0)
		case 35:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinBurnRatio", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MinBurnRatio.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 36:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxBurnRatio", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MaxBurnRatio.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 37:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultBurnRatio", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.DefaultBurnRatio.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 38:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockCongestionThreshold", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.BlockCongestionThreshold.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 39:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxPerDayTarget", wireType)
			}
			m.TxPerDayTarget = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TxPerDayTarget |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 40:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TreasuryFloorPct", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TreasuryFloorPct.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 41:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BurnAdjustmentSmoothing", wireType)
			}
			m.BurnAdjustmentSmoothing = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BurnAdjustmentSmoothing |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 42:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastAppliedBurnRatio", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.LastAppliedBurnRatio.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 43:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastBurnTrigger", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastBurnTrigger = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 44:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EmergencyBurnOverride", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EmergencyBurnOverride = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipParams(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthParams
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DefaultTokenomicsParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowParams
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DefaultTokenomicsParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DefaultTokenomicsParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalSupplyCap", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TotalSupplyCap = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentTotalSupply", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CurrentTotalSupply = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalMinted", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TotalMinted = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalBurned", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TotalBurned = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InflationRate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InflationRate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InflationMin", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InflationMin = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InflationMax", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InflationMax = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EmissionSplitStaking", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EmissionSplitStaking = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EmissionSplitPoc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EmissionSplitPoc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EmissionSplitSequencer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EmissionSplitSequencer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EmissionSplitTreasury", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EmissionSplitTreasury = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BurnRatePosGas", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BurnRatePosGas = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BurnRatePocAnchoring", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BurnRatePocAnchoring = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BurnRateSequencerGas", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BurnRateSequencerGas = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BurnRateSmartContracts", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BurnRateSmartContracts = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BurnRateAiQueries", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BurnRateAiQueries = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BurnRateMessaging", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BurnRateMessaging = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TreasuryBurnRedirect", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TreasuryBurnRedirect = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinGasPrice", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MinGasPrice = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GasConversionRatioContinuity", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GasConversionRatioContinuity = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GasConversionRatioSequencer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GasConversionRatioSequencer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PocAlpha", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PocAlpha = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardStreamInterval", wireType)
			}
			m.RewardStreamInterval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RewardStreamInterval |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContinuityIbcChannel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContinuityIbcChannel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SequencerIbcChannel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SequencerIbcChannel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 26:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParamChangeDelay", wireType)
			}
			m.ParamChangeDelay = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ParamChangeDelay |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinProposalDeposit", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MinProposalDeposit = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QuorumPercentage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QuorumPercentage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 29:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PassPercentage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PassPercentage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 30:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VotingPeriod", wireType)
			}
			m.VotingPeriod = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VotingPeriod |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 31:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeeBurnEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.FeeBurnEnabled = bool(v != 0)
		case 32:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeeBurnRatio", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FeeBurnRatio = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 33:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TreasuryFeeRatio", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TreasuryFeeRatio = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipParams(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthParams
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipParams(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowParams
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowParams
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowParams
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthParams
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupParams
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthParams
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthParams        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowParams          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupParams = fmt.Errorf("proto: unexpected end of group")
)
