// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: pos/timelock/v1/events.proto

package types

import (
	fmt "fmt"
	proto "github.com/cosmos/gogoproto/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// EventOperationQueued is emitted when an operation is queued
type EventOperationQueued struct {
	// operation_id is the unique identifier
	OperationId uint64 `protobuf:"varint,1,opt,name=operation_id,json=operationId,proto3" json:"operation_id,omitempty"`
	// proposal_id is the source governance proposal
	ProposalId uint64 `protobuf:"varint,2,opt,name=proposal_id,json=proposalId,proto3" json:"proposal_id,omitempty"`
	// operation_hash is the cryptographic hash (hex encoded)
	OperationHash string `protobuf:"bytes,3,opt,name=operation_hash,json=operationHash,proto3" json:"operation_hash,omitempty"`
	// executable_at_unix is when the operation becomes executable (Unix timestamp seconds)
	ExecutableAtUnix int64 `protobuf:"varint,4,opt,name=executable_at_unix,json=executableAtUnix,proto3" json:"executable_at_unix,omitempty"`
	// expires_at_unix is when the operation expires (Unix timestamp seconds)
	ExpiresAtUnix int64 `protobuf:"varint,5,opt,name=expires_at_unix,json=expiresAtUnix,proto3" json:"expires_at_unix,omitempty"`
	// message_count is the number of messages in the operation
	MessageCount uint32 `protobuf:"varint,6,opt,name=message_count,json=messageCount,proto3" json:"message_count,omitempty"`
}

func (m *EventOperationQueued) Reset()         { *m = EventOperationQueued{} }
func (m *EventOperationQueued) String() string { return proto.CompactTextString(m) }
func (*EventOperationQueued) ProtoMessage()    {}
func (*EventOperationQueued) Descriptor() ([]byte, []int) {
	return fileDescriptor_8bc519502ef1e976, []int{0}
}
func (m *EventOperationQueued) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventOperationQueued) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventOperationQueued.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventOperationQueued) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventOperationQueued.Merge(m, src)
}
func (m *EventOperationQueued) XXX_Size() int {
	return m.Size()
}
func (m *EventOperationQueued) XXX_DiscardUnknown() {
	xxx_messageInfo_EventOperationQueued.DiscardUnknown(m)
}

var xxx_messageInfo_EventOperationQueued proto.InternalMessageInfo

func (m *EventOperationQueued) GetOperationId() uint64 {
	if m != nil {
		return m.OperationId
	}
	return 0
}

func (m *EventOperationQueued) GetProposalId() uint64 {
	if m != nil {
		return m.ProposalId
	}
	return 0
}

func (m *EventOperationQueued) GetOperationHash() string {
	if m != nil {
		return m.OperationHash
	}
	return ""
}

func (m *EventOperationQueued) GetExecutableAtUnix() int64 {
	if m != nil {
		return m.ExecutableAtUnix
	}
	return 0
}

func (m *EventOperationQueued) GetExpiresAtUnix() int64 {
	if m != nil {
		return m.ExpiresAtUnix
	}
	return 0
}

func (m *EventOperationQueued) GetMessageCount() uint32 {
	if m != nil {
		return m.MessageCount
	}
	return 0
}

// EventOperationExecuted is emitted when an operation is executed
type EventOperationExecuted struct {
	// operation_id is the unique identifier
	OperationId uint64 `protobuf:"varint,1,opt,name=operation_id,json=operationId,proto3" json:"operation_id,omitempty"`
	// proposal_id is the source governance proposal
	ProposalId uint64 `protobuf:"varint,2,opt,name=proposal_id,json=proposalId,proto3" json:"proposal_id,omitempty"`
	// executor is the address that executed the operation
	Executor string `protobuf:"bytes,3,opt,name=executor,proto3" json:"executor,omitempty"`
	// success indicates if execution was successful
	Success bool `protobuf:"varint,4,opt,name=success,proto3" json:"success,omitempty"`
	// executed_at_unix is when the operation was executed (Unix timestamp seconds)
	ExecutedAtUnix int64 `protobuf:"varint,5,opt,name=executed_at_unix,json=executedAtUnix,proto3" json:"executed_at_unix,omitempty"`
}

func (m *EventOperationExecuted) Reset()         { *m = EventOperationExecuted{} }
func (m *EventOperationExecuted) String() string { return proto.CompactTextString(m) }
func (*EventOperationExecuted) ProtoMessage()    {}
func (*EventOperationExecuted) Descriptor() ([]byte, []int) {
	return fileDescriptor_8bc519502ef1e976, []int{1}
}
func (m *EventOperationExecuted) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventOperationExecuted) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventOperationExecuted.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventOperationExecuted) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventOperationExecuted.Merge(m, src)
}
func (m *EventOperationExecuted) XXX_Size() int {
	return m.Size()
}
func (m *EventOperationExecuted) XXX_DiscardUnknown() {
	xxx_messageInfo_EventOperationExecuted.DiscardUnknown(m)
}

var xxx_messageInfo_EventOperationExecuted proto.InternalMessageInfo

func (m *EventOperationExecuted) GetOperationId() uint64 {
	if m != nil {
		return m.OperationId
	}
	return 0
}

func (m *EventOperationExecuted) GetProposalId() uint64 {
	if m != nil {
		return m.ProposalId
	}
	return 0
}

func (m *EventOperationExecuted) GetExecutor() string {
	if m != nil {
		return m.Executor
	}
	return ""
}

func (m *EventOperationExecuted) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

func (m *EventOperationExecuted) GetExecutedAtUnix() int64 {
	if m != nil {
		return m.ExecutedAtUnix
	}
	return 0
}

// EventOperationCancelled is emitted when an operation is cancelled
type EventOperationCancelled struct {
	// operation_id is the unique identifier
	OperationId uint64 `protobuf:"varint,1,opt,name=operation_id,json=operationId,proto3" json:"operation_id,omitempty"`
	// proposal_id is the source governance proposal
	ProposalId uint64 `protobuf:"varint,2,opt,name=proposal_id,json=proposalId,proto3" json:"proposal_id,omitempty"`
	// canceller is the address that cancelled the operation
	Canceller string `protobuf:"bytes,3,opt,name=canceller,proto3" json:"canceller,omitempty"`
	// reason is the cancellation reason
	Reason string `protobuf:"bytes,4,opt,name=reason,proto3" json:"reason,omitempty"`
	// cancelled_at_unix is when the operation was cancelled (Unix timestamp seconds)
	CancelledAtUnix int64 `protobuf:"varint,5,opt,name=cancelled_at_unix,json=cancelledAtUnix,proto3" json:"cancelled_at_unix,omitempty"`
}

func (m *EventOperationCancelled) Reset()         { *m = EventOperationCancelled{} }
func (m *EventOperationCancelled) String() string { return proto.CompactTextString(m) }
func (*EventOperationCancelled) ProtoMessage()    {}
func (*EventOperationCancelled) Descriptor() ([]byte, []int) {
	return fileDescriptor_8bc519502ef1e976, []int{2}
}
func (m *EventOperationCancelled) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventOperationCancelled) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventOperationCancelled.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventOperationCancelled) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventOperationCancelled.Merge(m, src)
}
func (m *EventOperationCancelled) XXX_Size() int {
	return m.Size()
}
func (m *EventOperationCancelled) XXX_DiscardUnknown() {
	xxx_messageInfo_EventOperationCancelled.DiscardUnknown(m)
}

var xxx_messageInfo_EventOperationCancelled proto.InternalMessageInfo

func (m *EventOperationCancelled) GetOperationId() uint64 {
	if m != nil {
		return m.OperationId
	}
	return 0
}

func (m *EventOperationCancelled) GetProposalId() uint64 {
	if m != nil {
		return m.ProposalId
	}
	return 0
}

func (m *EventOperationCancelled) GetCanceller() string {
	if m != nil {
		return m.Canceller
	}
	return ""
}

func (m *EventOperationCancelled) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

func (m *EventOperationCancelled) GetCancelledAtUnix() int64 {
	if m != nil {
		return m.CancelledAtUnix
	}
	return 0
}

// EventOperationExpired is emitted when an operation expires
type EventOperationExpired struct {
	// operation_id is the unique identifier
	OperationId uint64 `protobuf:"varint,1,opt,name=operation_id,json=operationId,proto3" json:"operation_id,omitempty"`
	// proposal_id is the source governance proposal
	ProposalId uint64 `protobuf:"varint,2,opt,name=proposal_id,json=proposalId,proto3" json:"proposal_id,omitempty"`
	// expired_at_unix is when the operation expired (Unix timestamp seconds)
	ExpiredAtUnix int64 `protobuf:"varint,3,opt,name=expired_at_unix,json=expiredAtUnix,proto3" json:"expired_at_unix,omitempty"`
}

func (m *EventOperationExpired) Reset()         { *m = EventOperationExpired{} }
func (m *EventOperationExpired) String() string { return proto.CompactTextString(m) }
func (*EventOperationExpired) ProtoMessage()    {}
func (*EventOperationExpired) Descriptor() ([]byte, []int) {
	return fileDescriptor_8bc519502ef1e976, []int{3}
}
func (m *EventOperationExpired) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventOperationExpired) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventOperationExpired.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventOperationExpired) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventOperationExpired.Merge(m, src)
}
func (m *EventOperationExpired) XXX_Size() int {
	return m.Size()
}
func (m *EventOperationExpired) XXX_DiscardUnknown() {
	xxx_messageInfo_EventOperationExpired.DiscardUnknown(m)
}

var xxx_messageInfo_EventOperationExpired proto.InternalMessageInfo

func (m *EventOperationExpired) GetOperationId() uint64 {
	if m != nil {
		return m.OperationId
	}
	return 0
}

func (m *EventOperationExpired) GetProposalId() uint64 {
	if m != nil {
		return m.ProposalId
	}
	return 0
}

func (m *EventOperationExpired) GetExpiredAtUnix() int64 {
	if m != nil {
		return m.ExpiredAtUnix
	}
	return 0
}

// EventEmergencyExecution is emitted for emergency executions
type EventEmergencyExecution struct {
	// operation_id is the unique identifier
	OperationId uint64 `protobuf:"varint,1,opt,name=operation_id,json=operationId,proto3" json:"operation_id,omitempty"`
	// proposal_id is the source governance proposal
	ProposalId uint64 `protobuf:"varint,2,opt,name=proposal_id,json=proposalId,proto3" json:"proposal_id,omitempty"`
	// guardian is the guardian address that triggered emergency execution
	Guardian string `protobuf:"bytes,3,opt,name=guardian,proto3" json:"guardian,omitempty"`
	// justification is the reason for emergency execution
	Justification string `protobuf:"bytes,4,opt,name=justification,proto3" json:"justification,omitempty"`
	// executed_at_unix is when the operation was executed (Unix timestamp seconds)
	ExecutedAtUnix int64 `protobuf:"varint,5,opt,name=executed_at_unix,json=executedAtUnix,proto3" json:"executed_at_unix,omitempty"`
}

func (m *EventEmergencyExecution) Reset()         { *m = EventEmergencyExecution{} }
func (m *EventEmergencyExecution) String() string { return proto.CompactTextString(m) }
func (*EventEmergencyExecution) ProtoMessage()    {}
func (*EventEmergencyExecution) Descriptor() ([]byte, []int) {
	return fileDescriptor_8bc519502ef1e976, []int{4}
}
func (m *EventEmergencyExecution) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventEmergencyExecution) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventEmergencyExecution.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventEmergencyExecution) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventEmergencyExecution.Merge(m, src)
}
func (m *EventEmergencyExecution) XXX_Size() int {
	return m.Size()
}
func (m *EventEmergencyExecution) XXX_DiscardUnknown() {
	xxx_messageInfo_EventEmergencyExecution.DiscardUnknown(m)
}

var xxx_messageInfo_EventEmergencyExecution proto.InternalMessageInfo

func (m *EventEmergencyExecution) GetOperationId() uint64 {
	if m != nil {
		return m.OperationId
	}
	return 0
}

func (m *EventEmergencyExecution) GetProposalId() uint64 {
	if m != nil {
		return m.ProposalId
	}
	return 0
}

func (m *EventEmergencyExecution) GetGuardian() string {
	if m != nil {
		return m.Guardian
	}
	return ""
}

func (m *EventEmergencyExecution) GetJustification() string {
	if m != nil {
		return m.Justification
	}
	return ""
}

func (m *EventEmergencyExecution) GetExecutedAtUnix() int64 {
	if m != nil {
		return m.ExecutedAtUnix
	}
	return 0
}

// EventGuardianUpdated is emitted when the guardian is changed
type EventGuardianUpdated struct {
	// old_guardian is the previous guardian address
	OldGuardian string `protobuf:"bytes,1,opt,name=old_guardian,json=oldGuardian,proto3" json:"old_guardian,omitempty"`
	// new_guardian is the new guardian address
	NewGuardian string `protobuf:"bytes,2,opt,name=new_guardian,json=newGuardian,proto3" json:"new_guardian,omitempty"`
}

func (m *EventGuardianUpdated) Reset()         { *m = EventGuardianUpdated{} }
func (m *EventGuardianUpdated) String() string { return proto.CompactTextString(m) }
func (*EventGuardianUpdated) ProtoMessage()    {}
func (*EventGuardianUpdated) Descriptor() ([]byte, []int) {
	return fileDescriptor_8bc519502ef1e976, []int{5}
}
func (m *EventGuardianUpdated) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventGuardianUpdated) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventGuardianUpdated.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventGuardianUpdated) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventGuardianUpdated.Merge(m, src)
}
func (m *EventGuardianUpdated) XXX_Size() int {
	return m.Size()
}
func (m *EventGuardianUpdated) XXX_DiscardUnknown() {
	xxx_messageInfo_EventGuardianUpdated.DiscardUnknown(m)
}

var xxx_messageInfo_EventGuardianUpdated proto.InternalMessageInfo

func (m *EventGuardianUpdated) GetOldGuardian() string {
	if m != nil {
		return m.OldGuardian
	}
	return ""
}

func (m *EventGuardianUpdated) GetNewGuardian() string {
	if m != nil {
		return m.NewGuardian
	}
	return ""
}

// EventParamsUpdated is emitted when module parameters are updated
type EventParamsUpdated struct {
	// old_min_delay_seconds is the previous minimum delay in seconds
	OldMinDelaySeconds uint64 `protobuf:"varint,1,opt,name=old_min_delay_seconds,json=oldMinDelaySeconds,proto3" json:"old_min_delay_seconds,omitempty"`
	// new_min_delay_seconds is the new minimum delay in seconds
	NewMinDelaySeconds uint64 `protobuf:"varint,2,opt,name=new_min_delay_seconds,json=newMinDelaySeconds,proto3" json:"new_min_delay_seconds,omitempty"`
}

func (m *EventParamsUpdated) Reset()         { *m = EventParamsUpdated{} }
func (m *EventParamsUpdated) String() string { return proto.CompactTextString(m) }
func (*EventParamsUpdated) ProtoMessage()    {}
func (*EventParamsUpdated) Descriptor() ([]byte, []int) {
	return fileDescriptor_8bc519502ef1e976, []int{6}
}
func (m *EventParamsUpdated) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventParamsUpdated) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventParamsUpdated.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventParamsUpdated) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventParamsUpdated.Merge(m, src)
}
func (m *EventParamsUpdated) XXX_Size() int {
	return m.Size()
}
func (m *EventParamsUpdated) XXX_DiscardUnknown() {
	xxx_messageInfo_EventParamsUpdated.DiscardUnknown(m)
}

var xxx_messageInfo_EventParamsUpdated proto.InternalMessageInfo

func (m *EventParamsUpdated) GetOldMinDelaySeconds() uint64 {
	if m != nil {
		return m.OldMinDelaySeconds
	}
	return 0
}

func (m *EventParamsUpdated) GetNewMinDelaySeconds() uint64 {
	if m != nil {
		return m.NewMinDelaySeconds
	}
	return 0
}

func init() {
	proto.RegisterType((*EventOperationQueued)(nil), "pos.timelock.v1.EventOperationQueued")
	proto.RegisterType((*EventOperationExecuted)(nil), "pos.timelock.v1.EventOperationExecuted")
	proto.RegisterType((*EventOperationCancelled)(nil), "pos.timelock.v1.EventOperationCancelled")
	proto.RegisterType((*EventOperationExpired)(nil), "pos.timelock.v1.EventOperationExpired")
	proto.RegisterType((*EventEmergencyExecution)(nil), "pos.timelock.v1.EventEmergencyExecution")
	proto.RegisterType((*EventGuardianUpdated)(nil), "pos.timelock.v1.EventGuardianUpdated")
	proto.RegisterType((*EventParamsUpdated)(nil), "pos.timelock.v1.EventParamsUpdated")
}

func init() { proto.RegisterFile("pos/timelock/v1/events.proto", fileDescriptor_8bc519502ef1e976) }

var fileDescriptor_8bc519502ef1e976 = []byte{
	// 549 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x54, 0x4d, 0x6f, 0xd3, 0x40,
	0x10, 0xed, 0xb6, 0x25, 0x34, 0x93, 0xa6, 0x81, 0x55, 0x5b, 0x22, 0x54, 0x99, 0x10, 0x3e, 0x14,
	0x21, 0x94, 0x28, 0xe2, 0x17, 0x40, 0x89, 0xa0, 0x07, 0x04, 0x18, 0xf5, 0x82, 0x90, 0xac, 0xad,
	0x77, 0x48, 0x16, 0x9c, 0x5d, 0xcb, 0x6b, 0xe7, 0x83, 0x2b, 0x7f, 0x80, 0x1f, 0x84, 0xc4, 0x15,
	0x6e, 0x3d, 0x72, 0x44, 0xc9, 0xdf, 0xe0, 0x80, 0x6c, 0xef, 0xda, 0x24, 0x9c, 0x90, 0x72, 0xdc,
	0x37, 0x6f, 0x67, 0xde, 0x1b, 0x3f, 0x2f, 0x9c, 0x84, 0x4a, 0xf7, 0x62, 0x31, 0xc6, 0x40, 0xf9,
	0x1f, 0x7b, 0x93, 0x7e, 0x0f, 0x27, 0x28, 0x63, 0xdd, 0x0d, 0x23, 0x15, 0x2b, 0xda, 0x08, 0x95,
	0xee, 0xda, 0x6a, 0x77, 0xd2, 0x6f, 0xff, 0x26, 0x70, 0x38, 0x48, 0x19, 0x2f, 0x43, 0x8c, 0x58,
	0x2c, 0x94, 0x7c, 0x9d, 0x60, 0x82, 0x9c, 0xde, 0x86, 0x7d, 0x65, 0x21, 0x4f, 0xf0, 0x26, 0x69,
	0x91, 0xce, 0xae, 0x5b, 0x2b, 0xb0, 0x33, 0x4e, 0x6f, 0x41, 0x2d, 0x8c, 0x54, 0xa8, 0x34, 0x0b,
	0x52, 0xc6, 0x76, 0xc6, 0x00, 0x0b, 0x9d, 0x71, 0x7a, 0x0f, 0x0e, 0xca, 0x1e, 0x23, 0xa6, 0x47,
	0xcd, 0x9d, 0x16, 0xe9, 0x54, 0xdd, 0x7a, 0x81, 0x3e, 0x67, 0x7a, 0x44, 0x1f, 0x02, 0xc5, 0x19,
	0xfa, 0x49, 0xcc, 0x2e, 0x02, 0xf4, 0x58, 0xec, 0x25, 0x52, 0xcc, 0x9a, 0xbb, 0x2d, 0xd2, 0xd9,
	0x71, 0xaf, 0x95, 0x95, 0xc7, 0xf1, 0xb9, 0x14, 0x33, 0x7a, 0x1f, 0x1a, 0x38, 0x0b, 0x45, 0x84,
	0xba, 0xa0, 0x5e, 0xc9, 0xa8, 0x75, 0x03, 0x1b, 0xde, 0x1d, 0xa8, 0x8f, 0x51, 0x6b, 0x36, 0x44,
	0xcf, 0x57, 0x89, 0x8c, 0x9b, 0x95, 0x16, 0xe9, 0xd4, 0xdd, 0x7d, 0x03, 0x9e, 0xa6, 0x58, 0xfb,
	0x2b, 0x81, 0xe3, 0x55, 0xfb, 0x83, 0x6c, 0xde, 0x86, 0x16, 0x70, 0x13, 0xf6, 0x72, 0xfd, 0x2a,
	0x32, 0xd6, 0x8b, 0x33, 0x6d, 0xc2, 0x55, 0x9d, 0xf8, 0x3e, 0x6a, 0x9d, 0x59, 0xdd, 0x73, 0xed,
	0x91, 0x76, 0xc0, 0xb8, 0x46, 0xbe, 0x66, 0xf1, 0xc0, 0xe2, 0xb9, 0xc7, 0xf6, 0x37, 0x02, 0x37,
	0x56, 0xe5, 0x9f, 0x32, 0xe9, 0x63, 0x10, 0x6c, 0x48, 0xff, 0x09, 0x54, 0x7d, 0xd3, 0xd0, 0x1a,
	0x28, 0x01, 0x7a, 0x0c, 0x95, 0x08, 0x99, 0x56, 0x32, 0x33, 0x50, 0x75, 0xcd, 0x89, 0x3e, 0x80,
	0xeb, 0x96, 0xb4, 0x6e, 0xa0, 0x51, 0x14, 0x8c, 0x83, 0xcf, 0x04, 0x8e, 0xd6, 0x3f, 0x40, 0xfa,
	0x15, 0x37, 0xa3, 0xbf, 0xc8, 0x4a, 0xa9, 0x63, 0xe7, 0xef, 0xac, 0x58, 0x15, 0x3f, 0xec, 0x1e,
	0x07, 0x63, 0x8c, 0x86, 0x28, 0xfd, 0x79, 0x1e, 0x03, 0xa1, 0xe4, 0xa6, 0x72, 0x30, 0x4c, 0x58,
	0xc4, 0x05, 0x93, 0x36, 0x07, 0xf6, 0x4c, 0xef, 0x42, 0xfd, 0x43, 0xa2, 0x63, 0xf1, 0x5e, 0xf8,
	0x59, 0x3f, 0xb3, 0xcc, 0x55, 0xf0, 0x3f, 0x32, 0xf1, 0xce, 0xfc, 0xd0, 0xcf, 0xcc, 0x80, 0xf3,
	0x90, 0x33, 0x9b, 0xe7, 0x80, 0x7b, 0x85, 0x0e, 0x92, 0x8d, 0xa9, 0xa9, 0x80, 0x5b, 0x66, 0x4a,
	0x91, 0x38, 0x2d, 0x29, 0xdb, 0x39, 0x45, 0xe2, 0xd4, 0x52, 0xda, 0x9f, 0x80, 0x66, 0xdd, 0x5f,
	0xb1, 0x88, 0x8d, 0xb5, 0xed, 0xdd, 0x87, 0xa3, 0xb4, 0xf7, 0x58, 0x48, 0x8f, 0x63, 0xc0, 0xe6,
	0x9e, 0x46, 0x5f, 0x49, 0xae, 0xcd, 0xb2, 0xa8, 0x0a, 0xf8, 0x0b, 0x21, 0x9f, 0xa6, 0xa5, 0x37,
	0x79, 0x25, 0xbd, 0x92, 0xce, 0xfa, 0xf7, 0x4a, 0xbe, 0x3d, 0x2a, 0x71, 0xba, 0x76, 0xe5, 0x49,
	0xf7, 0xfb, 0xc2, 0x21, 0x97, 0x0b, 0x87, 0xfc, 0x5a, 0x38, 0xe4, 0xcb, 0xd2, 0xd9, 0xba, 0x5c,
	0x3a, 0x5b, 0x3f, 0x97, 0xce, 0xd6, 0xdb, 0xc3, 0xf4, 0xd1, 0x9b, 0x95, 0xcf, 0x5e, 0x3c, 0x0f,
	0x51, 0x5f, 0x54, 0xb2, 0x37, 0xef, 0xd1, 0x9f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x65, 0x96, 0x4f,
	0x51, 0x13, 0x05, 0x00, 0x00,
}

func (m *EventOperationQueued) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventOperationQueued) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventOperationQueued) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MessageCount != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.MessageCount))
		i--
		dAtA[i] = 0x30
	}
	if m.ExpiresAtUnix != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.ExpiresAtUnix))
		i--
		dAtA[i] = 0x28
	}
	if m.ExecutableAtUnix != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.ExecutableAtUnix))
		i--
		dAtA[i] = 0x20
	}
	if len(m.OperationHash) > 0 {
		i -= len(m.OperationHash)
		copy(dAtA[i:], m.OperationHash)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.OperationHash)))
		i--
		dAtA[i] = 0x1a
	}
	if m.ProposalId != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.ProposalId))
		i--
		dAtA[i] = 0x10
	}
	if m.OperationId != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.OperationId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EventOperationExecuted) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventOperationExecuted) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventOperationExecuted) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ExecutedAtUnix != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.ExecutedAtUnix))
		i--
		dAtA[i] = 0x28
	}
	if m.Success {
		i--
		if m.Success {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.Executor) > 0 {
		i -= len(m.Executor)
		copy(dAtA[i:], m.Executor)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Executor)))
		i--
		dAtA[i] = 0x1a
	}
	if m.ProposalId != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.ProposalId))
		i--
		dAtA[i] = 0x10
	}
	if m.OperationId != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.OperationId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EventOperationCancelled) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventOperationCancelled) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventOperationCancelled) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CancelledAtUnix != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.CancelledAtUnix))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Reason) > 0 {
		i -= len(m.Reason)
		copy(dAtA[i:], m.Reason)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Reason)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Canceller) > 0 {
		i -= len(m.Canceller)
		copy(dAtA[i:], m.Canceller)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Canceller)))
		i--
		dAtA[i] = 0x1a
	}
	if m.ProposalId != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.ProposalId))
		i--
		dAtA[i] = 0x10
	}
	if m.OperationId != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.OperationId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EventOperationExpired) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventOperationExpired) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventOperationExpired) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ExpiredAtUnix != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.ExpiredAtUnix))
		i--
		dAtA[i] = 0x18
	}
	if m.ProposalId != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.ProposalId))
		i--
		dAtA[i] = 0x10
	}
	if m.OperationId != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.OperationId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EventEmergencyExecution) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventEmergencyExecution) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventEmergencyExecution) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ExecutedAtUnix != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.ExecutedAtUnix))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Justification) > 0 {
		i -= len(m.Justification)
		copy(dAtA[i:], m.Justification)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Justification)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Guardian) > 0 {
		i -= len(m.Guardian)
		copy(dAtA[i:], m.Guardian)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Guardian)))
		i--
		dAtA[i] = 0x1a
	}
	if m.ProposalId != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.ProposalId))
		i--
		dAtA[i] = 0x10
	}
	if m.OperationId != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.OperationId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EventGuardianUpdated) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventGuardianUpdated) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventGuardianUpdated) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.NewGuardian) > 0 {
		i -= len(m.NewGuardian)
		copy(dAtA[i:], m.NewGuardian)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.NewGuardian)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.OldGuardian) > 0 {
		i -= len(m.OldGuardian)
		copy(dAtA[i:], m.OldGuardian)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.OldGuardian)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventParamsUpdated) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventParamsUpdated) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventParamsUpdated) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NewMinDelaySeconds != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.NewMinDelaySeconds))
		i--
		dAtA[i] = 0x10
	}
	if m.OldMinDelaySeconds != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.OldMinDelaySeconds))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintEvents(dAtA []byte, offset int, v uint64) int {
	offset -= sovEvents(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *EventOperationQueued) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OperationId != 0 {
		n += 1 + sovEvents(uint64(m.OperationId))
	}
	if m.ProposalId != 0 {
		n += 1 + sovEvents(uint64(m.ProposalId))
	}
	l = len(m.OperationHash)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.ExecutableAtUnix != 0 {
		n += 1 + sovEvents(uint64(m.ExecutableAtUnix))
	}
	if m.ExpiresAtUnix != 0 {
		n += 1 + sovEvents(uint64(m.ExpiresAtUnix))
	}
	if m.MessageCount != 0 {
		n += 1 + sovEvents(uint64(m.MessageCount))
	}
	return n
}

func (m *EventOperationExecuted) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OperationId != 0 {
		n += 1 + sovEvents(uint64(m.OperationId))
	}
	if m.ProposalId != 0 {
		n += 1 + sovEvents(uint64(m.ProposalId))
	}
	l = len(m.Executor)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.Success {
		n += 2
	}
	if m.ExecutedAtUnix != 0 {
		n += 1 + sovEvents(uint64(m.ExecutedAtUnix))
	}
	return n
}

func (m *EventOperationCancelled) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OperationId != 0 {
		n += 1 + sovEvents(uint64(m.OperationId))
	}
	if m.ProposalId != 0 {
		n += 1 + sovEvents(uint64(m.ProposalId))
	}
	l = len(m.Canceller)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.CancelledAtUnix != 0 {
		n += 1 + sovEvents(uint64(m.CancelledAtUnix))
	}
	return n
}

func (m *EventOperationExpired) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OperationId != 0 {
		n += 1 + sovEvents(uint64(m.OperationId))
	}
	if m.ProposalId != 0 {
		n += 1 + sovEvents(uint64(m.ProposalId))
	}
	if m.ExpiredAtUnix != 0 {
		n += 1 + sovEvents(uint64(m.ExpiredAtUnix))
	}
	return n
}

func (m *EventEmergencyExecution) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OperationId != 0 {
		n += 1 + sovEvents(uint64(m.OperationId))
	}
	if m.ProposalId != 0 {
		n += 1 + sovEvents(uint64(m.ProposalId))
	}
	l = len(m.Guardian)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.Justification)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.ExecutedAtUnix != 0 {
		n += 1 + sovEvents(uint64(m.ExecutedAtUnix))
	}
	return n
}

func (m *EventGuardianUpdated) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.OldGuardian)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.NewGuardian)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *EventParamsUpdated) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OldMinDelaySeconds != 0 {
		n += 1 + sovEvents(uint64(m.OldMinDelaySeconds))
	}
	if m.NewMinDelaySeconds != 0 {
		n += 1 + sovEvents(uint64(m.NewMinDelaySeconds))
	}
	return n
}

func sovEvents(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozEvents(x uint64) (n int) {
	return sovEvents(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *EventOperationQueued) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventOperationQueued: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventOperationQueued: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperationId", wireType)
			}
			m.OperationId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OperationId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProposalId", wireType)
			}
			m.ProposalId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProposalId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperationHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OperationHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExecutableAtUnix", wireType)
			}
			m.ExecutableAtUnix = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExecutableAtUnix |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpiresAtUnix", wireType)
			}
			m.ExpiresAtUnix = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpiresAtUnix |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageCount", wireType)
			}
			m.MessageCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MessageCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventOperationExecuted) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventOperationExecuted: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventOperationExecuted: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperationId", wireType)
			}
			m.OperationId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OperationId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProposalId", wireType)
			}
			m.ProposalId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProposalId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Executor", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Executor = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Success", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Success = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExecutedAtUnix", wireType)
			}
			m.ExecutedAtUnix = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExecutedAtUnix |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventOperationCancelled) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventOperationCancelled: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventOperationCancelled: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperationId", wireType)
			}
			m.OperationId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OperationId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProposalId", wireType)
			}
			m.ProposalId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProposalId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Canceller", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Canceller = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CancelledAtUnix", wireType)
			}
			m.CancelledAtUnix = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CancelledAtUnix |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventOperationExpired) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventOperationExpired: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventOperationExpired: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperationId", wireType)
			}
			m.OperationId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OperationId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProposalId", wireType)
			}
			m.ProposalId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProposalId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpiredAtUnix", wireType)
			}
			m.ExpiredAtUnix = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpiredAtUnix |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventEmergencyExecution) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventEmergencyExecution: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventEmergencyExecution: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperationId", wireType)
			}
			m.OperationId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OperationId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProposalId", wireType)
			}
			m.ProposalId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProposalId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Guardian", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Guardian = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Justification", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Justification = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExecutedAtUnix", wireType)
			}
			m.ExecutedAtUnix = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExecutedAtUnix |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventGuardianUpdated) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventGuardianUpdated: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventGuardianUpdated: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OldGuardian", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OldGuardian = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewGuardian", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewGuardian = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventParamsUpdated) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventParamsUpdated: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventParamsUpdated: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OldMinDelaySeconds", wireType)
			}
			m.OldMinDelaySeconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OldMinDelaySeconds |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewMinDelaySeconds", wireType)
			}
			m.NewMinDelaySeconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NewMinDelaySeconds |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipEvents(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthEvents
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupEvents
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthEvents
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthEvents        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowEvents          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupEvents = fmt.Errorf("proto: unexpected end of group")
)
