// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: pos/tokenomics/v1/events.proto

package types

import (
	cosmossdk_io_math "cosmossdk.io/math"
	fmt "fmt"
	_ "github.com/cosmos/cosmos-proto"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// EventMint is emitted when new tokens are minted
// Indexed for transparency and audit trails
type EventMint struct {
	// authority is the address that authorized minting
	Authority string `protobuf:"bytes,1,opt,name=authority,proto3" json:"authority,omitempty"`
	// amount is the minted amount in micro-OMNI
	Amount cosmossdk_io_math.Int `protobuf:"bytes,2,opt,name=amount,proto3,customtype=cosmossdk.io/math.Int" json:"amount"`
	// recipient is the address receiving the minted tokens
	Recipient string `protobuf:"bytes,3,opt,name=recipient,proto3" json:"recipient,omitempty"`
	// reason explains why tokens were minted
	Reason string `protobuf:"bytes,4,opt,name=reason,proto3" json:"reason,omitempty"`
	// new_total_supply is the total supply after minting
	NewTotalSupply cosmossdk_io_math.Int `protobuf:"bytes,5,opt,name=new_total_supply,json=newTotalSupply,proto3,customtype=cosmossdk.io/math.Int" json:"new_total_supply"`
	// new_total_minted is the cumulative minted amount
	NewTotalMinted cosmossdk_io_math.Int `protobuf:"bytes,6,opt,name=new_total_minted,json=newTotalMinted,proto3,customtype=cosmossdk.io/math.Int" json:"new_total_minted"`
	// remaining_mintable is how much can still be minted before cap
	RemainingMintable cosmossdk_io_math.Int `protobuf:"bytes,7,opt,name=remaining_mintable,json=remainingMintable,proto3,customtype=cosmossdk.io/math.Int" json:"remaining_mintable"`
	// block_height is when the mint occurred
	BlockHeight int64 `protobuf:"varint,8,opt,name=block_height,json=blockHeight,proto3" json:"block_height,omitempty"`
	// block_time is the timestamp of the mint
	BlockTime int64 `protobuf:"varint,9,opt,name=block_time,json=blockTime,proto3" json:"block_time,omitempty"`
}

func (m *EventMint) Reset()         { *m = EventMint{} }
func (m *EventMint) String() string { return proto.CompactTextString(m) }
func (*EventMint) ProtoMessage()    {}
func (*EventMint) Descriptor() ([]byte, []int) {
	return fileDescriptor_f82839906ff59fd3, []int{0}
}
func (m *EventMint) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventMint) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventMint.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventMint) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventMint.Merge(m, src)
}
func (m *EventMint) XXX_Size() int {
	return m.Size()
}
func (m *EventMint) XXX_DiscardUnknown() {
	xxx_messageInfo_EventMint.DiscardUnknown(m)
}

var xxx_messageInfo_EventMint proto.InternalMessageInfo

func (m *EventMint) GetAuthority() string {
	if m != nil {
		return m.Authority
	}
	return ""
}

func (m *EventMint) GetRecipient() string {
	if m != nil {
		return m.Recipient
	}
	return ""
}

func (m *EventMint) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

func (m *EventMint) GetBlockHeight() int64 {
	if m != nil {
		return m.BlockHeight
	}
	return 0
}

func (m *EventMint) GetBlockTime() int64 {
	if m != nil {
		return m.BlockTime
	}
	return 0
}

// EventBurn is emitted when tokens are burned
// Indexed for transparency and deflation tracking
type EventBurn struct {
	// burner is the address that burned the tokens
	Burner string `protobuf:"bytes,1,opt,name=burner,proto3" json:"burner,omitempty"`
	// amount is the total amount submitted for burning
	Amount cosmossdk_io_math.Int `protobuf:"bytes,2,opt,name=amount,proto3,customtype=cosmossdk.io/math.Int" json:"amount"`
	// amount_burned is the actual amount burned (after treasury redirect)
	AmountBurned cosmossdk_io_math.Int `protobuf:"bytes,3,opt,name=amount_burned,json=amountBurned,proto3,customtype=cosmossdk.io/math.Int" json:"amount_burned"`
	// amount_to_treasury is the amount redirected to treasury
	AmountToTreasury cosmossdk_io_math.Int `protobuf:"bytes,4,opt,name=amount_to_treasury,json=amountToTreasury,proto3,customtype=cosmossdk.io/math.Int" json:"amount_to_treasury"`
	// source identifies the burn source
	Source BurnSource `protobuf:"varint,5,opt,name=source,proto3,enum=pos.tokenomics.v1.BurnSource" json:"source,omitempty"`
	// chain_id is where the burn occurred
	ChainId string `protobuf:"bytes,6,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	// new_total_supply is the total supply after burning
	NewTotalSupply cosmossdk_io_math.Int `protobuf:"bytes,7,opt,name=new_total_supply,json=newTotalSupply,proto3,customtype=cosmossdk.io/math.Int" json:"new_total_supply"`
	// new_total_burned is the cumulative burned amount
	NewTotalBurned cosmossdk_io_math.Int `protobuf:"bytes,8,opt,name=new_total_burned,json=newTotalBurned,proto3,customtype=cosmossdk.io/math.Int" json:"new_total_burned"`
	// block_height is when the burn occurred
	BlockHeight int64 `protobuf:"varint,9,opt,name=block_height,json=blockHeight,proto3" json:"block_height,omitempty"`
	// block_time is the timestamp of the burn
	BlockTime int64 `protobuf:"varint,10,opt,name=block_time,json=blockTime,proto3" json:"block_time,omitempty"`
	// tx_hash is the transaction hash
	TxHash string `protobuf:"bytes,11,opt,name=tx_hash,json=txHash,proto3" json:"tx_hash,omitempty"`
}

func (m *EventBurn) Reset()         { *m = EventBurn{} }
func (m *EventBurn) String() string { return proto.CompactTextString(m) }
func (*EventBurn) ProtoMessage()    {}
func (*EventBurn) Descriptor() ([]byte, []int) {
	return fileDescriptor_f82839906ff59fd3, []int{1}
}
func (m *EventBurn) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventBurn) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventBurn.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventBurn) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventBurn.Merge(m, src)
}
func (m *EventBurn) XXX_Size() int {
	return m.Size()
}
func (m *EventBurn) XXX_DiscardUnknown() {
	xxx_messageInfo_EventBurn.DiscardUnknown(m)
}

var xxx_messageInfo_EventBurn proto.InternalMessageInfo

func (m *EventBurn) GetBurner() string {
	if m != nil {
		return m.Burner
	}
	return ""
}

func (m *EventBurn) GetSource() BurnSource {
	if m != nil {
		return m.Source
	}
	return BurnSource_BURN_SOURCE_UNSPECIFIED
}

func (m *EventBurn) GetChainId() string {
	if m != nil {
		return m.ChainId
	}
	return ""
}

func (m *EventBurn) GetBlockHeight() int64 {
	if m != nil {
		return m.BlockHeight
	}
	return 0
}

func (m *EventBurn) GetBlockTime() int64 {
	if m != nil {
		return m.BlockTime
	}
	return 0
}

func (m *EventBurn) GetTxHash() string {
	if m != nil {
		return m.TxHash
	}
	return ""
}

// EventDistributeRewards is emitted when inflation rewards are distributed
// Tracks emission splits across staking, PoC, sequencer, and treasury
type EventDistributeRewards struct {
	// authority is the inflation module address
	Authority string `protobuf:"bytes,1,opt,name=authority,proto3" json:"authority,omitempty"`
	// total_rewards is the total amount distributed
	TotalRewards cosmossdk_io_math.Int `protobuf:"bytes,2,opt,name=total_rewards,json=totalRewards,proto3,customtype=cosmossdk.io/math.Int" json:"total_rewards"`
	// to_staking is the amount sent to PoS validators
	ToStaking cosmossdk_io_math.Int `protobuf:"bytes,3,opt,name=to_staking,json=toStaking,proto3,customtype=cosmossdk.io/math.Int" json:"to_staking"`
	// to_poc is the amount sent to PoC contributors
	ToPoc cosmossdk_io_math.Int `protobuf:"bytes,4,opt,name=to_poc,json=toPoc,proto3,customtype=cosmossdk.io/math.Int" json:"to_poc"`
	// to_sequencer is the amount sent to sequencer operators
	ToSequencer cosmossdk_io_math.Int `protobuf:"bytes,5,opt,name=to_sequencer,json=toSequencer,proto3,customtype=cosmossdk.io/math.Int" json:"to_sequencer"`
	// to_treasury is the amount sent to DAO treasury
	ToTreasury cosmossdk_io_math.Int `protobuf:"bytes,6,opt,name=to_treasury,json=toTreasury,proto3,customtype=cosmossdk.io/math.Int" json:"to_treasury"`
	// local_distributed is the amount distributed on local chain
	LocalDistributed cosmossdk_io_math.Int `protobuf:"bytes,7,opt,name=local_distributed,json=localDistributed,proto3,customtype=cosmossdk.io/math.Int" json:"local_distributed"`
	// ibc_distributed is the amount sent via IBC
	IbcDistributed cosmossdk_io_math.Int `protobuf:"bytes,8,opt,name=ibc_distributed,json=ibcDistributed,proto3,customtype=cosmossdk.io/math.Int" json:"ibc_distributed"`
	// ibc_packets_sent is the number of IBC packets sent
	IbcPacketsSent uint32 `protobuf:"varint,9,opt,name=ibc_packets_sent,json=ibcPacketsSent,proto3" json:"ibc_packets_sent,omitempty"`
	// block_height is when the distribution occurred
	BlockHeight int64 `protobuf:"varint,10,opt,name=block_height,json=blockHeight,proto3" json:"block_height,omitempty"`
	// block_time is the timestamp of the distribution
	BlockTime int64 `protobuf:"varint,11,opt,name=block_time,json=blockTime,proto3" json:"block_time,omitempty"`
}

func (m *EventDistributeRewards) Reset()         { *m = EventDistributeRewards{} }
func (m *EventDistributeRewards) String() string { return proto.CompactTextString(m) }
func (*EventDistributeRewards) ProtoMessage()    {}
func (*EventDistributeRewards) Descriptor() ([]byte, []int) {
	return fileDescriptor_f82839906ff59fd3, []int{2}
}
func (m *EventDistributeRewards) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventDistributeRewards) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventDistributeRewards.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventDistributeRewards) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventDistributeRewards.Merge(m, src)
}
func (m *EventDistributeRewards) XXX_Size() int {
	return m.Size()
}
func (m *EventDistributeRewards) XXX_DiscardUnknown() {
	xxx_messageInfo_EventDistributeRewards.DiscardUnknown(m)
}

var xxx_messageInfo_EventDistributeRewards proto.InternalMessageInfo

func (m *EventDistributeRewards) GetAuthority() string {
	if m != nil {
		return m.Authority
	}
	return ""
}

func (m *EventDistributeRewards) GetIbcPacketsSent() uint32 {
	if m != nil {
		return m.IbcPacketsSent
	}
	return 0
}

func (m *EventDistributeRewards) GetBlockHeight() int64 {
	if m != nil {
		return m.BlockHeight
	}
	return 0
}

func (m *EventDistributeRewards) GetBlockTime() int64 {
	if m != nil {
		return m.BlockTime
	}
	return 0
}

// EventReportBurn is emitted when a burn is reported from another chain
// Enables cross-chain burn tracking for supply accounting
type EventReportBurn struct {
	// reporter is the IBC relayer address
	Reporter string `protobuf:"bytes,1,opt,name=reporter,proto3" json:"reporter,omitempty"`
	// source_chain_id is where the burn occurred
	SourceChainId string `protobuf:"bytes,2,opt,name=source_chain_id,json=sourceChainId,proto3" json:"source_chain_id,omitempty"`
	// amount is the burned amount
	Amount cosmossdk_io_math.Int `protobuf:"bytes,3,opt,name=amount,proto3,customtype=cosmossdk.io/math.Int" json:"amount"`
	// source is the burn source type
	Source BurnSource `protobuf:"varint,4,opt,name=source,proto3,enum=pos.tokenomics.v1.BurnSource" json:"source,omitempty"`
	// source_block_height is the height on source chain
	SourceBlockHeight int64 `protobuf:"varint,5,opt,name=source_block_height,json=sourceBlockHeight,proto3" json:"source_block_height,omitempty"`
	// source_tx_hash is the transaction hash on source chain
	SourceTxHash string `protobuf:"bytes,6,opt,name=source_tx_hash,json=sourceTxHash,proto3" json:"source_tx_hash,omitempty"`
	// recorded is true if burn was successfully recorded
	Recorded bool `protobuf:"varint,7,opt,name=recorded,proto3" json:"recorded,omitempty"`
	// new_total_burned is the updated global burn counter
	NewTotalBurned cosmossdk_io_math.Int `protobuf:"bytes,8,opt,name=new_total_burned,json=newTotalBurned,proto3,customtype=cosmossdk.io/math.Int" json:"new_total_burned"`
	// block_height is when the report was received on Core chain
	BlockHeight int64 `protobuf:"varint,9,opt,name=block_height,json=blockHeight,proto3" json:"block_height,omitempty"`
	// block_time is the timestamp of the report
	BlockTime int64 `protobuf:"varint,10,opt,name=block_time,json=blockTime,proto3" json:"block_time,omitempty"`
}

func (m *EventReportBurn) Reset()         { *m = EventReportBurn{} }
func (m *EventReportBurn) String() string { return proto.CompactTextString(m) }
func (*EventReportBurn) ProtoMessage()    {}
func (*EventReportBurn) Descriptor() ([]byte, []int) {
	return fileDescriptor_f82839906ff59fd3, []int{3}
}
func (m *EventReportBurn) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventReportBurn) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventReportBurn.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventReportBurn) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventReportBurn.Merge(m, src)
}
func (m *EventReportBurn) XXX_Size() int {
	return m.Size()
}
func (m *EventReportBurn) XXX_DiscardUnknown() {
	xxx_messageInfo_EventReportBurn.DiscardUnknown(m)
}

var xxx_messageInfo_EventReportBurn proto.InternalMessageInfo

func (m *EventReportBurn) GetReporter() string {
	if m != nil {
		return m.Reporter
	}
	return ""
}

func (m *EventReportBurn) GetSourceChainId() string {
	if m != nil {
		return m.SourceChainId
	}
	return ""
}

func (m *EventReportBurn) GetSource() BurnSource {
	if m != nil {
		return m.Source
	}
	return BurnSource_BURN_SOURCE_UNSPECIFIED
}

func (m *EventReportBurn) GetSourceBlockHeight() int64 {
	if m != nil {
		return m.SourceBlockHeight
	}
	return 0
}

func (m *EventReportBurn) GetSourceTxHash() string {
	if m != nil {
		return m.SourceTxHash
	}
	return ""
}

func (m *EventReportBurn) GetRecorded() bool {
	if m != nil {
		return m.Recorded
	}
	return false
}

func (m *EventReportBurn) GetBlockHeight() int64 {
	if m != nil {
		return m.BlockHeight
	}
	return 0
}

func (m *EventReportBurn) GetBlockTime() int64 {
	if m != nil {
		return m.BlockTime
	}
	return 0
}

// EventUpdateParams is emitted when tokenomics parameters are updated via governance
// Provides audit trail for DAO parameter changes
type EventUpdateParams struct {
	// authority is the governance module address
	Authority string `protobuf:"bytes,1,opt,name=authority,proto3" json:"authority,omitempty"`
	// proposal_id is the governance proposal ID that triggered the update
	ProposalId uint64 `protobuf:"varint,2,opt,name=proposal_id,json=proposalId,proto3" json:"proposal_id,omitempty"`
	// changed_params lists the parameter names that changed
	ChangedParams []string `protobuf:"bytes,3,rep,name=changed_params,json=changedParams,proto3" json:"changed_params,omitempty"`
	// old_inflation_rate is the previous inflation rate (if changed)
	OldInflationRate cosmossdk_io_math.LegacyDec `protobuf:"bytes,4,opt,name=old_inflation_rate,json=oldInflationRate,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"old_inflation_rate"`
	// new_inflation_rate is the new inflation rate (if changed)
	NewInflationRate cosmossdk_io_math.LegacyDec `protobuf:"bytes,5,opt,name=new_inflation_rate,json=newInflationRate,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"new_inflation_rate"`
	// effective_height is when the changes take effect (with time lock)
	EffectiveHeight int64 `protobuf:"varint,6,opt,name=effective_height,json=effectiveHeight,proto3" json:"effective_height,omitempty"`
	// block_height is when the proposal passed
	BlockHeight int64 `protobuf:"varint,7,opt,name=block_height,json=blockHeight,proto3" json:"block_height,omitempty"`
	// block_time is the timestamp of the update
	BlockTime int64 `protobuf:"varint,8,opt,name=block_time,json=blockTime,proto3" json:"block_time,omitempty"`
}

func (m *EventUpdateParams) Reset()         { *m = EventUpdateParams{} }
func (m *EventUpdateParams) String() string { return proto.CompactTextString(m) }
func (*EventUpdateParams) ProtoMessage()    {}
func (*EventUpdateParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_f82839906ff59fd3, []int{4}
}
func (m *EventUpdateParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventUpdateParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventUpdateParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventUpdateParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventUpdateParams.Merge(m, src)
}
func (m *EventUpdateParams) XXX_Size() int {
	return m.Size()
}
func (m *EventUpdateParams) XXX_DiscardUnknown() {
	xxx_messageInfo_EventUpdateParams.DiscardUnknown(m)
}

var xxx_messageInfo_EventUpdateParams proto.InternalMessageInfo

func (m *EventUpdateParams) GetAuthority() string {
	if m != nil {
		return m.Authority
	}
	return ""
}

func (m *EventUpdateParams) GetProposalId() uint64 {
	if m != nil {
		return m.ProposalId
	}
	return 0
}

func (m *EventUpdateParams) GetChangedParams() []string {
	if m != nil {
		return m.ChangedParams
	}
	return nil
}

func (m *EventUpdateParams) GetEffectiveHeight() int64 {
	if m != nil {
		return m.EffectiveHeight
	}
	return 0
}

func (m *EventUpdateParams) GetBlockHeight() int64 {
	if m != nil {
		return m.BlockHeight
	}
	return 0
}

func (m *EventUpdateParams) GetBlockTime() int64 {
	if m != nil {
		return m.BlockTime
	}
	return 0
}

// EventCapReached is emitted when approaching or reaching the supply cap
// WARNING event for DAO to adjust parameters
type EventCapReached struct {
	// warning_level indicates severity (0.8 = 80% of cap, 0.9 = 90%, 1.0 = 100%)
	WarningLevel cosmossdk_io_math.LegacyDec `protobuf:"bytes,1,opt,name=warning_level,json=warningLevel,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"warning_level"`
	// current_supply is the current total supply
	CurrentSupply cosmossdk_io_math.Int `protobuf:"bytes,2,opt,name=current_supply,json=currentSupply,proto3,customtype=cosmossdk.io/math.Int" json:"current_supply"`
	// total_supply_cap is the hard maximum
	TotalSupplyCap cosmossdk_io_math.Int `protobuf:"bytes,3,opt,name=total_supply_cap,json=totalSupplyCap,proto3,customtype=cosmossdk.io/math.Int" json:"total_supply_cap"`
	// remaining_mintable is how much can still be minted
	RemainingMintable cosmossdk_io_math.Int `protobuf:"bytes,4,opt,name=remaining_mintable,json=remainingMintable,proto3,customtype=cosmossdk.io/math.Int" json:"remaining_mintable"`
	// message provides context for the warning
	Message string `protobuf:"bytes,5,opt,name=message,proto3" json:"message,omitempty"`
	// block_height is when the threshold was crossed
	BlockHeight int64 `protobuf:"varint,6,opt,name=block_height,json=blockHeight,proto3" json:"block_height,omitempty"`
	// block_time is the timestamp
	BlockTime int64 `protobuf:"varint,7,opt,name=block_time,json=blockTime,proto3" json:"block_time,omitempty"`
}

func (m *EventCapReached) Reset()         { *m = EventCapReached{} }
func (m *EventCapReached) String() string { return proto.CompactTextString(m) }
func (*EventCapReached) ProtoMessage()    {}
func (*EventCapReached) Descriptor() ([]byte, []int) {
	return fileDescriptor_f82839906ff59fd3, []int{5}
}
func (m *EventCapReached) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventCapReached) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventCapReached.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventCapReached) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventCapReached.Merge(m, src)
}
func (m *EventCapReached) XXX_Size() int {
	return m.Size()
}
func (m *EventCapReached) XXX_DiscardUnknown() {
	xxx_messageInfo_EventCapReached.DiscardUnknown(m)
}

var xxx_messageInfo_EventCapReached proto.InternalMessageInfo

func (m *EventCapReached) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *EventCapReached) GetBlockHeight() int64 {
	if m != nil {
		return m.BlockHeight
	}
	return 0
}

func (m *EventCapReached) GetBlockTime() int64 {
	if m != nil {
		return m.BlockTime
	}
	return 0
}

// EventIBCRewardSent is emitted when rewards are sent via IBC
// Tracks cross-chain reward distribution
type EventIBCRewardSent struct {
	// source_chain is the sending chain (always Core)
	SourceChain string `protobuf:"bytes,1,opt,name=source_chain,json=sourceChain,proto3" json:"source_chain,omitempty"`
	// destination_chain is the receiving chain (Continuity or Sequencer)
	DestinationChain string `protobuf:"bytes,2,opt,name=destination_chain,json=destinationChain,proto3" json:"destination_chain,omitempty"`
	// ibc_channel is the IBC channel ID
	IbcChannel string `protobuf:"bytes,3,opt,name=ibc_channel,json=ibcChannel,proto3" json:"ibc_channel,omitempty"`
	// amount is the reward amount sent
	Amount cosmossdk_io_math.Int `protobuf:"bytes,4,opt,name=amount,proto3,customtype=cosmossdk.io/math.Int" json:"amount"`
	// recipient_module is the destination module (e.g., "poc", "sequencer")
	RecipientModule string `protobuf:"bytes,5,opt,name=recipient_module,json=recipientModule,proto3" json:"recipient_module,omitempty"`
	// sequence is the IBC packet sequence number
	Sequence uint64 `protobuf:"varint,6,opt,name=sequence,proto3" json:"sequence,omitempty"`
	// timeout_height is the IBC timeout height
	TimeoutHeight int64 `protobuf:"varint,7,opt,name=timeout_height,json=timeoutHeight,proto3" json:"timeout_height,omitempty"`
	// block_height is when the IBC packet was sent
	BlockHeight int64 `protobuf:"varint,8,opt,name=block_height,json=blockHeight,proto3" json:"block_height,omitempty"`
	// block_time is the timestamp
	BlockTime int64 `protobuf:"varint,9,opt,name=block_time,json=blockTime,proto3" json:"block_time,omitempty"`
}

func (m *EventIBCRewardSent) Reset()         { *m = EventIBCRewardSent{} }
func (m *EventIBCRewardSent) String() string { return proto.CompactTextString(m) }
func (*EventIBCRewardSent) ProtoMessage()    {}
func (*EventIBCRewardSent) Descriptor() ([]byte, []int) {
	return fileDescriptor_f82839906ff59fd3, []int{6}
}
func (m *EventIBCRewardSent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventIBCRewardSent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventIBCRewardSent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventIBCRewardSent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventIBCRewardSent.Merge(m, src)
}
func (m *EventIBCRewardSent) XXX_Size() int {
	return m.Size()
}
func (m *EventIBCRewardSent) XXX_DiscardUnknown() {
	xxx_messageInfo_EventIBCRewardSent.DiscardUnknown(m)
}

var xxx_messageInfo_EventIBCRewardSent proto.InternalMessageInfo

func (m *EventIBCRewardSent) GetSourceChain() string {
	if m != nil {
		return m.SourceChain
	}
	return ""
}

func (m *EventIBCRewardSent) GetDestinationChain() string {
	if m != nil {
		return m.DestinationChain
	}
	return ""
}

func (m *EventIBCRewardSent) GetIbcChannel() string {
	if m != nil {
		return m.IbcChannel
	}
	return ""
}

func (m *EventIBCRewardSent) GetRecipientModule() string {
	if m != nil {
		return m.RecipientModule
	}
	return ""
}

func (m *EventIBCRewardSent) GetSequence() uint64 {
	if m != nil {
		return m.Sequence
	}
	return 0
}

func (m *EventIBCRewardSent) GetTimeoutHeight() int64 {
	if m != nil {
		return m.TimeoutHeight
	}
	return 0
}

func (m *EventIBCRewardSent) GetBlockHeight() int64 {
	if m != nil {
		return m.BlockHeight
	}
	return 0
}

func (m *EventIBCRewardSent) GetBlockTime() int64 {
	if m != nil {
		return m.BlockTime
	}
	return 0
}

// EventIBCRewardReceived is emitted when rewards are received via IBC
// Confirms successful cross-chain reward delivery
type EventIBCRewardReceived struct {
	// source_chain is the sending chain (Core)
	SourceChain string `protobuf:"bytes,1,opt,name=source_chain,json=sourceChain,proto3" json:"source_chain,omitempty"`
	// destination_chain is the receiving chain
	DestinationChain string `protobuf:"bytes,2,opt,name=destination_chain,json=destinationChain,proto3" json:"destination_chain,omitempty"`
	// ibc_channel is the IBC channel ID
	IbcChannel string `protobuf:"bytes,3,opt,name=ibc_channel,json=ibcChannel,proto3" json:"ibc_channel,omitempty"`
	// amount is the reward amount received
	Amount cosmossdk_io_math.Int `protobuf:"bytes,4,opt,name=amount,proto3,customtype=cosmossdk.io/math.Int" json:"amount"`
	// recipient_module is the destination module
	RecipientModule string `protobuf:"bytes,5,opt,name=recipient_module,json=recipientModule,proto3" json:"recipient_module,omitempty"`
	// sequence is the IBC packet sequence number
	Sequence uint64 `protobuf:"varint,6,opt,name=sequence,proto3" json:"sequence,omitempty"`
	// block_height is when the IBC packet was received
	BlockHeight int64 `protobuf:"varint,7,opt,name=block_height,json=blockHeight,proto3" json:"block_height,omitempty"`
	// block_time is the timestamp
	BlockTime int64 `protobuf:"varint,8,opt,name=block_time,json=blockTime,proto3" json:"block_time,omitempty"`
}

func (m *EventIBCRewardReceived) Reset()         { *m = EventIBCRewardReceived{} }
func (m *EventIBCRewardReceived) String() string { return proto.CompactTextString(m) }
func (*EventIBCRewardReceived) ProtoMessage()    {}
func (*EventIBCRewardReceived) Descriptor() ([]byte, []int) {
	return fileDescriptor_f82839906ff59fd3, []int{7}
}
func (m *EventIBCRewardReceived) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventIBCRewardReceived) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventIBCRewardReceived.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventIBCRewardReceived) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventIBCRewardReceived.Merge(m, src)
}
func (m *EventIBCRewardReceived) XXX_Size() int {
	return m.Size()
}
func (m *EventIBCRewardReceived) XXX_DiscardUnknown() {
	xxx_messageInfo_EventIBCRewardReceived.DiscardUnknown(m)
}

var xxx_messageInfo_EventIBCRewardReceived proto.InternalMessageInfo

func (m *EventIBCRewardReceived) GetSourceChain() string {
	if m != nil {
		return m.SourceChain
	}
	return ""
}

func (m *EventIBCRewardReceived) GetDestinationChain() string {
	if m != nil {
		return m.DestinationChain
	}
	return ""
}

func (m *EventIBCRewardReceived) GetIbcChannel() string {
	if m != nil {
		return m.IbcChannel
	}
	return ""
}

func (m *EventIBCRewardReceived) GetRecipientModule() string {
	if m != nil {
		return m.RecipientModule
	}
	return ""
}

func (m *EventIBCRewardReceived) GetSequence() uint64 {
	if m != nil {
		return m.Sequence
	}
	return 0
}

func (m *EventIBCRewardReceived) GetBlockHeight() int64 {
	if m != nil {
		return m.BlockHeight
	}
	return 0
}

func (m *EventIBCRewardReceived) GetBlockTime() int64 {
	if m != nil {
		return m.BlockTime
	}
	return 0
}

// EventTreasuryDeposit is emitted when treasury receives funds
// Tracks DAO treasury inflows from inflation and burn redirection
type EventTreasuryDeposit struct {
	// source is the deposit source ("inflation" or "burn_redirect")
	Source string `protobuf:"bytes,1,opt,name=source,proto3" json:"source,omitempty"`
	// amount is the deposited amount
	Amount cosmossdk_io_math.Int `protobuf:"bytes,2,opt,name=amount,proto3,customtype=cosmossdk.io/math.Int" json:"amount"`
	// treasury_address is the DAO treasury account
	TreasuryAddress string `protobuf:"bytes,3,opt,name=treasury_address,json=treasuryAddress,proto3" json:"treasury_address,omitempty"`
	// new_treasury_balance is the balance after deposit
	NewTreasuryBalance cosmossdk_io_math.Int `protobuf:"bytes,4,opt,name=new_treasury_balance,json=newTreasuryBalance,proto3,customtype=cosmossdk.io/math.Int" json:"new_treasury_balance"`
	// block_height is when the deposit occurred
	BlockHeight int64 `protobuf:"varint,5,opt,name=block_height,json=blockHeight,proto3" json:"block_height,omitempty"`
	// block_time is the timestamp
	BlockTime int64 `protobuf:"varint,6,opt,name=block_time,json=blockTime,proto3" json:"block_time,omitempty"`
}

func (m *EventTreasuryDeposit) Reset()         { *m = EventTreasuryDeposit{} }
func (m *EventTreasuryDeposit) String() string { return proto.CompactTextString(m) }
func (*EventTreasuryDeposit) ProtoMessage()    {}
func (*EventTreasuryDeposit) Descriptor() ([]byte, []int) {
	return fileDescriptor_f82839906ff59fd3, []int{8}
}
func (m *EventTreasuryDeposit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventTreasuryDeposit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventTreasuryDeposit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventTreasuryDeposit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventTreasuryDeposit.Merge(m, src)
}
func (m *EventTreasuryDeposit) XXX_Size() int {
	return m.Size()
}
func (m *EventTreasuryDeposit) XXX_DiscardUnknown() {
	xxx_messageInfo_EventTreasuryDeposit.DiscardUnknown(m)
}

var xxx_messageInfo_EventTreasuryDeposit proto.InternalMessageInfo

func (m *EventTreasuryDeposit) GetSource() string {
	if m != nil {
		return m.Source
	}
	return ""
}

func (m *EventTreasuryDeposit) GetTreasuryAddress() string {
	if m != nil {
		return m.TreasuryAddress
	}
	return ""
}

func (m *EventTreasuryDeposit) GetBlockHeight() int64 {
	if m != nil {
		return m.BlockHeight
	}
	return 0
}

func (m *EventTreasuryDeposit) GetBlockTime() int64 {
	if m != nil {
		return m.BlockTime
	}
	return 0
}

// EventInflationRateChange is emitted when inflation rate changes
// Can happen automatically or via DAO governance
type EventInflationRateChange struct {
	// old_rate is the previous inflation rate
	OldRate cosmossdk_io_math.LegacyDec `protobuf:"bytes,1,opt,name=old_rate,json=oldRate,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"old_rate"`
	// new_rate is the new inflation rate
	NewRate cosmossdk_io_math.LegacyDec `protobuf:"bytes,2,opt,name=new_rate,json=newRate,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"new_rate"`
	// reason explains why the rate changed ("governance" or "automatic")
	Reason string `protobuf:"bytes,3,opt,name=reason,proto3" json:"reason,omitempty"`
	// proposal_id is the governance proposal ID (if via governance)
	ProposalId uint64 `protobuf:"varint,4,opt,name=proposal_id,json=proposalId,proto3" json:"proposal_id,omitempty"`
	// block_height is when the change took effect
	BlockHeight int64 `protobuf:"varint,5,opt,name=block_height,json=blockHeight,proto3" json:"block_height,omitempty"`
	// block_time is the timestamp
	BlockTime int64 `protobuf:"varint,6,opt,name=block_time,json=blockTime,proto3" json:"block_time,omitempty"`
}

func (m *EventInflationRateChange) Reset()         { *m = EventInflationRateChange{} }
func (m *EventInflationRateChange) String() string { return proto.CompactTextString(m) }
func (*EventInflationRateChange) ProtoMessage()    {}
func (*EventInflationRateChange) Descriptor() ([]byte, []int) {
	return fileDescriptor_f82839906ff59fd3, []int{9}
}
func (m *EventInflationRateChange) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventInflationRateChange) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventInflationRateChange.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventInflationRateChange) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventInflationRateChange.Merge(m, src)
}
func (m *EventInflationRateChange) XXX_Size() int {
	return m.Size()
}
func (m *EventInflationRateChange) XXX_DiscardUnknown() {
	xxx_messageInfo_EventInflationRateChange.DiscardUnknown(m)
}

var xxx_messageInfo_EventInflationRateChange proto.InternalMessageInfo

func (m *EventInflationRateChange) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

func (m *EventInflationRateChange) GetProposalId() uint64 {
	if m != nil {
		return m.ProposalId
	}
	return 0
}

func (m *EventInflationRateChange) GetBlockHeight() int64 {
	if m != nil {
		return m.BlockHeight
	}
	return 0
}

func (m *EventInflationRateChange) GetBlockTime() int64 {
	if m != nil {
		return m.BlockTime
	}
	return 0
}

func init() {
	proto.RegisterType((*EventMint)(nil), "pos.tokenomics.v1.EventMint")
	proto.RegisterType((*EventBurn)(nil), "pos.tokenomics.v1.EventBurn")
	proto.RegisterType((*EventDistributeRewards)(nil), "pos.tokenomics.v1.EventDistributeRewards")
	proto.RegisterType((*EventReportBurn)(nil), "pos.tokenomics.v1.EventReportBurn")
	proto.RegisterType((*EventUpdateParams)(nil), "pos.tokenomics.v1.EventUpdateParams")
	proto.RegisterType((*EventCapReached)(nil), "pos.tokenomics.v1.EventCapReached")
	proto.RegisterType((*EventIBCRewardSent)(nil), "pos.tokenomics.v1.EventIBCRewardSent")
	proto.RegisterType((*EventIBCRewardReceived)(nil), "pos.tokenomics.v1.EventIBCRewardReceived")
	proto.RegisterType((*EventTreasuryDeposit)(nil), "pos.tokenomics.v1.EventTreasuryDeposit")
	proto.RegisterType((*EventInflationRateChange)(nil), "pos.tokenomics.v1.EventInflationRateChange")
}

func init() { proto.RegisterFile("pos/tokenomics/v1/events.proto", fileDescriptor_f82839906ff59fd3) }

var fileDescriptor_f82839906ff59fd3 = []byte{
	// 1307 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe4, 0x58, 0x4f, 0x6f, 0x1b, 0xc5,
	0x1b, 0x4e, 0x62, 0xc7, 0x7f, 0x5e, 0xc7, 0x89, 0x33, 0xbf, 0xfe, 0xca, 0x36, 0x50, 0xa7, 0x44,
	0x80, 0x5a, 0x55, 0x38, 0x14, 0xc4, 0x07, 0xc0, 0x0e, 0x52, 0x83, 0x12, 0x14, 0x6d, 0x52, 0x04,
	0x95, 0xd0, 0x6a, 0x3c, 0x3b, 0xb5, 0x47, 0x59, 0xcf, 0x2c, 0x33, 0xe3, 0xfc, 0xf9, 0x16, 0x7c,
	0x0c, 0xae, 0x48, 0xdc, 0xb9, 0xf6, 0xc0, 0xa1, 0xea, 0x05, 0x84, 0x50, 0x85, 0xda, 0x2f, 0xd0,
	0x33, 0x27, 0x34, 0x7f, 0xd6, 0x76, 0x1c, 0x2a, 0xcb, 0x9b, 0x1c, 0x90, 0xb8, 0x79, 0xde, 0x7d,
	0xfd, 0xcc, 0xec, 0xf3, 0x3e, 0xf3, 0xbc, 0x33, 0x0b, 0xcd, 0x54, 0xa8, 0x6d, 0x2d, 0x8e, 0x29,
	0x17, 0x03, 0x46, 0xd4, 0xf6, 0xc9, 0x83, 0x6d, 0x7a, 0x42, 0xb9, 0x56, 0xad, 0x54, 0x0a, 0x2d,
	0xd0, 0x7a, 0x2a, 0x54, 0x6b, 0xfc, 0xbc, 0x75, 0xf2, 0x60, 0xe3, 0x16, 0x11, 0x6a, 0x20, 0x54,
	0x64, 0x13, 0xb6, 0xdd, 0xc0, 0x65, 0x6f, 0xdc, 0xe8, 0x89, 0x9e, 0x70, 0x71, 0xf3, 0xcb, 0x47,
	0x37, 0x2e, 0xcf, 0xa1, 0xcf, 0xdc, 0xb3, 0xad, 0xd7, 0x05, 0xa8, 0x7e, 0x6e, 0x26, 0xdc, 0x67,
	0x5c, 0xa3, 0x77, 0xa0, 0x8a, 0x87, 0xba, 0x2f, 0x24, 0xd3, 0xe7, 0xc1, 0xe2, 0x9d, 0xc5, 0xbb,
	0xd5, 0x70, 0x1c, 0x40, 0x1d, 0x28, 0xe1, 0x81, 0x18, 0x72, 0x1d, 0x2c, 0x99, 0x47, 0xed, 0xfb,
	0x4f, 0x5f, 0x6c, 0x2e, 0xfc, 0xfe, 0x62, 0xf3, 0xff, 0x6e, 0x0d, 0x2a, 0x3e, 0x6e, 0x31, 0xb1,
	0x3d, 0xc0, 0xba, 0xdf, 0xda, 0xe5, 0xfa, 0xf9, 0x4f, 0x1f, 0x82, 0x5f, 0xdc, 0x2e, 0xd7, 0xa1,
	0xff, 0xab, 0x99, 0x42, 0x52, 0xc2, 0x52, 0x46, 0xb9, 0x0e, 0x0a, 0x6e, 0x8a, 0x51, 0x00, 0xdd,
	0x84, 0x92, 0xa4, 0x58, 0x09, 0x1e, 0x14, 0xed, 0x23, 0x3f, 0x42, 0x8f, 0xa0, 0xc1, 0xe9, 0x69,
	0xa4, 0x85, 0xc6, 0x49, 0xa4, 0x86, 0x69, 0x9a, 0x9c, 0x07, 0xcb, 0xf3, 0x2f, 0x62, 0x95, 0xd3,
	0xd3, 0x23, 0x83, 0x71, 0x68, 0x21, 0x2e, 0xc2, 0x0e, 0x18, 0xd7, 0x34, 0x0e, 0x4a, 0x57, 0x80,
	0xdd, 0xb7, 0x10, 0xe8, 0x31, 0x20, 0x49, 0x07, 0x98, 0x71, 0xc6, 0x7b, 0x16, 0x16, 0x77, 0x13,
	0x1a, 0x94, 0xe7, 0x07, 0x5e, 0x1f, 0xc1, 0xec, 0x7b, 0x14, 0xf4, 0x2e, 0xac, 0x74, 0x13, 0x41,
	0x8e, 0xa3, 0x3e, 0x65, 0xbd, 0xbe, 0x0e, 0x2a, 0x77, 0x16, 0xef, 0x16, 0xc2, 0x9a, 0x8d, 0x3d,
	0xb4, 0x21, 0x74, 0x1b, 0xc0, 0xa5, 0x68, 0x36, 0xa0, 0x41, 0xd5, 0x26, 0x54, 0x6d, 0xe4, 0x88,
	0x0d, 0xe8, 0xd6, 0xeb, 0xa2, 0x2f, 0x79, 0x7b, 0x28, 0xb9, 0x61, 0xbc, 0x3b, 0x94, 0x9c, 0x4a,
	0x5f, 0x6f, 0x3f, 0xba, 0x9e, 0x62, 0x1f, 0x40, 0xdd, 0xfd, 0x8a, 0x2c, 0x6a, 0xec, 0x0a, 0x3e,
	0x1f, 0xd6, 0x8a, 0x43, 0x68, 0x5b, 0x00, 0xf4, 0x0d, 0x20, 0x8f, 0xa8, 0x45, 0xa4, 0x8d, 0x3a,
	0x86, 0xf2, 0xdc, 0x89, 0x65, 0x3e, 0xd8, 0x86, 0x83, 0x39, 0x12, 0x47, 0x1e, 0x04, 0x7d, 0x0a,
	0x25, 0x25, 0x86, 0x92, 0x50, 0xab, 0xac, 0xd5, 0x8f, 0x6f, 0xb7, 0x2e, 0xed, 0xbd, 0x96, 0x59,
	0xc5, 0xa1, 0x4d, 0x0a, 0x7d, 0x32, 0xba, 0x05, 0x15, 0xd2, 0xc7, 0x8c, 0x47, 0xcc, 0x6b, 0x27,
	0x2c, 0xdb, 0xf1, 0x6e, 0xfc, 0x8f, 0xaa, 0x2d, 0x5f, 0xb3, 0x6a, 0x3d, 0xb1, 0x95, 0x2b, 0xc0,
	0x7a, 0x6a, 0xa7, 0x95, 0x55, 0x9d, 0xa5, 0x2c, 0x98, 0x52, 0x16, 0x7a, 0x0b, 0xca, 0xfa, 0x2c,
	0xea, 0x63, 0xd5, 0x0f, 0x6a, 0x4e, 0x4c, 0xfa, 0xec, 0x21, 0x56, 0xfd, 0xad, 0xe7, 0xcb, 0x70,
	0xd3, 0x4a, 0x6e, 0x87, 0x29, 0x2d, 0x59, 0x77, 0xa8, 0x69, 0x48, 0x4f, 0xb1, 0x8c, 0xd5, 0x0c,
	0xcb, 0x39, 0x80, 0xba, 0x7b, 0x4d, 0xe9, 0xd2, 0xf3, 0x88, 0x71, 0xc5, 0x22, 0x64, 0xf3, 0x7d,
	0x01, 0xa0, 0x45, 0xa4, 0x34, 0x3e, 0x66, 0xbc, 0x97, 0x47, 0x8f, 0x55, 0x2d, 0x0e, 0xdd, 0xbf,
	0x51, 0x1b, 0x4a, 0x5a, 0x44, 0xa9, 0x20, 0x79, 0x04, 0xb8, 0xac, 0xc5, 0x81, 0x20, 0xe8, 0x4b,
	0x58, 0x31, 0xeb, 0xa1, 0xdf, 0x0d, 0x29, 0x27, 0x54, 0xe6, 0x71, 0xb5, 0x9a, 0x16, 0x87, 0xd9,
	0xff, 0xd1, 0x1e, 0xd4, 0x26, 0x77, 0x46, 0x0e, 0x37, 0x03, 0x3d, 0xde, 0x13, 0x5f, 0xc3, 0x7a,
	0x22, 0x08, 0x4e, 0xa2, 0x78, 0x54, 0xb8, 0x38, 0x8f, 0x84, 0x1b, 0x16, 0x65, 0x5c, 0xfd, 0x18,
	0x1d, 0xc1, 0x1a, 0xeb, 0x92, 0x0b, 0xb8, 0x79, 0x34, 0xcc, 0xba, 0x64, 0x12, 0xf5, 0x2e, 0x34,
	0x0c, 0x6a, 0x8a, 0xc9, 0x31, 0xd5, 0x2a, 0x52, 0xa6, 0xc9, 0x18, 0x1d, 0xd7, 0x6d, 0xe6, 0x81,
	0x0b, 0x1f, 0x9a, 0x4e, 0x33, 0xad, 0x76, 0x98, 0xa5, 0xf6, 0xda, 0xb4, 0x8f, 0xfe, 0x51, 0x80,
	0x35, 0x2b, 0xea, 0x90, 0xa6, 0x42, 0x3a, 0x37, 0xdd, 0x80, 0x8a, 0xb4, 0xa3, 0x91, 0x9f, 0x8e,
	0xc6, 0xe8, 0x03, 0x58, 0x73, 0x96, 0x11, 0x8d, 0xfc, 0xc2, 0xaa, 0x39, 0xac, 0xbb, 0x70, 0xc7,
	0xbb, 0xc6, 0xd8, 0x79, 0x0b, 0xf9, 0x9d, 0x77, 0x6c, 0x66, 0xc5, 0x79, 0xcc, 0xac, 0x05, 0xff,
	0xf3, 0x6b, 0xbc, 0x40, 0xce, 0xb2, 0x7d, 0xf7, 0x75, 0xf7, 0xa8, 0x3d, 0x41, 0xd1, 0x7b, 0xb0,
	0xea, 0xf3, 0xb3, 0x8d, 0xef, 0x2c, 0x70, 0xc5, 0x45, 0x8f, 0xec, 0xf6, 0x77, 0xac, 0x10, 0x21,
	0x63, 0x2f, 0x9e, 0x4a, 0x38, 0x1a, 0xff, 0x6b, 0xcd, 0x6c, 0xeb, 0x87, 0x02, 0xac, 0xdb, 0xf2,
	0x3e, 0x4a, 0x63, 0xac, 0xe9, 0x01, 0x96, 0x78, 0x30, 0xcb, 0xae, 0x36, 0xa1, 0x96, 0x4a, 0x91,
	0x0a, 0x85, 0x93, 0xac, 0xbc, 0xc5, 0x10, 0xb2, 0xd0, 0x6e, 0x8c, 0xde, 0x87, 0x55, 0xd2, 0xc7,
	0xbc, 0x47, 0xe3, 0x28, 0xb5, 0x80, 0x41, 0xe1, 0x4e, 0xc1, 0x48, 0xc0, 0x47, 0xfd, 0x2c, 0x11,
	0x20, 0x91, 0xc4, 0x11, 0xe3, 0x4f, 0x12, 0xac, 0x99, 0xe0, 0x91, 0xc4, 0x9a, 0x7a, 0x93, 0x79,
	0xe0, 0x69, 0x79, 0xfb, 0x32, 0x2d, 0x7b, 0xb4, 0x87, 0xc9, 0xf9, 0x0e, 0x25, 0x13, 0xe4, 0xec,
	0x50, 0x12, 0x36, 0x44, 0x12, 0xef, 0x66, 0x58, 0x21, 0xd6, 0xd4, 0x4c, 0x60, 0x58, 0x9f, 0x9a,
	0x60, 0x39, 0xf7, 0x04, 0x9c, 0x9e, 0x5e, 0x9c, 0xe0, 0x1e, 0x34, 0xe8, 0x93, 0x27, 0x94, 0x68,
	0x76, 0x42, 0xb3, 0x1a, 0x94, 0x2c, 0xc5, 0x6b, 0xa3, 0xb8, 0xaf, 0xc3, 0x74, 0xa9, 0xca, 0xb3,
	0x4a, 0x55, 0x99, 0x2e, 0xd5, 0x2f, 0xd9, 0x4e, 0xec, 0xe0, 0x34, 0xa4, 0x98, 0xf4, 0x69, 0x8c,
	0xbe, 0x82, 0xfa, 0x29, 0x96, 0xf6, 0x04, 0x96, 0xd0, 0x13, 0x9a, 0xb8, 0x62, 0xe5, 0x79, 0xb9,
	0x15, 0x8f, 0xb3, 0x67, 0x60, 0x50, 0x08, 0xab, 0x64, 0x28, 0x25, 0xe5, 0x3a, 0xeb, 0xe8, 0x39,
	0x5a, 0x52, 0xdd, 0x43, 0x8c, 0x1b, 0xfa, 0xe4, 0x19, 0x21, 0x22, 0x38, 0xcd, 0xb3, 0xf7, 0x57,
	0xf5, 0xf8, 0x90, 0xd0, 0xc1, 0xe9, 0x1b, 0x8e, 0xa1, 0xc5, 0x6b, 0x39, 0x86, 0x06, 0x50, 0x1e,
	0x50, 0xa5, 0x70, 0xcf, 0xab, 0x26, 0xcc, 0x86, 0x97, 0xca, 0x59, 0x9a, 0x55, 0xce, 0xf2, 0x74,
	0x39, 0xff, 0x5a, 0x02, 0x64, 0xcb, 0xb9, 0xdb, 0xee, 0xb8, 0xb6, 0x9d, 0x39, 0xf6, 0xa4, 0x7f,
	0xfa, 0xdd, 0x57, 0x9b, 0x30, 0x4f, 0x74, 0x1f, 0xd6, 0x63, 0xaa, 0x34, 0xe3, 0x4e, 0xd4, 0x2e,
	0xcf, 0x99, 0x6c, 0x63, 0xe2, 0x81, 0x4b, 0xde, 0x84, 0x9a, 0xe9, 0x15, 0x66, 0xe7, 0x71, 0x9a,
	0xf8, 0xbb, 0x08, 0xb0, 0x2e, 0xe9, 0xb8, 0xc8, 0x84, 0x11, 0x17, 0xf3, 0x1b, 0xf1, 0x3d, 0x68,
	0x8c, 0xae, 0x37, 0xd1, 0x40, 0xc4, 0xc3, 0x24, 0x63, 0x6c, 0x6d, 0x14, 0xdf, 0xb7, 0x61, 0x63,
	0x93, 0xd9, 0x39, 0xc0, 0xb2, 0x56, 0x0c, 0x47, 0x63, 0x63, 0x1c, 0x86, 0x2c, 0x31, 0xd4, 0x17,
	0xb7, 0x49, 0xdd, 0x47, 0xdf, 0xb0, 0x97, 0xe6, 0xbf, 0x1d, 0xfc, 0xba, 0xe4, 0x8f, 0x6a, 0x23,
	0xf2, 0x43, 0x4a, 0x28, 0x3b, 0x71, 0x9e, 0xfa, 0xdf, 0x2d, 0xc0, 0xd5, 0x5d, 0xea, 0xe7, 0x25,
	0xb8, 0x61, 0x99, 0xcd, 0x4e, 0x57, 0x3b, 0x34, 0x15, 0x8a, 0xd9, 0x4b, 0xaf, 0xef, 0xd5, 0xfe,
	0x0a, 0xe6, 0x9b, 0xf1, 0xb5, 0x5c, 0xc1, 0xee, 0x41, 0x23, 0x3b, 0x0c, 0x46, 0x38, 0x8e, 0x25,
	0x55, 0xca, 0x33, 0xbd, 0x96, 0xc5, 0x3f, 0x73, 0x61, 0xf4, 0x2d, 0xdc, 0xb0, 0xad, 0x38, 0x4b,
	0xef, 0xe2, 0x04, 0x73, 0x92, 0xcb, 0x31, 0x4c, 0x77, 0xc9, 0x5e, 0xb3, 0xed, 0x60, 0x2e, 0x31,
	0xb8, 0x3c, 0x8b, 0xc1, 0xd2, 0x34, 0x83, 0x3f, 0x2e, 0x41, 0xe0, 0xb4, 0x39, 0xd9, 0x6b, 0x3a,
	0xb6, 0x75, 0xa2, 0x3d, 0xa8, 0x98, 0x9e, 0x69, 0x1b, 0x59, 0x6e, 0xaf, 0x2f, 0x8b, 0x24, 0xb6,
	0xfd, 0x6b, 0x0f, 0x2a, 0x86, 0x0b, 0x8b, 0xb6, 0x94, 0x1b, 0x8d, 0xd3, 0x53, 0x8b, 0x36, 0xfe,
	0xac, 0x51, 0xb8, 0xf0, 0x59, 0x63, 0xea, 0xbc, 0x50, 0xbc, 0x74, 0x5e, 0xb8, 0x32, 0x67, 0xed,
	0x8f, 0x9e, 0xbe, 0x6c, 0x2e, 0x3e, 0x7b, 0xd9, 0x5c, 0xfc, 0xf3, 0x65, 0x73, 0xf1, 0xfb, 0x57,
	0xcd, 0x85, 0x67, 0xaf, 0x9a, 0x0b, 0xbf, 0xbd, 0x6a, 0x2e, 0x3c, 0xbe, 0x99, 0x0a, 0xb5, 0x7d,
	0x36, 0xf9, 0x61, 0x48, 0x9f, 0xa7, 0x54, 0x75, 0x4b, 0xf6, 0xcb, 0xd0, 0x27, 0x7f, 0x07, 0x00,
	0x00, 0xff, 0xff, 0xc5, 0x66, 0xb0, 0x44, 0x9b, 0x12, 0x00, 0x00,
}

func (m *EventMint) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventMint) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventMint) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.BlockTime != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.BlockTime))
		i--
		dAtA[i] = 0x48
	}
	if m.BlockHeight != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.BlockHeight))
		i--
		dAtA[i] = 0x40
	}
	{
		size := m.RemainingMintable.Size()
		i -= size
		if _, err := m.RemainingMintable.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	{
		size := m.NewTotalMinted.Size()
		i -= size
		if _, err := m.NewTotalMinted.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	{
		size := m.NewTotalSupply.Size()
		i -= size
		if _, err := m.NewTotalSupply.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	if len(m.Reason) > 0 {
		i -= len(m.Reason)
		copy(dAtA[i:], m.Reason)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Reason)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Recipient) > 0 {
		i -= len(m.Recipient)
		copy(dAtA[i:], m.Recipient)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Recipient)))
		i--
		dAtA[i] = 0x1a
	}
	{
		size := m.Amount.Size()
		i -= size
		if _, err := m.Amount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Authority) > 0 {
		i -= len(m.Authority)
		copy(dAtA[i:], m.Authority)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Authority)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventBurn) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventBurn) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventBurn) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TxHash) > 0 {
		i -= len(m.TxHash)
		copy(dAtA[i:], m.TxHash)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.TxHash)))
		i--
		dAtA[i] = 0x5a
	}
	if m.BlockTime != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.BlockTime))
		i--
		dAtA[i] = 0x50
	}
	if m.BlockHeight != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.BlockHeight))
		i--
		dAtA[i] = 0x48
	}
	{
		size := m.NewTotalBurned.Size()
		i -= size
		if _, err := m.NewTotalBurned.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x42
	{
		size := m.NewTotalSupply.Size()
		i -= size
		if _, err := m.NewTotalSupply.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	if len(m.ChainId) > 0 {
		i -= len(m.ChainId)
		copy(dAtA[i:], m.ChainId)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.ChainId)))
		i--
		dAtA[i] = 0x32
	}
	if m.Source != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.Source))
		i--
		dAtA[i] = 0x28
	}
	{
		size := m.AmountToTreasury.Size()
		i -= size
		if _, err := m.AmountToTreasury.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size := m.AmountBurned.Size()
		i -= size
		if _, err := m.AmountBurned.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.Amount.Size()
		i -= size
		if _, err := m.Amount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Burner) > 0 {
		i -= len(m.Burner)
		copy(dAtA[i:], m.Burner)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Burner)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventDistributeRewards) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventDistributeRewards) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventDistributeRewards) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.BlockTime != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.BlockTime))
		i--
		dAtA[i] = 0x58
	}
	if m.BlockHeight != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.BlockHeight))
		i--
		dAtA[i] = 0x50
	}
	if m.IbcPacketsSent != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.IbcPacketsSent))
		i--
		dAtA[i] = 0x48
	}
	{
		size := m.IbcDistributed.Size()
		i -= size
		if _, err := m.IbcDistributed.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x42
	{
		size := m.LocalDistributed.Size()
		i -= size
		if _, err := m.LocalDistributed.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	{
		size := m.ToTreasury.Size()
		i -= size
		if _, err := m.ToTreasury.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	{
		size := m.ToSequencer.Size()
		i -= size
		if _, err := m.ToSequencer.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size := m.ToPoc.Size()
		i -= size
		if _, err := m.ToPoc.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size := m.ToStaking.Size()
		i -= size
		if _, err := m.ToStaking.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.TotalRewards.Size()
		i -= size
		if _, err := m.TotalRewards.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Authority) > 0 {
		i -= len(m.Authority)
		copy(dAtA[i:], m.Authority)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Authority)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventReportBurn) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventReportBurn) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventReportBurn) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.BlockTime != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.BlockTime))
		i--
		dAtA[i] = 0x50
	}
	if m.BlockHeight != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.BlockHeight))
		i--
		dAtA[i] = 0x48
	}
	{
		size := m.NewTotalBurned.Size()
		i -= size
		if _, err := m.NewTotalBurned.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x42
	if m.Recorded {
		i--
		if m.Recorded {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if len(m.SourceTxHash) > 0 {
		i -= len(m.SourceTxHash)
		copy(dAtA[i:], m.SourceTxHash)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.SourceTxHash)))
		i--
		dAtA[i] = 0x32
	}
	if m.SourceBlockHeight != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.SourceBlockHeight))
		i--
		dAtA[i] = 0x28
	}
	if m.Source != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.Source))
		i--
		dAtA[i] = 0x20
	}
	{
		size := m.Amount.Size()
		i -= size
		if _, err := m.Amount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.SourceChainId) > 0 {
		i -= len(m.SourceChainId)
		copy(dAtA[i:], m.SourceChainId)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.SourceChainId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Reporter) > 0 {
		i -= len(m.Reporter)
		copy(dAtA[i:], m.Reporter)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Reporter)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventUpdateParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventUpdateParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventUpdateParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.BlockTime != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.BlockTime))
		i--
		dAtA[i] = 0x40
	}
	if m.BlockHeight != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.BlockHeight))
		i--
		dAtA[i] = 0x38
	}
	if m.EffectiveHeight != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.EffectiveHeight))
		i--
		dAtA[i] = 0x30
	}
	{
		size := m.NewInflationRate.Size()
		i -= size
		if _, err := m.NewInflationRate.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size := m.OldInflationRate.Size()
		i -= size
		if _, err := m.OldInflationRate.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.ChangedParams) > 0 {
		for iNdEx := len(m.ChangedParams) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ChangedParams[iNdEx])
			copy(dAtA[i:], m.ChangedParams[iNdEx])
			i = encodeVarintEvents(dAtA, i, uint64(len(m.ChangedParams[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.ProposalId != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.ProposalId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Authority) > 0 {
		i -= len(m.Authority)
		copy(dAtA[i:], m.Authority)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Authority)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventCapReached) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventCapReached) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventCapReached) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.BlockTime != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.BlockTime))
		i--
		dAtA[i] = 0x38
	}
	if m.BlockHeight != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.BlockHeight))
		i--
		dAtA[i] = 0x30
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x2a
	}
	{
		size := m.RemainingMintable.Size()
		i -= size
		if _, err := m.RemainingMintable.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size := m.TotalSupplyCap.Size()
		i -= size
		if _, err := m.TotalSupplyCap.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.CurrentSupply.Size()
		i -= size
		if _, err := m.CurrentSupply.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size := m.WarningLevel.Size()
		i -= size
		if _, err := m.WarningLevel.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *EventIBCRewardSent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventIBCRewardSent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventIBCRewardSent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.BlockTime != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.BlockTime))
		i--
		dAtA[i] = 0x48
	}
	if m.BlockHeight != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.BlockHeight))
		i--
		dAtA[i] = 0x40
	}
	if m.TimeoutHeight != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.TimeoutHeight))
		i--
		dAtA[i] = 0x38
	}
	if m.Sequence != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.Sequence))
		i--
		dAtA[i] = 0x30
	}
	if len(m.RecipientModule) > 0 {
		i -= len(m.RecipientModule)
		copy(dAtA[i:], m.RecipientModule)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.RecipientModule)))
		i--
		dAtA[i] = 0x2a
	}
	{
		size := m.Amount.Size()
		i -= size
		if _, err := m.Amount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.IbcChannel) > 0 {
		i -= len(m.IbcChannel)
		copy(dAtA[i:], m.IbcChannel)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.IbcChannel)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.DestinationChain) > 0 {
		i -= len(m.DestinationChain)
		copy(dAtA[i:], m.DestinationChain)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.DestinationChain)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.SourceChain) > 0 {
		i -= len(m.SourceChain)
		copy(dAtA[i:], m.SourceChain)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.SourceChain)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventIBCRewardReceived) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventIBCRewardReceived) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventIBCRewardReceived) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.BlockTime != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.BlockTime))
		i--
		dAtA[i] = 0x40
	}
	if m.BlockHeight != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.BlockHeight))
		i--
		dAtA[i] = 0x38
	}
	if m.Sequence != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.Sequence))
		i--
		dAtA[i] = 0x30
	}
	if len(m.RecipientModule) > 0 {
		i -= len(m.RecipientModule)
		copy(dAtA[i:], m.RecipientModule)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.RecipientModule)))
		i--
		dAtA[i] = 0x2a
	}
	{
		size := m.Amount.Size()
		i -= size
		if _, err := m.Amount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.IbcChannel) > 0 {
		i -= len(m.IbcChannel)
		copy(dAtA[i:], m.IbcChannel)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.IbcChannel)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.DestinationChain) > 0 {
		i -= len(m.DestinationChain)
		copy(dAtA[i:], m.DestinationChain)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.DestinationChain)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.SourceChain) > 0 {
		i -= len(m.SourceChain)
		copy(dAtA[i:], m.SourceChain)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.SourceChain)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventTreasuryDeposit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventTreasuryDeposit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventTreasuryDeposit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.BlockTime != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.BlockTime))
		i--
		dAtA[i] = 0x30
	}
	if m.BlockHeight != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.BlockHeight))
		i--
		dAtA[i] = 0x28
	}
	{
		size := m.NewTreasuryBalance.Size()
		i -= size
		if _, err := m.NewTreasuryBalance.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.TreasuryAddress) > 0 {
		i -= len(m.TreasuryAddress)
		copy(dAtA[i:], m.TreasuryAddress)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.TreasuryAddress)))
		i--
		dAtA[i] = 0x1a
	}
	{
		size := m.Amount.Size()
		i -= size
		if _, err := m.Amount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Source) > 0 {
		i -= len(m.Source)
		copy(dAtA[i:], m.Source)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Source)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventInflationRateChange) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventInflationRateChange) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventInflationRateChange) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.BlockTime != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.BlockTime))
		i--
		dAtA[i] = 0x30
	}
	if m.BlockHeight != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.BlockHeight))
		i--
		dAtA[i] = 0x28
	}
	if m.ProposalId != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.ProposalId))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Reason) > 0 {
		i -= len(m.Reason)
		copy(dAtA[i:], m.Reason)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Reason)))
		i--
		dAtA[i] = 0x1a
	}
	{
		size := m.NewRate.Size()
		i -= size
		if _, err := m.NewRate.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size := m.OldRate.Size()
		i -= size
		if _, err := m.OldRate.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func encodeVarintEvents(dAtA []byte, offset int, v uint64) int {
	offset -= sovEvents(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *EventMint) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Authority)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = m.Amount.Size()
	n += 1 + l + sovEvents(uint64(l))
	l = len(m.Recipient)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = m.NewTotalSupply.Size()
	n += 1 + l + sovEvents(uint64(l))
	l = m.NewTotalMinted.Size()
	n += 1 + l + sovEvents(uint64(l))
	l = m.RemainingMintable.Size()
	n += 1 + l + sovEvents(uint64(l))
	if m.BlockHeight != 0 {
		n += 1 + sovEvents(uint64(m.BlockHeight))
	}
	if m.BlockTime != 0 {
		n += 1 + sovEvents(uint64(m.BlockTime))
	}
	return n
}

func (m *EventBurn) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Burner)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = m.Amount.Size()
	n += 1 + l + sovEvents(uint64(l))
	l = m.AmountBurned.Size()
	n += 1 + l + sovEvents(uint64(l))
	l = m.AmountToTreasury.Size()
	n += 1 + l + sovEvents(uint64(l))
	if m.Source != 0 {
		n += 1 + sovEvents(uint64(m.Source))
	}
	l = len(m.ChainId)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = m.NewTotalSupply.Size()
	n += 1 + l + sovEvents(uint64(l))
	l = m.NewTotalBurned.Size()
	n += 1 + l + sovEvents(uint64(l))
	if m.BlockHeight != 0 {
		n += 1 + sovEvents(uint64(m.BlockHeight))
	}
	if m.BlockTime != 0 {
		n += 1 + sovEvents(uint64(m.BlockTime))
	}
	l = len(m.TxHash)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *EventDistributeRewards) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Authority)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = m.TotalRewards.Size()
	n += 1 + l + sovEvents(uint64(l))
	l = m.ToStaking.Size()
	n += 1 + l + sovEvents(uint64(l))
	l = m.ToPoc.Size()
	n += 1 + l + sovEvents(uint64(l))
	l = m.ToSequencer.Size()
	n += 1 + l + sovEvents(uint64(l))
	l = m.ToTreasury.Size()
	n += 1 + l + sovEvents(uint64(l))
	l = m.LocalDistributed.Size()
	n += 1 + l + sovEvents(uint64(l))
	l = m.IbcDistributed.Size()
	n += 1 + l + sovEvents(uint64(l))
	if m.IbcPacketsSent != 0 {
		n += 1 + sovEvents(uint64(m.IbcPacketsSent))
	}
	if m.BlockHeight != 0 {
		n += 1 + sovEvents(uint64(m.BlockHeight))
	}
	if m.BlockTime != 0 {
		n += 1 + sovEvents(uint64(m.BlockTime))
	}
	return n
}

func (m *EventReportBurn) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Reporter)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.SourceChainId)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = m.Amount.Size()
	n += 1 + l + sovEvents(uint64(l))
	if m.Source != 0 {
		n += 1 + sovEvents(uint64(m.Source))
	}
	if m.SourceBlockHeight != 0 {
		n += 1 + sovEvents(uint64(m.SourceBlockHeight))
	}
	l = len(m.SourceTxHash)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.Recorded {
		n += 2
	}
	l = m.NewTotalBurned.Size()
	n += 1 + l + sovEvents(uint64(l))
	if m.BlockHeight != 0 {
		n += 1 + sovEvents(uint64(m.BlockHeight))
	}
	if m.BlockTime != 0 {
		n += 1 + sovEvents(uint64(m.BlockTime))
	}
	return n
}

func (m *EventUpdateParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Authority)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.ProposalId != 0 {
		n += 1 + sovEvents(uint64(m.ProposalId))
	}
	if len(m.ChangedParams) > 0 {
		for _, s := range m.ChangedParams {
			l = len(s)
			n += 1 + l + sovEvents(uint64(l))
		}
	}
	l = m.OldInflationRate.Size()
	n += 1 + l + sovEvents(uint64(l))
	l = m.NewInflationRate.Size()
	n += 1 + l + sovEvents(uint64(l))
	if m.EffectiveHeight != 0 {
		n += 1 + sovEvents(uint64(m.EffectiveHeight))
	}
	if m.BlockHeight != 0 {
		n += 1 + sovEvents(uint64(m.BlockHeight))
	}
	if m.BlockTime != 0 {
		n += 1 + sovEvents(uint64(m.BlockTime))
	}
	return n
}

func (m *EventCapReached) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.WarningLevel.Size()
	n += 1 + l + sovEvents(uint64(l))
	l = m.CurrentSupply.Size()
	n += 1 + l + sovEvents(uint64(l))
	l = m.TotalSupplyCap.Size()
	n += 1 + l + sovEvents(uint64(l))
	l = m.RemainingMintable.Size()
	n += 1 + l + sovEvents(uint64(l))
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.BlockHeight != 0 {
		n += 1 + sovEvents(uint64(m.BlockHeight))
	}
	if m.BlockTime != 0 {
		n += 1 + sovEvents(uint64(m.BlockTime))
	}
	return n
}

func (m *EventIBCRewardSent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SourceChain)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.DestinationChain)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.IbcChannel)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = m.Amount.Size()
	n += 1 + l + sovEvents(uint64(l))
	l = len(m.RecipientModule)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.Sequence != 0 {
		n += 1 + sovEvents(uint64(m.Sequence))
	}
	if m.TimeoutHeight != 0 {
		n += 1 + sovEvents(uint64(m.TimeoutHeight))
	}
	if m.BlockHeight != 0 {
		n += 1 + sovEvents(uint64(m.BlockHeight))
	}
	if m.BlockTime != 0 {
		n += 1 + sovEvents(uint64(m.BlockTime))
	}
	return n
}

func (m *EventIBCRewardReceived) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SourceChain)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.DestinationChain)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.IbcChannel)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = m.Amount.Size()
	n += 1 + l + sovEvents(uint64(l))
	l = len(m.RecipientModule)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.Sequence != 0 {
		n += 1 + sovEvents(uint64(m.Sequence))
	}
	if m.BlockHeight != 0 {
		n += 1 + sovEvents(uint64(m.BlockHeight))
	}
	if m.BlockTime != 0 {
		n += 1 + sovEvents(uint64(m.BlockTime))
	}
	return n
}

func (m *EventTreasuryDeposit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Source)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = m.Amount.Size()
	n += 1 + l + sovEvents(uint64(l))
	l = len(m.TreasuryAddress)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = m.NewTreasuryBalance.Size()
	n += 1 + l + sovEvents(uint64(l))
	if m.BlockHeight != 0 {
		n += 1 + sovEvents(uint64(m.BlockHeight))
	}
	if m.BlockTime != 0 {
		n += 1 + sovEvents(uint64(m.BlockTime))
	}
	return n
}

func (m *EventInflationRateChange) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.OldRate.Size()
	n += 1 + l + sovEvents(uint64(l))
	l = m.NewRate.Size()
	n += 1 + l + sovEvents(uint64(l))
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.ProposalId != 0 {
		n += 1 + sovEvents(uint64(m.ProposalId))
	}
	if m.BlockHeight != 0 {
		n += 1 + sovEvents(uint64(m.BlockHeight))
	}
	if m.BlockTime != 0 {
		n += 1 + sovEvents(uint64(m.BlockTime))
	}
	return n
}

func sovEvents(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozEvents(x uint64) (n int) {
	return sovEvents(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *EventMint) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventMint: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventMint: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Authority = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Recipient", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Recipient = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewTotalSupply", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.NewTotalSupply.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewTotalMinted", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.NewTotalMinted.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemainingMintable", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RemainingMintable.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockHeight", wireType)
			}
			m.BlockHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockTime", wireType)
			}
			m.BlockTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventBurn) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventBurn: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventBurn: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Burner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Burner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AmountBurned", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AmountBurned.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AmountToTreasury", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AmountToTreasury.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			m.Source = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Source |= BurnSource(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChainId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewTotalSupply", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.NewTotalSupply.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewTotalBurned", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.NewTotalBurned.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockHeight", wireType)
			}
			m.BlockHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockTime", wireType)
			}
			m.BlockTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventDistributeRewards) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventDistributeRewards: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventDistributeRewards: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Authority = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalRewards", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalRewards.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToStaking", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ToStaking.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToPoc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ToPoc.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToSequencer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ToSequencer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToTreasury", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ToTreasury.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalDistributed", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.LocalDistributed.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IbcDistributed", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.IbcDistributed.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IbcPacketsSent", wireType)
			}
			m.IbcPacketsSent = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IbcPacketsSent |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockHeight", wireType)
			}
			m.BlockHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockTime", wireType)
			}
			m.BlockTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventReportBurn) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventReportBurn: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventReportBurn: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reporter", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reporter = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceChainId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SourceChainId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			m.Source = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Source |= BurnSource(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceBlockHeight", wireType)
			}
			m.SourceBlockHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SourceBlockHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceTxHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SourceTxHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Recorded", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Recorded = bool(v != 0)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewTotalBurned", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.NewTotalBurned.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockHeight", wireType)
			}
			m.BlockHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockTime", wireType)
			}
			m.BlockTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventUpdateParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventUpdateParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventUpdateParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Authority = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProposalId", wireType)
			}
			m.ProposalId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProposalId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangedParams", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChangedParams = append(m.ChangedParams, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OldInflationRate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.OldInflationRate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewInflationRate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.NewInflationRate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EffectiveHeight", wireType)
			}
			m.EffectiveHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EffectiveHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockHeight", wireType)
			}
			m.BlockHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockTime", wireType)
			}
			m.BlockTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventCapReached) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventCapReached: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventCapReached: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WarningLevel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.WarningLevel.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentSupply", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CurrentSupply.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalSupplyCap", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalSupplyCap.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemainingMintable", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RemainingMintable.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockHeight", wireType)
			}
			m.BlockHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockTime", wireType)
			}
			m.BlockTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventIBCRewardSent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventIBCRewardSent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventIBCRewardSent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceChain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SourceChain = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestinationChain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DestinationChain = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IbcChannel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IbcChannel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecipientModule", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RecipientModule = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sequence", wireType)
			}
			m.Sequence = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sequence |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeoutHeight", wireType)
			}
			m.TimeoutHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimeoutHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockHeight", wireType)
			}
			m.BlockHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockTime", wireType)
			}
			m.BlockTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventIBCRewardReceived) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventIBCRewardReceived: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventIBCRewardReceived: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceChain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SourceChain = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestinationChain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DestinationChain = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IbcChannel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IbcChannel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecipientModule", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RecipientModule = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sequence", wireType)
			}
			m.Sequence = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sequence |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockHeight", wireType)
			}
			m.BlockHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockTime", wireType)
			}
			m.BlockTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventTreasuryDeposit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventTreasuryDeposit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventTreasuryDeposit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Source = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TreasuryAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TreasuryAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewTreasuryBalance", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.NewTreasuryBalance.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockHeight", wireType)
			}
			m.BlockHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockTime", wireType)
			}
			m.BlockTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventInflationRateChange) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventInflationRateChange: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventInflationRateChange: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OldRate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.OldRate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewRate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.NewRate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProposalId", wireType)
			}
			m.ProposalId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProposalId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockHeight", wireType)
			}
			m.BlockHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockTime", wireType)
			}
			m.BlockTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipEvents(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthEvents
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupEvents
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthEvents
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthEvents        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowEvents          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupEvents = fmt.Errorf("proto: unexpected end of group")
)
