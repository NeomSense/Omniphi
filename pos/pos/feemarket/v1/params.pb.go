// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: pos/feemarket/v1/params.proto

package types

import (
	cosmossdk_io_math "cosmossdk.io/math"
	fmt "fmt"
	_ "github.com/cosmos/cosmos-proto"
	_ "github.com/cosmos/cosmos-sdk/types/tx/amino"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// FeeMarketParams defines the parameters for the feemarket module.
// All parameters are governance-adjustable via ParamChangeProposal.
type FeeMarketParams struct {
	// min_gas_price is the minimum gas price enforced by validators (in uomni/gas)
	// Transactions below this price will be rejected
	// Default: 0.05 uomni/gas
	// Governance Range: 0.01 - 1.0 uomni/gas
	MinGasPrice cosmossdk_io_math.LegacyDec `protobuf:"bytes,1,opt,name=min_gas_price,json=minGasPrice,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"min_gas_price"`
	// base_fee_enabled enables EIP-1559 style dynamic base fee adjustment
	// When true, base fee adjusts based on block utilization
	// Default: true
	BaseFeeEnabled bool `protobuf:"varint,2,opt,name=base_fee_enabled,json=baseFeeEnabled,proto3" json:"base_fee_enabled,omitempty"`
	// base_fee_initial is the initial base fee (in uomni/gas) at genesis
	// Default: 0.05 uomni/gas
	BaseFeeInitial cosmossdk_io_math.LegacyDec `protobuf:"bytes,3,opt,name=base_fee_initial,json=baseFeeInitial,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"base_fee_initial"`
	// elasticity_multiplier determines how much base fee changes per block
	// If utilization > target: new_base_fee = old_base_fee * elasticity_multiplier
	// If utilization < target: new_base_fee = old_base_fee / elasticity_multiplier
	// Default: 1.125 (12.5% change per block)
	// Governance Range: 1.01 - 1.50
	ElasticityMultiplier cosmossdk_io_math.LegacyDec `protobuf:"bytes,4,opt,name=elasticity_multiplier,json=elasticityMultiplier,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"elasticity_multiplier"`
	// max_tip_ratio is the maximum tip as a percentage of base fee
	// Tips go to the block proposer
	// Default: 0.20 (20% of base fee)
	// Governance Range: 0.0 - 0.50
	MaxTipRatio cosmossdk_io_math.LegacyDec `protobuf:"bytes,5,opt,name=max_tip_ratio,json=maxTipRatio,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"max_tip_ratio"`
	// target_block_utilization is the target percentage of block gas usage
	// Base fee adjusts to maintain this target
	// Default: 0.33 (33%)
	// Governance Range: 0.20 - 0.80
	TargetBlockUtilization cosmossdk_io_math.LegacyDec `protobuf:"bytes,6,opt,name=target_block_utilization,json=targetBlockUtilization,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"target_block_utilization"`
	// max_tx_gas is the maximum gas allowed per transaction
	// Prevents outlier transactions from consuming entire blocks
	// Default: 10,000,000
	// Governance Range: 1,000,000 - 100,000,000
	MaxTxGas int64 `protobuf:"varint,7,opt,name=max_tx_gas,json=maxTxGas,proto3" json:"max_tx_gas,omitempty"`
	// free_tx_quota is the number of whitelisted message types per block
	// These transactions are not counted toward utilization
	// (e.g., MsgVote, MsgClaimRewards)
	// Default: 100
	// Governance Range: 0 - 1000
	FreeTxQuota int64 `protobuf:"varint,8,opt,name=free_tx_quota,json=freeTxQuota,proto3" json:"free_tx_quota,omitempty"`
	// burn_cool is the burn percentage when utilization is below cool threshold
	// Default: 0.10 (10%)
	// Governance Range: 0.05 - 0.20
	BurnCool cosmossdk_io_math.LegacyDec `protobuf:"bytes,9,opt,name=burn_cool,json=burnCool,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"burn_cool"`
	// burn_normal is the burn percentage for normal utilization
	// Default: 0.20 (20%)
	// Governance Range: 0.10 - 0.30
	BurnNormal cosmossdk_io_math.LegacyDec `protobuf:"bytes,10,opt,name=burn_normal,json=burnNormal,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"burn_normal"`
	// burn_hot is the burn percentage when utilization exceeds hot threshold
	// Default: 0.40 (40%)
	// Governance Range: 0.20 - 0.50
	BurnHot cosmossdk_io_math.LegacyDec `protobuf:"bytes,11,opt,name=burn_hot,json=burnHot,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"burn_hot"`
	// util_cool_threshold is the utilization below which "cool" burn tier applies
	// Default: 0.16 (16%)
	// Governance Range: 0.05 - 0.25
	UtilCoolThreshold cosmossdk_io_math.LegacyDec `protobuf:"bytes,12,opt,name=util_cool_threshold,json=utilCoolThreshold,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"util_cool_threshold"`
	// util_hot_threshold is the utilization above which "hot" burn tier applies
	// Default: 0.33 (33%)
	// Governance Range: 0.25 - 0.50
	UtilHotThreshold cosmossdk_io_math.LegacyDec `protobuf:"bytes,13,opt,name=util_hot_threshold,json=utilHotThreshold,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"util_hot_threshold"`
	// validator_fee_ratio is the percentage of post-burn fees that go to validators
	// Default: 0.70 (70%)
	// Governance Range: 0.50 - 0.90
	// Note: validator_fee_ratio + treasury_fee_ratio must equal 1.0
	ValidatorFeeRatio cosmossdk_io_math.LegacyDec `protobuf:"bytes,14,opt,name=validator_fee_ratio,json=validatorFeeRatio,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"validator_fee_ratio"`
	// treasury_fee_ratio is the percentage of post-burn fees that go to treasury
	// Default: 0.30 (30%)
	// Governance Range: 0.10 - 0.50
	// Note: validator_fee_ratio + treasury_fee_ratio must equal 1.0
	TreasuryFeeRatio cosmossdk_io_math.LegacyDec `protobuf:"bytes,15,opt,name=treasury_fee_ratio,json=treasuryFeeRatio,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"treasury_fee_ratio"`
	// max_burn_ratio is the hard cap on burn percentage
	// Prevents excessive deflation during extreme congestion
	// Default: 0.50 (50%)
	// Protocol Enforced: Cannot exceed 0.50
	MaxBurnRatio cosmossdk_io_math.LegacyDec `protobuf:"bytes,16,opt,name=max_burn_ratio,json=maxBurnRatio,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"max_burn_ratio"`
	// min_gas_price_floor is the absolute minimum gas price
	// Acts as a hard floor below which governance cannot reduce min_gas_price
	// Default: 0.025 uomni/gas
	// Protocol Enforced: Cannot be less than 0.01
	MinGasPriceFloor cosmossdk_io_math.LegacyDec `protobuf:"bytes,17,opt,name=min_gas_price_floor,json=minGasPriceFloor,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"min_gas_price_floor"`
}

func (m *FeeMarketParams) Reset()         { *m = FeeMarketParams{} }
func (m *FeeMarketParams) String() string { return proto.CompactTextString(m) }
func (*FeeMarketParams) ProtoMessage()    {}
func (*FeeMarketParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_49c1a95314f7c282, []int{0}
}
func (m *FeeMarketParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FeeMarketParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FeeMarketParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FeeMarketParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FeeMarketParams.Merge(m, src)
}
func (m *FeeMarketParams) XXX_Size() int {
	return m.Size()
}
func (m *FeeMarketParams) XXX_DiscardUnknown() {
	xxx_messageInfo_FeeMarketParams.DiscardUnknown(m)
}

var xxx_messageInfo_FeeMarketParams proto.InternalMessageInfo

func (m *FeeMarketParams) GetBaseFeeEnabled() bool {
	if m != nil {
		return m.BaseFeeEnabled
	}
	return false
}

func (m *FeeMarketParams) GetMaxTxGas() int64 {
	if m != nil {
		return m.MaxTxGas
	}
	return 0
}

func (m *FeeMarketParams) GetFreeTxQuota() int64 {
	if m != nil {
		return m.FreeTxQuota
	}
	return 0
}

func init() {
	proto.RegisterType((*FeeMarketParams)(nil), "pos.feemarket.v1.FeeMarketParams")
}

func init() { proto.RegisterFile("pos/feemarket/v1/params.proto", fileDescriptor_49c1a95314f7c282) }

var fileDescriptor_49c1a95314f7c282 = []byte{
	// 627 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x95, 0xcd, 0x6e, 0x13, 0x31,
	0x10, 0xc7, 0xb3, 0x14, 0xda, 0xd4, 0xe9, 0x47, 0xea, 0xb6, 0xc8, 0x14, 0x48, 0xaa, 0x9e, 0x22,
	0x24, 0xb2, 0xaa, 0xb8, 0x71, 0x0c, 0x25, 0x2d, 0x52, 0x5b, 0x95, 0xa8, 0x15, 0x12, 0x1c, 0x8c,
	0xb3, 0x99, 0x24, 0x56, 0x76, 0x77, 0x16, 0xaf, 0x53, 0x6d, 0x78, 0x04, 0x4e, 0x3c, 0x02, 0x8f,
	0xc0, 0x81, 0x23, 0x0f, 0xd0, 0x63, 0xc5, 0x09, 0x71, 0xa8, 0x50, 0x7b, 0x80, 0xc7, 0x40, 0xf6,
	0xb6, 0x49, 0xe8, 0xd1, 0x97, 0xd5, 0x7a, 0x66, 0xf6, 0xf7, 0x9f, 0xb1, 0x67, 0xc7, 0xe4, 0x71,
	0x82, 0xa9, 0xdf, 0x05, 0x88, 0x84, 0x1a, 0x80, 0xf6, 0x4f, 0xb7, 0xfd, 0x44, 0x28, 0x11, 0xa5,
	0xf5, 0x44, 0xa1, 0x46, 0x5a, 0x4e, 0x30, 0xad, 0x8f, 0xdd, 0xf5, 0xd3, 0xed, 0x8d, 0x15, 0x11,
	0xc9, 0x18, 0x7d, 0xfb, 0xcc, 0x83, 0x36, 0x1e, 0x04, 0x98, 0x46, 0x98, 0x72, 0xbb, 0xf2, 0xf3,
	0xc5, 0xb5, 0x6b, 0xad, 0x87, 0x3d, 0xcc, 0xed, 0xe6, 0x2d, 0xb7, 0x6e, 0x7d, 0x2f, 0x91, 0xe5,
	0x26, 0xc0, 0x81, 0x85, 0x1e, 0x59, 0x3d, 0x7a, 0x42, 0x16, 0x23, 0x19, 0xf3, 0x9e, 0x30, 0x1c,
	0x19, 0x00, 0xf3, 0x36, 0xbd, 0xda, 0x7c, 0x63, 0xfb, 0xec, 0xa2, 0x5a, 0xf8, 0x75, 0x51, 0x7d,
	0x98, 0x63, 0xd3, 0xce, 0xa0, 0x2e, 0xd1, 0x8f, 0x84, 0xee, 0xd7, 0xf7, 0xa1, 0x27, 0x82, 0xd1,
	0x0e, 0x04, 0x3f, 0xbe, 0x3d, 0x25, 0xd7, 0xaa, 0x3b, 0x10, 0xb4, 0x4a, 0x91, 0x8c, 0x77, 0x45,
	0x7a, 0x64, 0x28, 0xb4, 0x46, 0xca, 0x6d, 0x91, 0x02, 0xef, 0x02, 0x70, 0x88, 0x45, 0x3b, 0x84,
	0x0e, 0xbb, 0xb3, 0xe9, 0xd5, 0x8a, 0xad, 0x25, 0x63, 0x6f, 0x02, 0xbc, 0xcc, 0xad, 0xf4, 0xdd,
	0x54, 0xa4, 0x8c, 0xa5, 0x96, 0x22, 0x64, 0x33, 0xae, 0x39, 0xdc, 0xc0, 0x5f, 0xe5, 0x20, 0xda,
	0x25, 0xeb, 0x10, 0x8a, 0x54, 0xcb, 0x40, 0xea, 0x11, 0x8f, 0x86, 0xa1, 0x96, 0x49, 0x28, 0x41,
	0xb1, 0xbb, 0xae, 0x0a, 0x6b, 0x13, 0xde, 0xc1, 0x18, 0x67, 0x77, 0x51, 0x64, 0x5c, 0xcb, 0x84,
	0x2b, 0xa1, 0x25, 0xb2, 0x7b, 0xee, 0xbb, 0x28, 0xb2, 0x63, 0x99, 0xb4, 0x0c, 0x85, 0x0e, 0x08,
	0xd3, 0x42, 0xf5, 0x40, 0xf3, 0x76, 0x88, 0xc1, 0x80, 0x0f, 0xb5, 0x0c, 0xe5, 0x47, 0xe3, 0x8a,
	0xd9, 0xac, 0xab, 0xc2, 0xfd, 0x1c, 0xd9, 0x30, 0xc4, 0x93, 0x09, 0x90, 0x3e, 0x22, 0xc4, 0xd6,
	0x90, 0x99, 0x66, 0x60, 0x73, 0x9b, 0x5e, 0x6d, 0xa6, 0x55, 0x34, 0xd9, 0x64, 0xbb, 0x22, 0xa5,
	0x5b, 0x64, 0xb1, 0xab, 0x00, 0x8c, 0xfb, 0xc3, 0x10, 0xb5, 0x60, 0x45, 0x1b, 0x50, 0x32, 0xc6,
	0xe3, 0xec, 0xb5, 0x31, 0xd1, 0x43, 0x32, 0xdf, 0x1e, 0xaa, 0x98, 0x07, 0x88, 0x21, 0x9b, 0x77,
	0xcd, 0xaf, 0x68, 0x18, 0x2f, 0x10, 0x43, 0xda, 0x22, 0x25, 0xcb, 0x8b, 0x51, 0x45, 0x22, 0x64,
	0xc4, 0x95, 0x48, 0x0c, 0xe5, 0xd0, 0x42, 0xe8, 0x3e, 0xb1, 0x7c, 0xde, 0x47, 0xcd, 0x4a, 0xae,
	0xc0, 0x39, 0x83, 0xd8, 0x43, 0x4d, 0x05, 0x59, 0x35, 0x67, 0x62, 0x2b, 0xe6, 0xba, 0xaf, 0x20,
	0xed, 0x63, 0xd8, 0x61, 0x0b, 0xae, 0xe0, 0x15, 0x43, 0x33, 0xb5, 0x1f, 0xdf, 0xb0, 0x28, 0x27,
	0xd4, 0x4a, 0xf4, 0x51, 0x4f, 0x29, 0x2c, 0xba, 0x2a, 0x94, 0x0d, 0x6c, 0x0f, 0xf5, 0x44, 0x40,
	0x90, 0xd5, 0x53, 0x11, 0xca, 0x8e, 0xd0, 0xa8, 0xec, 0x5f, 0x98, 0x77, 0xf0, 0x92, 0x73, 0x0d,
	0x63, 0x5a, 0x13, 0x20, 0xef, 0x63, 0x4e, 0xa8, 0x56, 0x20, 0xd2, 0xa1, 0x1a, 0x4d, 0x29, 0x2c,
	0x3b, 0xd7, 0x70, 0x03, 0x1b, 0x0b, 0xbc, 0x21, 0x4b, 0xa6, 0x77, 0xed, 0xc9, 0xe6, 0xf0, 0xb2,
	0x2b, 0x7c, 0x21, 0x12, 0x59, 0x63, 0xa8, 0xe2, 0x1c, 0xfc, 0x9e, 0xac, 0xfe, 0x37, 0x1e, 0x79,
	0x37, 0x44, 0x54, 0x6c, 0xc5, 0x39, 0xf5, 0xa9, 0x21, 0xd9, 0x34, 0xa8, 0xe7, 0xb5, 0xbf, 0x5f,
	0xaa, 0xde, 0xa7, 0x3f, 0x5f, 0x9f, 0x54, 0xcd, 0x95, 0x90, 0x4d, 0x5d, 0x0a, 0xb7, 0x46, 0x75,
	0xc3, 0x3f, 0xbb, 0xac, 0x78, 0xe7, 0x97, 0x15, 0xef, 0xf7, 0x65, 0xc5, 0xfb, 0x7c, 0x55, 0x29,
	0x9c, 0x5f, 0x55, 0x0a, 0x3f, 0xaf, 0x2a, 0x85, 0xb7, 0xeb, 0xb7, 0x3f, 0xd5, 0xa3, 0x04, 0xd2,
	0xf6, 0xac, 0x1d, 0xfb, 0xcf, 0xfe, 0x05, 0x00, 0x00, 0xff, 0xff, 0x8e, 0x84, 0x98, 0x94, 0x6d,
	0x06, 0x00, 0x00,
}

func (this *FeeMarketParams) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FeeMarketParams)
	if !ok {
		that2, ok := that.(FeeMarketParams)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.MinGasPrice.Equal(that1.MinGasPrice) {
		return false
	}
	if this.BaseFeeEnabled != that1.BaseFeeEnabled {
		return false
	}
	if !this.BaseFeeInitial.Equal(that1.BaseFeeInitial) {
		return false
	}
	if !this.ElasticityMultiplier.Equal(that1.ElasticityMultiplier) {
		return false
	}
	if !this.MaxTipRatio.Equal(that1.MaxTipRatio) {
		return false
	}
	if !this.TargetBlockUtilization.Equal(that1.TargetBlockUtilization) {
		return false
	}
	if this.MaxTxGas != that1.MaxTxGas {
		return false
	}
	if this.FreeTxQuota != that1.FreeTxQuota {
		return false
	}
	if !this.BurnCool.Equal(that1.BurnCool) {
		return false
	}
	if !this.BurnNormal.Equal(that1.BurnNormal) {
		return false
	}
	if !this.BurnHot.Equal(that1.BurnHot) {
		return false
	}
	if !this.UtilCoolThreshold.Equal(that1.UtilCoolThreshold) {
		return false
	}
	if !this.UtilHotThreshold.Equal(that1.UtilHotThreshold) {
		return false
	}
	if !this.ValidatorFeeRatio.Equal(that1.ValidatorFeeRatio) {
		return false
	}
	if !this.TreasuryFeeRatio.Equal(that1.TreasuryFeeRatio) {
		return false
	}
	if !this.MaxBurnRatio.Equal(that1.MaxBurnRatio) {
		return false
	}
	if !this.MinGasPriceFloor.Equal(that1.MinGasPriceFloor) {
		return false
	}
	return true
}
func (m *FeeMarketParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FeeMarketParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FeeMarketParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.MinGasPriceFloor.Size()
		i -= size
		if _, err := m.MinGasPriceFloor.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintParams(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x8a
	{
		size := m.MaxBurnRatio.Size()
		i -= size
		if _, err := m.MaxBurnRatio.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintParams(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x82
	{
		size := m.TreasuryFeeRatio.Size()
		i -= size
		if _, err := m.TreasuryFeeRatio.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintParams(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x7a
	{
		size := m.ValidatorFeeRatio.Size()
		i -= size
		if _, err := m.ValidatorFeeRatio.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintParams(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x72
	{
		size := m.UtilHotThreshold.Size()
		i -= size
		if _, err := m.UtilHotThreshold.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintParams(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x6a
	{
		size := m.UtilCoolThreshold.Size()
		i -= size
		if _, err := m.UtilCoolThreshold.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintParams(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x62
	{
		size := m.BurnHot.Size()
		i -= size
		if _, err := m.BurnHot.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintParams(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x5a
	{
		size := m.BurnNormal.Size()
		i -= size
		if _, err := m.BurnNormal.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintParams(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x52
	{
		size := m.BurnCool.Size()
		i -= size
		if _, err := m.BurnCool.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintParams(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x4a
	if m.FreeTxQuota != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.FreeTxQuota))
		i--
		dAtA[i] = 0x40
	}
	if m.MaxTxGas != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.MaxTxGas))
		i--
		dAtA[i] = 0x38
	}
	{
		size := m.TargetBlockUtilization.Size()
		i -= size
		if _, err := m.TargetBlockUtilization.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintParams(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	{
		size := m.MaxTipRatio.Size()
		i -= size
		if _, err := m.MaxTipRatio.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintParams(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size := m.ElasticityMultiplier.Size()
		i -= size
		if _, err := m.ElasticityMultiplier.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintParams(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size := m.BaseFeeInitial.Size()
		i -= size
		if _, err := m.BaseFeeInitial.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintParams(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.BaseFeeEnabled {
		i--
		if m.BaseFeeEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	{
		size := m.MinGasPrice.Size()
		i -= size
		if _, err := m.MinGasPrice.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintParams(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func encodeVarintParams(dAtA []byte, offset int, v uint64) int {
	offset -= sovParams(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *FeeMarketParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.MinGasPrice.Size()
	n += 1 + l + sovParams(uint64(l))
	if m.BaseFeeEnabled {
		n += 2
	}
	l = m.BaseFeeInitial.Size()
	n += 1 + l + sovParams(uint64(l))
	l = m.ElasticityMultiplier.Size()
	n += 1 + l + sovParams(uint64(l))
	l = m.MaxTipRatio.Size()
	n += 1 + l + sovParams(uint64(l))
	l = m.TargetBlockUtilization.Size()
	n += 1 + l + sovParams(uint64(l))
	if m.MaxTxGas != 0 {
		n += 1 + sovParams(uint64(m.MaxTxGas))
	}
	if m.FreeTxQuota != 0 {
		n += 1 + sovParams(uint64(m.FreeTxQuota))
	}
	l = m.BurnCool.Size()
	n += 1 + l + sovParams(uint64(l))
	l = m.BurnNormal.Size()
	n += 1 + l + sovParams(uint64(l))
	l = m.BurnHot.Size()
	n += 1 + l + sovParams(uint64(l))
	l = m.UtilCoolThreshold.Size()
	n += 1 + l + sovParams(uint64(l))
	l = m.UtilHotThreshold.Size()
	n += 1 + l + sovParams(uint64(l))
	l = m.ValidatorFeeRatio.Size()
	n += 1 + l + sovParams(uint64(l))
	l = m.TreasuryFeeRatio.Size()
	n += 1 + l + sovParams(uint64(l))
	l = m.MaxBurnRatio.Size()
	n += 2 + l + sovParams(uint64(l))
	l = m.MinGasPriceFloor.Size()
	n += 2 + l + sovParams(uint64(l))
	return n
}

func sovParams(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozParams(x uint64) (n int) {
	return sovParams(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *FeeMarketParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowParams
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FeeMarketParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FeeMarketParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinGasPrice", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MinGasPrice.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseFeeEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.BaseFeeEnabled = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseFeeInitial", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.BaseFeeInitial.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ElasticityMultiplier", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ElasticityMultiplier.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxTipRatio", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MaxTipRatio.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetBlockUtilization", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TargetBlockUtilization.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxTxGas", wireType)
			}
			m.MaxTxGas = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxTxGas |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FreeTxQuota", wireType)
			}
			m.FreeTxQuota = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FreeTxQuota |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BurnCool", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.BurnCool.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BurnNormal", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.BurnNormal.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BurnHot", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.BurnHot.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UtilCoolThreshold", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.UtilCoolThreshold.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UtilHotThreshold", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.UtilHotThreshold.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidatorFeeRatio", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ValidatorFeeRatio.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TreasuryFeeRatio", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TreasuryFeeRatio.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxBurnRatio", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MaxBurnRatio.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinGasPriceFloor", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MinGasPriceFloor.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipParams(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthParams
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipParams(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowParams
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowParams
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowParams
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthParams
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupParams
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthParams
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthParams        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowParams          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupParams = fmt.Errorf("proto: unexpected end of group")
)
